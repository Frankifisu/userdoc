

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
<META name="ROBOTS" content="NOINDEX, NOFOLLOW">
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>scm.plams.mol.molecule &mdash; PLAMS 2021.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../../_static/sphinx_tabs/semantic-ui-2.4.1/segment.min.css" type="text/css" />
  
    <link rel="stylesheet" href="../../../../_static/sphinx_tabs/semantic-ui-2.4.1/menu.min.css" type="text/css" />
  
    <link rel="stylesheet" href="../../../../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.css" type="text/css" />
  
    <link rel="stylesheet" href="../../../../_static/sphinx_tabs/tabs.css" type="text/css" />
  
    <link rel="stylesheet" href="../../../../_static/css/theme_tabs.css" type="text/css" />
  
    <link rel="stylesheet" href="../../../../_static/panels-bootstrap.min.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../../search.html"/>
    <link rel="top" title="PLAMS 2021.1 documentation" href="../../../../index.html"/>
        <link rel="up" title="Module code" href="../../../index.html"/> 

  
  <script src="../../../../_static/js/jquery.min.js"></script>
  <script src="../../../../_static/js/bootstrap.min.js"></script>
  <script src="../../../../_static/js/modernizr.min.js"></script>
  <script src="../../../../_static/js/app.js"></script>
<script type="text/javascript">
</script>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NCRWHZZ');</script>
<!-- End Google Tag Manager -->

</head>

<body class="wy-body-for-nav" role="document">
  <!--STARTNOSOLR-->
  <header class="site-header navbar-fixed-top compact">
      <nav class="main navbar navbar-default">
        <div class="headerbar_container">
          <a role="button" href="/free-trial/" class="btn btn-sm btn-primary">Free trial</a>
          <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <div class="navbar-brand">
              <a class="logo" href="https://www.scm.com">
                <img class="logo-small" src="https://www.scm.com/wp-content/themes/scm/images/logos/scm-logo-compact.svg" alt="Software for Chemistry &amp; Materials" />
                <img class="logo-full" src="https://www.scm.com/wp-content/themes/scm/images/logos/scm-logo.svg" alt="Software for Chemistry &amp; Materials" />
              </a>
            </div>
          </div>
          <div class="nav-wrapper">
            <div class="collapse navbar-collapse">
              <ul id="menu-primary-navigation" class="nav navbar-nav"><li id="menu-item-40077" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-40077"><a title="Applications" href="https://www.scm.com/applications/">Applications</a></li>
<li id="menu-item-35" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-35"><a title="Products" href="https://www.scm.com/amsterdam-modeling-suite/">Products</a></li>
<li id="menu-item-36" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-36"><a title="Support" href="https://www.scm.com/support/">Support</a></li>
<li id="menu-item-37" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-37"><a title="About us" href="https://www.scm.com/about-us/">About us</a></li>
</ul>                           <span class="search"><a class="menu_search_link" href="https://www.scm.com/search.php"></a><span class="sr-only">Search</span></span>
            </div>
          </div>
        </div>
      </nav>
 </header>
    

   
  <div id="doc-wrapper">
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html">
          

          
            
            <img src="../../../../_static/plams_logo.png" class="logo" />
          
          </a>

          
          
  <ul>
      <li class="wy-breadcrumbs-aside">
        
           
           
        
      </li>
  </ul>
 
<!--ENDNOSOLR-->
             <!--STARTNOSOLR-->
<div role="search">
  <form id="rtd-search-form" class="wy-form search-docs-form" action="https://www.scm.com/search.php" method="get">
  <div class="input-group">
    <input type="text" name="search" placeholder="Search PLAMS" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
    <input type="hidden" name="root" value="doctrunk" />


    <input type="hidden" name="cat" value="doc-scripting" />


    <span class="input-group-btn">
			<button type="submit" class="btn btn-primary"><span class="sr-only">Search</span><span class="fa fa-search"></span></button>
		</span>
	</div>
  </form>
</div>
<!--ENDNOSOLR-->
          

          
        </div>
<!--STARTNOSOLR-->
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../intro.html#what-is-plams">What is PLAMS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../intro.html#what-can-be-done-with-plams">What can be done with PLAMS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../intro.html#simple-example">Simple example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../intro.html#what-plams-is-not">What PLAMS is <em>not</em></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../intro.html#about-this-documentation">About this documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../started.html">Getting started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../started.html#library-contents">Library contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../started.html#installing-plams">Installing PLAMS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../started.html#updating-plams">Updating PLAMS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../started.html#running-plams">Running PLAMS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../started.html#defaults-file">Defaults file</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../started.html#the-launch-script">The launch script</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../started.html#working-folder-location">Working folder location</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../started.html#passing-variables">Passing variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../started.html#importing-past-jobs">Importing past jobs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../started.html#restarting-failed-script">Restarting failed script</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../started.html#multiple-input-scripts">Multiple input scripts</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../components/components.html">Components overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../components/settings.html">Settings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/settings.html#tree-like-structure">Tree-like structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/settings.html#dot-notation">Dot notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/settings.html#case-sensitivity">Case sensitivity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/settings.html#global-settings">Global settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/settings.html#api">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../components/jobs.html">Jobs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/jobs.html#preparing-a-job">Preparing a job</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../components/jobs.html#contents-of-job-settings">Contents of job settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../components/jobs.html#default-settings">Default settings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/jobs.html#running-a-job">Running a job</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../components/jobs.html#name-conflicts">Name conflicts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../components/jobs.html#prerun-and-postrun-methods">Prerun and postrun methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../components/jobs.html#preview-mode">Preview mode</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/jobs.html#job-api">Job API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/jobs.html#single-jobs">Single jobs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../components/jobs.html#subclassing-singlejob">Subclassing SingleJob</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/jobs.html#multijobs">Multijobs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../components/jobs.html#using-multijob">Using MultiJob</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../components/results.html">Results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/results.html#files-in-the-job-folder">Files in the job folder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/results.html#synchronization-of-parallel-job-executions">Synchronization of parallel job executions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../components/results.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/results.html#cleaning-job-folder">Cleaning job folder</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../components/results.html#cleaning-for-multijobs">Cleaning for multijobs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/results.html#api">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../components/runners.html">Job runners</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/runners.html#local-job-runner">Local job runner</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/runners.html#remote-job-runner">Remote job runner</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../components/jobmanager.html">Job manager</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/jobmanager.html#rerun-prevention">Rerun prevention</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/jobmanager.html#pickling">Pickling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/jobmanager.html#restarting-scripts">Restarting scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/jobmanager.html#api">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../components/functions.html">Public functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/functions.html#logging">Logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/functions.html#binding-decorators">Binding decorators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../components/molecule.html">Molecule</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/mol_api.html">Molecule</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../components/mol_api.html#atom-labeling">Atom labeling</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/atombond.html">Atom</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/atombond.html#bond">Bond</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/mol_rdkit.html">RDKit interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/mol_ase.html">ASE interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../components/utils.html">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/utils.html#periodic-table">Periodic Table</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/utils.html#units">Units</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/utils.html#geometry-tools">Geometry tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/utils.html#file-format-conversion-tools">File format conversion tools</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../components/trajectories.html">Trajectories</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/xyz.html">XYZ trajectory files</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../components/xyz.html#xyz-history-files">XYZ history files</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/rkf.html">RKF trajectory files</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../components/rkf.html#rkf-history-files">RKF history files</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../components/dcd.html">DCD trajectory files</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../interfaces/interfaces.html">Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../interfaces/amssuite.html">Amsterdam Modeling Suite</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/ams.html">AMS driver and engines</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/ams.html#preparing-input">Preparing input</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/ams.html#preparing-runscript">Preparing runscript</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/ams.html#molecule-handling">Molecule handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/ams.html#amsjob-api">AMSJob API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/ams.html#amsresults-api">AMSResults API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/amsworker.html">AMS worker</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/amsworker.html#amsworker-api">AMSWorker API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/amsworker.html#amsworkerresults-api">AMSWorkerResults API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/amsworker.html#amsworkerpool-api">AMSWorkerPool API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/postadf.html">Analysis tools: Densf, FCF, analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/kffiles.html">KF files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/crs.html">COSMO-RS</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/crs.html#settings">Settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/crs.html#settings-with-multiple-compound">Settings with multiple compound</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/crs.html#adf-and-crsjob">ADF and CRSJob</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/crs.html#cosmo-rs-parameters">COSMO-RS Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/crs.html#data-analyses-and-plotting">Data analyses and plotting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/crs.html#api">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/adf.html">ADF (pre-2020 version)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/adf.html#preparing-input">Preparing input</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/adf.html#preparing-runscript">Preparing runscript</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/adf.html#api">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/reaxff.html">ReaxFF (pre-2019 version)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../interfaces/thirdparty.html">Other programs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/cp2k.html">CP2K</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/cp2k.html#settings">Settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/cp2k.html#molecule-parsing">Molecule parsing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/cp2k.html#loading-jobs">Loading jobs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/cp2k.html#molecule-loading">Molecule loading</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/cp2k.html#api">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/crystal.html">Crystal</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/crystal.html#preparing-a-calculation">Preparing a calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/crystal.html#molecule-parsing">Molecule parsing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/crystal.html#results-extraction">Results extraction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/crystal.html#example">Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/crystal.html#api">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/dftbplus.html">DFTB+</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/dftbplus.html#preparing-a-calculation">Preparing a calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/dftbplus.html#results-extraction">Results extraction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/dftbplus.html#example">Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/dftbplus.html#api">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/dirac.html">Dirac</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/dirac.html#preparing-a-calculation">Preparing a calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/dirac.html#results-extraction">Results extraction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/dirac.html#api">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/mopac.html">MOPAC (standalone program)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/mopac.html#preparing-input">Preparing input</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/mopac.html#api">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/orca.html">ORCA</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/orca.html#api">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../interfaces/raspa.html">RASPA</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/raspa.html#input">Input</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/raspa.html#molecule-parsing">Molecule parsing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/raspa.html#loading-jobs">Loading jobs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../interfaces/raspa.html#api">API</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples/examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../examples/examples.html#id1">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/He2DissociationCurve.html">Helium dimer dissociation curve</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/WaterOptimization.html">Geometry optimization of water</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/ManyJobsInParallel.html">Many jobs in parallel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/BasisSetBenchmark.html">Benchmark accuracy of basis sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/ExcitationsWorkflow.html">Workflow: filtering molecules based on excitation energies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/ChargeTransferIntegralsADF.html">Charge transfer integrals with ADF</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/gammascan.html">Tuning the range separation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../examples/examples.html#pre-made-recipes">Pre-made recipes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/ams_crs.html">ADF and COSMO-RS workflow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/adffragment.html">ADF fragment job</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/ReorganizationEnergy.html">Reorganization Energy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/adfnbo.html">NBO with ADF</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/numgrad.html">Numerical gradients</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/numhess.html">Numerical Hessian</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/molecule_gun.html">ReaxFF molecule gun</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/global_minimum.html">Global Minimum Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../examples/vibrationASE.html">Vibrational analysis with ASE</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../examples/vibrationASE.html#example">Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../examples/vibrationASE.html#api">API</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cookbook/cookbook.html">Cookbook</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../cookbook/cookbook.html#settings-and-input">Settings and input</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#create-an-input-block-with-an-header">Create an input block with an header</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#create-an-empty-input-block">Create an empty input block</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#convert-an-ams-text-input-into-an-ams-job">Convert an AMS text input into an AMS job</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#convert-an-ams-text-input-into-settings-object">Convert an AMS text input into settings object</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#convert-an-ams-run-file-into-an-amsjob">Convert an AMS .run file into an AMSJob</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#specify-paths-to-files-in-the-input">Specify paths to files in the input</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#restart-from-a-previous-job">Restart from a previous job</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../cookbook/cookbook.html#molecules">Molecules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#generate-a-molecule-from-a-smiles-string">Generate a molecule from a SMILES string</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#counting-rings">Counting rings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../cookbook/cookbook.html#extracting-results">Extracting Results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#directly-from-functions">Directly from Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../cookbook/cookbook.html#examples-total-energy-and-final-structure">Examples: Total Energy and Final Structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../cookbook/cookbook.html#amsresults-api-functions">AMSResults API Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#from-the-rkf-interface">From the RKF Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#finding-section-variable-pairs">Finding Section/Variable Pairs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../cookbook/cookbook.html#from-python-directories">From Python Directories</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../cookbook/cookbook.html#kfbrowser">KFBrowser</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#from-molecular-dynamics-trajectories">From molecular dynamics trajectories</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../cookbook/cookbook.html#general-md-properties">General MD properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../cookbook/cookbook.html#molecules-from-trajectories">Molecules from trajectories</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../cookbook/cookbook.html#accessing-old-jobs">Accessing Old Jobs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#binding-native-plams-jobs">Binding Native PLAMS Jobs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../cookbook/cookbook.html#binding-old-rkf-files">Binding old RKF Files</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../citations.html">Citations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../index.html">PLAMS</a>
      </nav>
<!--ENDNOSOLR-->

      
      <div class="wy-nav-content">
        <div class="rst-content">
        <!--STARTNOSOLR-->
<div class="header" role="navigation" aria-label="breadcrumbs navigation">
 
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../PLAMS.html/../../Documentation/index.html">Documentation</a>/</li>
    <li><a href="../../../../index.html">PLAMS</a>/</li>
      
          <li><a href="../../../index.html">Module code</a>/</li>
      
    <li class="orange-text">scm.plams.mol.molecule</li>
  </ul>
  <p>
 
</div>
<!--ENDNOSOLR-->
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for scm.plams.mol.molecule</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">io</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>

<span class="kn">from</span> <span class="nn">.atom</span> <span class="k">import</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">.bond</span> <span class="k">import</span> <span class="n">Bond</span>
<span class="kn">from</span> <span class="nn">.pdbtools</span> <span class="k">import</span> <span class="n">PDBHandler</span><span class="p">,</span> <span class="n">PDBRecord</span>

<span class="kn">from</span> <span class="nn">..core.errors</span> <span class="k">import</span> <span class="n">MoleculeError</span><span class="p">,</span> <span class="n">PTError</span><span class="p">,</span> <span class="n">FileError</span>
<span class="kn">from</span> <span class="nn">..core.functions</span> <span class="k">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">..core.private</span> <span class="k">import</span> <span class="n">smart_copy</span><span class="p">,</span> <span class="n">parse_action</span>
<span class="kn">from</span> <span class="nn">..core.settings</span> <span class="k">import</span> <span class="n">Settings</span>
<span class="kn">from</span> <span class="nn">..tools.periodic_table</span> <span class="k">import</span> <span class="n">PT</span>
<span class="kn">from</span> <span class="nn">..tools.geometry</span> <span class="k">import</span> <span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">axis_rotation_matrix</span><span class="p">,</span> <span class="n">distance_array</span><span class="p">,</span> <span class="n">cell_lengths</span><span class="p">,</span> <span class="n">cell_angles</span>
<span class="kn">from</span> <span class="nn">..tools.units</span> <span class="k">import</span> <span class="n">Units</span>
<span class="kn">from</span> <span class="nn">..tools.kftools</span> <span class="k">import</span> <span class="n">KFFile</span>

<span class="n">input_parser_available</span> <span class="o">=</span> <span class="s1">&#39;AMSBIN&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Molecule&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="Molecule"><a class="viewcode-back" href="../../../../components/mol_ase.html#scm.plams.mol.molecule.Molecule">[docs]</a><span class="k">class</span> <span class="nc">Molecule</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A class representing the molecule object.</span>

<span class="sd">    An instance of this class has the following attributes:</span>

<span class="sd">    *   ``atoms`` -- list of |Atom| objects that belong to the molecule</span>
<span class="sd">    *   ``bonds`` -- list of |Bond| objects between atoms listed in ``atoms``</span>
<span class="sd">    *   ``lattice`` -- list of lattice vectors in case of periodic structures</span>
<span class="sd">    *   ``properties`` -- |Settings| instance storing all other information about the molecule</span>

<span class="sd">    .. note::</span>

<span class="sd">        Each |Atom| in ``atoms`` list and each |Bond| in ``bonds`` list has a reference to the parent molecule. Moreover, each atom stores the list of bonds it&#39;s a part of and each bond stores references to atoms it bonds. That creates a complex net of references between objects that are part of a molecule. Consistency of this data is crucial for proper functioning of many methods. Because of that it is advised not to modify contents of ``atoms`` and ``bonds`` by hand. When you need to alter your molecule, methods :meth:`add_atom`, :meth:`delete_atom`, :meth:`add_bond` and :meth:`delete_bond` can be used to ensure that all these references are updated properly.</span>

<span class="sd">    Creating a |Molecule| object for your calculation can be done in several ways. You can start with an empty molecule and manually add all atoms (and bonds, if needed)::</span>

<span class="sd">        mol = Molecule()</span>
<span class="sd">        mol.add_atom(Atom(atnum=1, coords=(0,0,0)))</span>
<span class="sd">        mol.add_atom(Atom(atnum=1, coords=(d,0,0)))</span>

<span class="sd">    This approach can be useful for building small molecules, especially if you wish to parametrize some of atomic coordinates (like in :ref:`simple_example`), but in general it&#39;s not very practical.</span>
<span class="sd">    If coordinates and atom numbers are available, instantiation can be done by passing a value to the `positions`, `numbers` and optionally the `lattice` arguments::</span>

<span class="sd">        xyz     = np.random.randn(10,3) # 10 atoms, 3 coordinates per atom</span>
<span class="sd">        numbers = 10*[6] # 10 carbon atoms. If left None, will initialize to dummy atoms</span>
<span class="sd">        lattice = [[1,2,3], [1,2,3]] # lattice should have a shape of {1,2,3}x3</span>
<span class="sd">        mol     = Molecule(positions=xyz, numbers=numbers, lattice=lattice)</span>

<span class="sd">    Alternatively, one can import atomic coordinates from some external file::</span>

<span class="sd">        mol = Molecule(&#39;xyz/Benzene.xyz&#39;)</span>

<span class="sd">    The constructor of a |Molecule| object accepts four arguments that can be used to supply this information from a file in your filesystem. *filename* should be a string with a path (absolute or relative) to such a file. *inputformat* describes the format of the file. Currently, the following formats are supported: ``xyz``, ``mol``, ``mol2`` and ``pdb``. If *inputformat* is ``ase`` the file reader engine of the ASE.io module is used, enabling you to read all input formats supported by :ref:`ASEInterface`. See :meth:`read` for further details. If the *inputformat* argument is not supplied, PLAMS will try to deduce it by examining the extension of the provided file, so in most of cases it is not needed to use *inputformat*, if only the file has the proper extension. Some formats (``xyz`` and ``pdb``) allow to store more than one geometry of a particular molecule within a single file. See the respective :meth:`read` function for details how to access them. All *other* keyword arguments will be passed to the appropriate read function for the selected or determined file format.</span>

<span class="sd">    If a |Molecule| is initialized from an external file, the path to this file (*filename* argument) is stored in ``properties.source``. The base name of the file (filename without the extension) is kept in ``properties.name``.</span>

<span class="sd">    It is also possible to write a molecule to a file in one of the formats mentioned above or using the ASE.io engine. See :meth:`write` for details.</span>

<span class="sd">    The ``lattice`` attribute is used to store information about lattice vectors in case of periodic structures. Some job types will automatically use that data while constructing input files. ``lattice`` should be a list of up to 3 vectors (for different types of periodicity: chain, slab or bulk), each of which needs to be a list or a tuple of 3 numbers.</span>

<span class="sd">    Lattice vectors can be directly read from and written to ``xyz`` files using the following convention (please mind the fact that this is an unofficial extension to the XYZ format):</span>

<span class="sd">    .. code-block:: none</span>

<span class="sd">        3</span>

<span class="sd">            H      0.000000      0.765440     -0.008360</span>
<span class="sd">            O      0.000000      0.000000      0.593720</span>
<span class="sd">            H      0.000000     -0.765440     -0.008360</span>
<span class="sd">        VEC1       3.000000      0.000000      0.000000</span>
<span class="sd">        VEC2       0.000000      3.000000      0.000000</span>
<span class="sd">        VEC3       0.000000      0.000000      3.000000</span>

<span class="sd">    For 1D (2D) periodicity please supply only ``VEC1`` (``VEC1`` and ``VEC2``). Writing lattice vectors to ``xyz`` files can be disabled by simply reseting the ``lattice`` attribute::</span>

<span class="sd">        mol.lattice = []</span>


<span class="sd">    The detailed description of all available methods is presented below. Many of these methods require arguments that are atoms belonging to the current molecule. It can by done by using a reference to an |Atom| object present it the ``atoms`` list, but not by passing a number of an atom (its position within ``atoms`` list). Unlike some other tools, PLAMS does not use integer numbers as primary identifiers of atoms. It is done to prevent problems when atoms within a molecule are reordered or some atoms are deleted. References to |Atom| or |Bond| objects can be obtained directly from ``atoms`` or ``bonds`` lists, or with dictionary-like bracket notation::</span>

<span class="sd">        &gt;&gt;&gt; mol = Molecule(&#39;xyz/Ammonia.xyz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; mol.guess_bonds()</span>
<span class="sd">        &gt;&gt;&gt; print(mol)</span>
<span class="sd">          Atoms:</span>
<span class="sd">            1         H      0.942179      0.000000     -0.017370</span>
<span class="sd">            2         H     -0.471089      0.815951     -0.017370</span>
<span class="sd">            3         N      0.000000      0.000000      0.383210</span>
<span class="sd">            4         H     -0.471089     -0.815951     -0.017370</span>
<span class="sd">          Bonds:</span>
<span class="sd">           (1)--1.0--(3)</span>
<span class="sd">           (2)--1.0--(3)</span>
<span class="sd">           (3)--1.0--(4)</span>
<span class="sd">        &gt;&gt;&gt; at = mol[1]</span>
<span class="sd">        &gt;&gt;&gt; print(at)</span>
<span class="sd">                 H      0.942179      0.000000     -0.017370</span>
<span class="sd">        &gt;&gt;&gt; b = mol[(1,3)]</span>
<span class="sd">        &gt;&gt;&gt; print(b)</span>
<span class="sd">        (         H      0.942179      0.000000     -0.017370 )--1.0--(         N      0.000000      0.000000      0.383210 )</span>
<span class="sd">        &gt;&gt;&gt; b = mol[(1,4)]</span>
<span class="sd">        &gt;&gt;&gt; print(b)</span>
<span class="sd">        None</span>

<span class="sd">    .. note::</span>

<span class="sd">        For the purpose of ``mol[i]`` notation, the numbering of atoms within a molecule starts with 1. Negative integers can be used to access atoms enumerated in the reversed order (``mol[-1]`` for the last atom etc.)</span>

<span class="sd">    However, if you feel more familiar with identifying atoms by natural numbers, you can use :meth:`set_atoms_id` to equip each atom of the molecule with ``id`` attribute equal to atom&#39;s position within ``atoms`` list. This method can also be helpful to track changes in your molecule during tasks that can reorder atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Molecule.__init__"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inputformat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numbers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="n">Settings</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">inputformat</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">filename</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filename</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">positions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">positions</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;`Positions` must be a 2d array&quot;</span>
            <span class="k">assert</span> <span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;Inner dim of `positions` must be 3&quot;</span>
            <span class="k">if</span> <span class="n">numbers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">numbers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="n">f</span><span class="s2">&quot;Length or `numbers` and `positions` does not match&quot;</span>
            <span class="k">for</span> <span class="n">num</span><span class="p">,</span><span class="n">xyz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span> <span class="n">Atom</span><span class="p">(</span><span class="n">atnum</span><span class="o">=</span><span class="n">num</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">lattice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">lattice</span><span class="o">.</span><span class="n">ndim</span>      <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;`Lattice` must be a 2d array&quot;</span>
                <span class="k">assert</span> <span class="n">lattice</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;`Lattice` shoud be a 3x3 vector at most&quot;</span>
                <span class="k">assert</span> <span class="n">lattice</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;Inner dim of `lattice` must be 3&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>



<span class="c1">#===========================================================================</span>
<span class="c1">#==== Atoms/bonds manipulation =============================================</span>
<span class="c1">#===========================================================================</span>


<div class="viewcode-block" id="Molecule.copy"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the molecule. The copy has atoms, bonds and all other components distinct from the original molecule (it is so called &quot;deep copy&quot;).</span>

<span class="sd">        By default the entire molecule is copied. It is also possible to copy only some part of the molecule, indicated by *atoms* argument. It should be a list of atoms that belong to the molecule. If used, only these atoms, together with any bonds between them, are copied and included in the returned molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">smart_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owncopy</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span> <span class="n">without</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">,</span><span class="s1">&#39;bonds&#39;</span><span class="p">])</span>

        <span class="n">bro</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># mapping of original to copied atoms</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="n">at_copy</span> <span class="o">=</span> <span class="n">smart_copy</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">owncopy</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span> <span class="n">without</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;mol&#39;</span><span class="p">,</span><span class="s1">&#39;bonds&#39;</span><span class="p">])</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">at_copy</span><span class="p">)</span>
            <span class="n">bro</span><span class="p">[</span><span class="n">at</span><span class="p">]</span> <span class="o">=</span> <span class="n">at_copy</span>

        <span class="k">for</span> <span class="n">bo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bo</span><span class="o">.</span><span class="n">atom1</span> <span class="ow">in</span> <span class="n">bro</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bo</span><span class="o">.</span><span class="n">atom2</span> <span class="ow">in</span> <span class="n">bro</span><span class="p">):</span>
                <span class="n">bo_copy</span> <span class="o">=</span> <span class="n">smart_copy</span><span class="p">(</span><span class="n">bo</span><span class="p">,</span> <span class="n">owncopy</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span> <span class="n">without</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;atom1&#39;</span><span class="p">,</span> <span class="s1">&#39;atom2&#39;</span><span class="p">,</span> <span class="s1">&#39;mol&#39;</span><span class="p">])</span>
                <span class="n">bo_copy</span><span class="o">.</span><span class="n">atom1</span> <span class="o">=</span> <span class="n">bro</span><span class="p">[</span><span class="n">bo</span><span class="o">.</span><span class="n">atom1</span><span class="p">]</span>
                <span class="n">bo_copy</span><span class="o">.</span><span class="n">atom2</span> <span class="o">=</span> <span class="n">bro</span><span class="p">[</span><span class="n">bo</span><span class="o">.</span><span class="n">atom2</span><span class="p">]</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">bo_copy</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="Molecule.add_molecule"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.add_molecule">[docs]</a>    <span class="k">def</span> <span class="nf">add_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add some *other* molecule to this one::</span>

<span class="sd">            protein += water</span>

<span class="sd">        If *copy* is ``True``, *other* molecule is copied and the copy is added to this molecule. Otherwise, *other* molecule is directly merged with this one</span>
<span class="sd">        The ``properties`` of this molecule are :meth:`soft_updated&lt;scm.plams.core.settings.Settings.soft_update&gt;` with the  ``properties`` of the *other* molecules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">other</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">bonds</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">bond</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">soft_update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.add_atom"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.add_atom">[docs]</a>    <span class="k">def</span> <span class="nf">add_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new *atom* to the molecule.</span>

<span class="sd">        *atom* should be an |Atom| instance that does not belong to any molecule. Bonds between the new atom and other atoms of the molecule can be automatically added based on *adjacent* argument. It should be a list describing atoms of the molecule that the new atom is connected to. Each element of *adjacent* list can either be a pair ``(Atom, order)`` to indicate new bond&#39;s order (use ``Bond.AR`` for aromatic bonds) or an |Atom| instance (a single bond is created in this case).</span>

<span class="sd">        Example::</span>

<span class="sd">            mol = Molecule() #create an empty molecule</span>
<span class="sd">            h1 = Atom(symbol=&#39;H&#39;, coords=(1.0, 0.0, 0.0))</span>
<span class="sd">            h2 = Atom(symbol=&#39;H&#39;, coords=(-1.0, 0.0, 0.0))</span>
<span class="sd">            o = Atom(symbol=&#39;O&#39;, coords=(0.0, 1.0, 0.0))</span>
<span class="sd">            mol.add_atom(h1)</span>
<span class="sd">            mol.add_atom(h2)</span>
<span class="sd">            mol.add_atom(o)</span>
<span class="sd">            mol.add_atom(Atom(symbol=&#39;C&#39;, coords=(0.0, 0.0, 0.0)), adjacent=[h1, h2, (o,2)])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="n">atom</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">adjacent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">adj</span> <span class="ow">in</span> <span class="n">adjacent</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">adj</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="o">*</span><span class="n">adj</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.delete_atom"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.delete_atom">[docs]</a>    <span class="k">def</span> <span class="nf">delete_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete an *atom* from the molecule.</span>

<span class="sd">        *atom* should be an |Atom| instance that belongs to the molecule. All bonds containing this atom are removed too.</span>

<span class="sd">        Examples::</span>

<span class="sd">            #delete all hydrogens</span>
<span class="sd">            mol = Molecule(&#39;protein.pdb&#39;)</span>
<span class="sd">            hydrogens = [atom for atom in mol if atom.atnum == 1]</span>
<span class="sd">            for i in hydrogens: mol.delete_atom(i)</span>

<span class="sd">        ::</span>

<span class="sd">            #delete first two atoms</span>
<span class="sd">            mol = Molecule(&#39;geom.xyz&#39;)</span>
<span class="sd">            mol.delete_atom(mol[1])</span>
<span class="sd">            mol.delete_atom(mol[1]) #since the second atom of original molecule is now the first</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">mol</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;delete_atom: passed atom should belong to the molecule&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;delete_atom: invalid argument passed as atom&#39;</span><span class="p">)</span>
        <span class="n">atom</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete_bond</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.add_bond"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.add_bond">[docs]</a>    <span class="k">def</span> <span class="nf">add_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new bond to the molecule.</span>

<span class="sd">        This method can be used in two different ways. You can call it with just one argument being a |Bond| instance (other arguments are then ignored)::</span>

<span class="sd">            &gt;&gt;&gt; b = Bond(mol[2], mol[4], order=Bond.AR) #create aromatic bond between 2nd and 4th atom</span>
<span class="sd">            &gt;&gt;&gt; mol.add_bond(b)</span>

<span class="sd">        The other way is to pass two atoms (and possibly bond order) and new |Bond| object will be created automatically::</span>

<span class="sd">            &gt;&gt;&gt; mol.add_bond(mol[2], mol[4], order=Bond.AR)</span>

<span class="sd">        In both cases both atoms that are bonded have to belong to the molecule, otherwise an exception is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg2</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">newbond</span> <span class="o">=</span> <span class="n">Bond</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">Bond</span><span class="p">):</span>
            <span class="n">newbond</span> <span class="o">=</span> <span class="n">arg1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;add_bond: invalid arguments passed&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">newbond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">mol</span> <span class="o">==</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">newbond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">mol</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">newbond</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newbond</span><span class="p">)</span>
            <span class="n">newbond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newbond</span><span class="p">)</span>
            <span class="n">newbond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newbond</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;add_bond: bonded atoms have to belong to the molecule&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.delete_bond"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.delete_bond">[docs]</a>    <span class="k">def</span> <span class="nf">delete_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a bond from the molecule.</span>

<span class="sd">        Just like :meth:`add_bond`, this method accepts either a single argument that is a |Bond| instance, or two arguments being instances of |Atom|. In both cases objects used as arguments have to belong to the molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg2</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">delbond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_bond</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">Bond</span><span class="p">):</span>
            <span class="n">delbond</span> <span class="o">=</span> <span class="n">arg1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;delete_bond: invalid arguments passed&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">delbond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">delbond</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">delbond</span><span class="p">)</span>
            <span class="n">delbond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">delbond</span><span class="p">)</span>
            <span class="n">delbond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">delbond</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.delete_all_bonds"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.delete_all_bonds">[docs]</a>    <span class="k">def</span> <span class="nf">delete_all_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete all bonds from the molecule.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete_bond</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.find_bond"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.find_bond">[docs]</a>    <span class="k">def</span> <span class="nf">find_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find and return a bond between *atom1* and *atom2*. Both atoms have to belong to the molecule. If no bond between chosen atoms exists, the retured value is ``None``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom1</span><span class="o">.</span><span class="n">mol</span> <span class="o">!=</span> <span class="bp">self</span> <span class="ow">or</span> <span class="n">atom2</span><span class="o">.</span><span class="n">mol</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;find_bond: atoms passed as arguments have to belong to the molecule&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom1</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom2</span> <span class="ow">is</span> <span class="n">b</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">atom1</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">b</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Molecule.set_atoms_id"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.set_atoms_id">[docs]</a>    <span class="k">def</span> <span class="nf">set_atoms_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equip each atom of the molecule with the ``id`` attribute equal to its position within ``atoms`` list.</span>

<span class="sd">        The starting value of the numbering can be set with *start* (starts at 1 by default).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">at</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
            <span class="n">at</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span></div>


<div class="viewcode-block" id="Molecule.unset_atoms_id"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.unset_atoms_id">[docs]</a>    <span class="k">def</span> <span class="nf">unset_atoms_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete ``id`` attributes of all atoms.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">at</span><span class="o">.</span><span class="n">id</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span></div>


<div class="viewcode-block" id="Molecule.neighbors"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of neighbors of *atom* within the molecule.</span>

<span class="sd">        *atom* has to belong to the molecule. Returned list follows the same order as the ``bonds`` attribute of *atom*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">mol</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;neighbors: passed atom should belong to the molecule&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">]</span></div>


<div class="viewcode-block" id="Molecule.bond_matrix"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.bond_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">bond_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a square numpy array with bond orders. The size of the array is equal to the number of atoms.&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_atoms_id</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">id</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unset_atoms_id</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="Molecule.separate"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.separate">[docs]</a>    <span class="k">def</span> <span class="nf">separate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Separate the molecule into connected components.</span>

<span class="sd">        Returned is a list of new |Molecule| objects (all atoms and bonds are disjoint with the original molecule). Each element of this list is identical to one connected component of the base molecule. A connected component is a subset of atoms such that there exists a path (along one or more bonds) between any two atoms. Usually these connected components are molecules.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; mol = Molecule(&#39;xyz_dimers/NH3-H2O.xyz&#39;)</span>
<span class="sd">            &gt;&gt;&gt; mol.guess_bonds()</span>
<span class="sd">            &gt;&gt;&gt; print(mol)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         N     -1.395591     -0.021564      0.000037</span>
<span class="sd">                2         H     -1.629811      0.961096     -0.106224</span>
<span class="sd">                3         H     -1.862767     -0.512544     -0.755974</span>
<span class="sd">                4         H     -1.833547     -0.330770      0.862307</span>
<span class="sd">                5         O      1.568501      0.105892      0.000005</span>
<span class="sd">                6         H      0.606736     -0.033962     -0.000628</span>
<span class="sd">                7         H      1.940519     -0.780005      0.000222</span>
<span class="sd">              Bonds:</span>
<span class="sd">               (5)--1.0--(7)</span>
<span class="sd">               (5)--1.0--(6)</span>
<span class="sd">               (1)--1.0--(3)</span>
<span class="sd">               (1)--1.0--(4)</span>
<span class="sd">               (1)--1.0--(2)</span>
<span class="sd">            &gt;&gt;&gt; x = mol.separate()</span>
<span class="sd">            &gt;&gt;&gt; for i in x: print(i)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         N     -1.395591     -0.021564      0.000037</span>
<span class="sd">                2         H     -1.629811      0.961096     -0.106224</span>
<span class="sd">                3         H     -1.862767     -0.512544     -0.755974</span>
<span class="sd">                4         H     -1.833547     -0.330770      0.862307</span>
<span class="sd">              Bonds:</span>
<span class="sd">               (1)--1.0--(3)</span>
<span class="sd">               (1)--1.0--(4)</span>
<span class="sd">               (1)--1.0--(2)</span>

<span class="sd">              Atoms:</span>
<span class="sd">                1         O      1.568501      0.105892      0.000005</span>
<span class="sd">                2         H      0.606736     -0.033962     -0.000628</span>
<span class="sd">                3         H      1.940519     -0.780005      0.000222</span>
<span class="sd">              Bonds:</span>
<span class="sd">               (1)--1.0--(3)</span>
<span class="sd">               (1)--1.0--(2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">clone</span><span class="p">:</span>
            <span class="n">at</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
            <span class="n">v</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">v</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">mol</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">mol</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span><span class="o">.</span><span class="n">_visited</span><span class="p">:</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">mol</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">clone</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">src</span><span class="o">.</span><span class="n">_visited</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">()</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">frags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">frags</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span>

        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">clone</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">at</span><span class="o">.</span><span class="n">_visited</span>
            <span class="n">at</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">clone</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">frags</span></div>


<div class="viewcode-block" id="Molecule.guess_bonds"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.guess_bonds">[docs]</a>    <span class="k">def</span> <span class="nf">guess_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="mf">1.28</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to guess bonds in the molecule based on types and positions of atoms.</span>

<span class="sd">        All previously existing bonds are removed. New bonds are generated based on interatomic distances and information about maximal number of bonds for each atom type (``connectors`` property, taken from |PeriodicTable|).</span>

<span class="sd">        The problem of finding molecular bonds for a given set of atoms in space does not have a general solution, especially considering the fact the chemical bond in itself is not a precisely defined concept. For every method, no matter how sophisticated, there will always be corner cases for which the method produces disputable results. Moreover, depending on the context (area of application) the desired solution for a particular geometry may vary. Please do not treat this method as an oracle always providing a proper solution. The algorithm used here gives very good results for geometries that are not very far from the optimal geometry, especially consisting of lighter atoms. All kinds of organic molecules, including aromatic ones, usually work very well. Problematic results can emerge for transition metal complexes, transition states, incomplete molecules etc.</span>

<span class="sd">        The algorithm used scales as *n log n* where *n* is the number of atoms.</span>

<span class="sd">        The *atom_subset* argument can be used to limit the bond guessing to a subset of atoms, it should be an iterable container with atoms belonging to this molecule.</span>

<span class="sd">        The *dmax* argument gives the maximum value for ratio of the bond length to the sum of atomic radii for the two atoms in the bond.</span>

<span class="sd">        The bond order for any bond to a metal atom will be set to 1.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This method works reliably only for geometries representing complete molecules. If some atoms are missing (for example, a protein without hydrogens) the resulting set of bonds would usually contain more bonds or bonds with higher order than expected.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">class</span> <span class="nc">HeapElement</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">):</span>
                <span class="n">eff_ord</span> <span class="o">=</span> <span class="n">order</span>
                <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mf">1.5</span><span class="p">:</span> <span class="c1">#effective order for aromatic bonds</span>
                    <span class="n">eff_ord</span> <span class="o">=</span> <span class="mf">1.15</span>
                <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">{</span><span class="n">atom1</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">atom2</span><span class="o">.</span><span class="n">symbol</span><span class="p">}</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">}:</span>
                    <span class="n">eff_ord</span> <span class="o">=</span> <span class="mf">1.11</span> <span class="c1">#effective order for single C-N bond</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">eff_ord</span> <span class="o">+</span> <span class="mf">0.9</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">unpack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">val</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
                <span class="n">at1</span><span class="p">,</span> <span class="n">at2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
                <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">at1</span><span class="p">,</span> <span class="n">at2</span>
            <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>
            <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>
            <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>
            <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>
            <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>
            <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>

        <span class="k">def</span> <span class="nf">get_neighbors</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">dmax</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; adds attributes ._id, .free, and .cube to asll atoms in atom_list&quot;&quot;&quot;</span>
            <span class="n">cubesize</span> <span class="o">=</span> <span class="n">dmax</span><span class="o">*</span><span class="mf">2.1</span><span class="o">*</span><span class="nb">max</span><span class="p">([</span><span class="n">at</span><span class="o">.</span><span class="n">radius</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">atom_list</span><span class="p">])</span>

            <span class="n">cubes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">at</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">at</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">at</span><span class="o">.</span><span class="n">free</span> <span class="o">=</span> <span class="n">at</span><span class="o">.</span><span class="n">connectors</span>
                <span class="n">at</span><span class="o">.</span><span class="n">cube</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">cubesize</span><span class="p">)),</span> <span class="n">at</span><span class="o">.</span><span class="n">coords</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">at</span><span class="o">.</span><span class="n">cube</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">:</span>
                    <span class="n">cubes</span><span class="p">[</span><span class="n">at</span><span class="o">.</span><span class="n">cube</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cubes</span><span class="p">[</span><span class="n">at</span><span class="o">.</span><span class="n">cube</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">at</span><span class="p">]</span>

            <span class="n">neighbors</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">:</span>
                <span class="n">neighbors</span><span class="p">[</span><span class="n">cube</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cube</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cube</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cube</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cube</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cube</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cube</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">:</span>
                                <span class="n">neighbors</span><span class="p">[</span><span class="n">cube</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cubes</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)]</span>

            <span class="k">return</span> <span class="n">neighbors</span>

        <span class="k">def</span> <span class="nf">find_and_add_bonds</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">dmax</span><span class="p">,</span> <span class="n">from_atoms_subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_atoms_subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_free</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">from_atoms_subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">from_atoms_subset</span> <span class="o">=</span> <span class="n">atom_list</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">atom_list</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">from_atoms_subset</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;from_atoms_subset must be a subset of atoms_subset&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">to_atoms_subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">to_atoms_subset</span> <span class="o">=</span> <span class="n">atom_list</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">atom_list</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">to_atoms_subset</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;to_atoms_subset must be a subset of atoms_subset&#39;</span><span class="p">)</span>

            <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">at1</span> <span class="ow">in</span> <span class="n">from_atoms_subset</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">at1</span><span class="o">.</span><span class="n">free</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ignore_free</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">at2</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">at1</span><span class="o">.</span><span class="n">cube</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">at2</span> <span class="ow">in</span> <span class="n">to_atoms_subset</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">ignore_free</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">at2</span> <span class="ow">in</span> <span class="n">from_atoms_subset</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">at2</span><span class="o">.</span><span class="n">_id</span> <span class="o">&lt;=</span> <span class="n">at1</span><span class="o">.</span><span class="n">_id</span><span class="p">:</span>
                                    <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">at2</span><span class="o">.</span><span class="n">free</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">at2</span><span class="o">.</span><span class="n">_id</span> <span class="o">&lt;=</span> <span class="n">at1</span><span class="o">.</span><span class="n">_id</span><span class="p">:</span>
                                <span class="k">continue</span>
                        <span class="c1"># the bond guessing is more accurate with smaller metallic radii</span>
                        <span class="n">ratio</span> <span class="o">=</span> <span class="n">at1</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">at2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">at1</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">at1</span><span class="o">.</span><span class="n">is_metallic</span><span class="p">)</span> <span class="o">+</span> <span class="n">at2</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">at2</span><span class="o">.</span><span class="n">is_metallic</span><span class="p">))</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">ratio</span> <span class="o">&lt;</span> <span class="n">dmax</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">ignore_free</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">at1</span><span class="p">,</span> <span class="n">at2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">heap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HeapElement</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">at1</span><span class="p">,</span> <span class="n">at2</span><span class="p">))</span>
                                <span class="c1"># I hate to do this, but I guess there&#39;s no other way :/ [MiHa]</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">at1</span><span class="o">.</span><span class="n">atnum</span> <span class="o">==</span> <span class="mi">16</span> <span class="ow">and</span> <span class="n">at2</span><span class="o">.</span><span class="n">atnum</span> <span class="o">==</span> <span class="mi">8</span><span class="p">):</span>
                                    <span class="n">at1</span><span class="o">.</span><span class="n">free</span> <span class="o">=</span> <span class="mi">6</span>
                                <span class="k">elif</span> <span class="p">(</span><span class="n">at2</span><span class="o">.</span><span class="n">atnum</span> <span class="o">==</span> <span class="mi">16</span> <span class="ow">and</span> <span class="n">at1</span><span class="o">.</span><span class="n">atnum</span> <span class="o">==</span> <span class="mi">8</span><span class="p">):</span>
                                    <span class="n">at2</span><span class="o">.</span><span class="n">free</span> <span class="o">=</span> <span class="mi">6</span>
                                <span class="k">elif</span> <span class="p">(</span><span class="n">at1</span><span class="o">.</span><span class="n">atnum</span> <span class="o">==</span> <span class="mi">7</span><span class="p">):</span>
                                    <span class="n">at1</span><span class="o">.</span><span class="n">free</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="k">elif</span> <span class="p">(</span><span class="n">at2</span><span class="o">.</span><span class="n">atnum</span> <span class="o">==</span> <span class="mi">7</span><span class="p">):</span>
                                    <span class="n">at2</span><span class="o">.</span><span class="n">free</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_free</span><span class="p">:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">atom_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">at</span><span class="o">.</span><span class="n">atnum</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">at</span><span class="o">.</span><span class="n">free</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">:</span>
                            <span class="n">at</span><span class="o">.</span><span class="n">free</span> <span class="o">=</span> <span class="mi">4</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">at</span><span class="o">.</span><span class="n">free</span> <span class="o">=</span> <span class="mi">3</span>

                <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
                    <span class="n">val</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">at1</span><span class="p">,</span> <span class="n">at2</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">()</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="k">else</span> <span class="mf">0.5</span>
                    <span class="k">if</span> <span class="n">at1</span><span class="o">.</span><span class="n">free</span> <span class="o">&gt;=</span> <span class="n">step</span> <span class="ow">and</span> <span class="n">at2</span><span class="o">.</span><span class="n">free</span> <span class="o">&gt;=</span> <span class="n">step</span><span class="p">:</span>
                        <span class="n">o</span> <span class="o">+=</span> <span class="n">step</span>
                        <span class="n">at1</span><span class="o">.</span><span class="n">free</span> <span class="o">-=</span> <span class="n">step</span>
                        <span class="n">at2</span><span class="o">.</span><span class="n">free</span> <span class="o">-=</span> <span class="n">step</span>
                        <span class="k">if</span> <span class="n">o</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">HeapElement</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">at1</span><span class="p">,</span> <span class="n">at2</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">at1</span><span class="p">,</span> <span class="n">at2</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">o</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="mf">1.5</span><span class="p">:</span>
                            <span class="n">o</span> <span class="o">=</span> <span class="n">Bond</span><span class="o">.</span><span class="n">AR</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">at1</span><span class="p">,</span> <span class="n">at2</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">par</span><span class="p">):</span>
                    <span class="n">atom</span><span class="o">.</span><span class="n">arom</span> <span class="o">+=</span> <span class="mi">1000</span>
                    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                        <span class="n">oe</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_aromatic</span><span class="p">()</span> <span class="ow">and</span> <span class="n">oe</span><span class="o">.</span><span class="n">arom</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">oe</span><span class="o">.</span><span class="n">arom</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="k">return</span> <span class="kc">False</span>
                            <span class="k">if</span> <span class="n">par</span> <span class="ow">and</span> <span class="n">oe</span><span class="o">.</span><span class="n">arom</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">b</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">2</span>
                                <span class="k">return</span> <span class="kc">True</span>
                            <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">oe</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">par</span><span class="p">):</span>
                                <span class="n">b</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">par</span>
                                <span class="k">return</span> <span class="kc">True</span>

                <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">atom_list</span><span class="p">:</span>
                    <span class="n">at</span><span class="o">.</span><span class="n">arom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">Bond</span><span class="o">.</span><span class="n">is_aromatic</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">bonds</span><span class="p">)))</span>

                <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">atom_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">at</span><span class="o">.</span><span class="n">arom</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dfs</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">cleanup_atom_list</span><span class="p">(</span><span class="n">atom_list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">atom_list</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">at</span><span class="o">.</span><span class="n">cube</span><span class="p">,</span><span class="n">at</span><span class="o">.</span><span class="n">free</span><span class="p">,</span><span class="n">at</span><span class="o">.</span><span class="n">_id</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="s1">&#39;arom&#39;</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">at</span><span class="o">.</span><span class="n">arom</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="s1">&#39;_metalbondcounter&#39;</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">at</span><span class="o">.</span><span class="n">_metalbondcounter</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="s1">&#39;_electronegativebondcounter&#39;</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">at</span><span class="o">.</span><span class="n">_electronegativebondcounter</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">delete_all_bonds</span><span class="p">()</span>
        <span class="n">atom_list</span> <span class="o">=</span> <span class="n">atom_subset</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>

        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>

        <span class="n">nonmetallic</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atom_list</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_metallic</span><span class="p">]</span>
        <span class="n">metallic</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atom_list</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_metallic</span><span class="p">]</span>
        <span class="n">hydrogens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atom_list</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">atnum</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">potentially_ignore_metal_bonds</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atom_list</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">symbol</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="s1">&#39;N&#39;</span><span class="p">,</span><span class="s1">&#39;S&#39;</span><span class="p">,</span><span class="s1">&#39;P&#39;</span><span class="p">,</span><span class="s1">&#39;As&#39;</span><span class="p">]]</span>

        <span class="c1"># first guess bonds for non-metals. This also captures bond orders.</span>
        <span class="n">find_and_add_bonds</span><span class="p">(</span><span class="n">nonmetallic</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="n">dmax</span><span class="p">)</span>

        <span class="c1"># add stray hydrogens</span>
        <span class="n">stray_hydrogens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hydrogens</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">find_and_add_bonds</span><span class="p">(</span><span class="n">nonmetallic</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">from_atoms_subset</span><span class="o">=</span><span class="n">stray_hydrogens</span><span class="p">,</span> <span class="n">to_atoms_subset</span><span class="o">=</span><span class="n">nonmetallic</span><span class="p">,</span> <span class="n">ignore_free</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="n">dmax</span><span class="p">)</span>

        <span class="c1"># for obvious anions like carbonate, nitrate, sulfate, phosphate, and arsenate, do not allow metal atoms to bond to the central atom</span>
        <span class="n">new_atom_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">atom_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">potentially_ignore_metal_bonds</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">at</span><span class="o">.</span><span class="n">bonds</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">at</span><span class="p">)</span><span class="o">.</span><span class="n">is_electronegative</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="n">new_atom_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
        <span class="n">find_and_add_bonds</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">from_atoms_subset</span><span class="o">=</span><span class="n">metallic</span><span class="p">,</span> <span class="n">to_atoms_subset</span><span class="o">=</span><span class="n">new_atom_list</span><span class="p">,</span> <span class="n">ignore_free</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="n">dmax</span><span class="p">)</span>

        <span class="c1"># delete metal-metal bonds and metal-hydrogen bonds if the metal is bonded to enough electronegative atoms and not enough metal atoms</span>
        <span class="c1"># (this means that the metal is a cation, so bonds should almost never be drawn unless it&#39;s a dimetal complex or a hydride/H2 ligand, but that should be rare)</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">metallic</span><span class="p">:</span>
            <span class="n">at</span><span class="o">.</span><span class="n">_metalbondcounter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">at</span><span class="o">.</span><span class="n">bonds</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">at</span><span class="p">)</span><span class="o">.</span><span class="n">is_metallic</span><span class="p">])</span>
            <span class="n">at</span><span class="o">.</span><span class="n">_electronegativebondcounter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">at</span><span class="o">.</span><span class="n">bonds</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">at</span><span class="p">)</span><span class="o">.</span><span class="n">is_electronegative</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">at</span><span class="o">.</span><span class="n">_electronegativebondcounter</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">or</span> \
                    <span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">_electronegativebondcounter</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">at</span><span class="o">.</span><span class="n">_metalbondcounter</span><span class="p">)</span> <span class="ow">or</span> \
                    <span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">_electronegativebondcounter</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">at</span><span class="o">.</span><span class="n">_metalbondcounter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">bonds_to_delete</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">at</span><span class="o">.</span><span class="n">bonds</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">at</span><span class="p">)</span><span class="o">.</span><span class="n">is_metallic</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">at</span><span class="p">)</span><span class="o">.</span><span class="n">atnum</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds_to_delete</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">delete_bond</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>


        <span class="n">cleanup_atom_list</span><span class="p">(</span><span class="n">atom_list</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.in_ring"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.in_ring">[docs]</a>    <span class="k">def</span> <span class="nf">in_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if an atom or a bond belonging to this |Molecule| forms a ring. *arg* should be an instance of |Atom| or |Bond| belonging to this |Molecule|.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Bond</span><span class="p">)))</span> <span class="ow">or</span> <span class="n">arg</span><span class="o">.</span><span class="n">mol</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;in_ring: Argument should be a Bond or an Atom and it should be a part of the Molecule&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">v</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bond</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="n">arg</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">u</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="s1">&#39;cycle&#39;</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span><span class="o">.</span><span class="n">_visited</span><span class="p">:</span>
                        <span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">at</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">_visited</span> <span class="o">==</span> <span class="s1">&#39;cycle&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">atom1</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">_visited</span>

        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">at</span><span class="o">.</span><span class="n">_visited</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="Molecule.supercell"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.supercell">[docs]</a>    <span class="k">def</span> <span class="nf">supercell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new |Molecule| instance representing a supercell build by replicating this |Molecule| along its lattice vectors.</span>

<span class="sd">        One should provide in input an integer matrix :math:`T_{i,j}` representing the supercell transformation (:math:`\\vec{a}_i&#39; = \sum_j T_{i,j}\\vec{a}_j`). The size of the matrix should match the number of lattice vectors, i.e. 3x3 for 3D periodic systems, 2x2 for 2D periodic systems and one number for 1D periodic systems. The matrix can be provided in input as either a nested list or as a numpy matrix.</span>

<span class="sd">        For a diagonal supercell expansion (i.e. :math:`T_{i \\neq j}=0`) one can provide in input n positive integers instead of a matrix, where n is number of lattice vectors in the molecule. e.g. This ``mol.supercell([[2,0],[0,2]])`` is equivalent to ``mol.supercell(2,2)``.</span>

<span class="sd">        The returned |Molecule| is fully distinct from the current one, in a sense that it contains a different set of |Atom| and |Bond| instances. However, each atom of the returned |Molecule| carries an additional information about its origin within the supercell. If ``atom`` is an |Atom| instance in the supercell, ``atom.properties.supercell.origin`` points to the |Atom| instance of the original molecule that was copied to create ``atom``, while ``atom.properties.supercell.index`` stores the tuple (with length equal to the number of lattice vectors) with cell index. For example, ``atom.properties.supercell.index == (2,1,0)`` means that ``atom`` is a copy of ``atom.properties.supercell.origin`` that was translated twice along the first lattice vector, once along the second vector, and not translated along the third vector.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            &gt;&gt;&gt; graphene = Molecule(&#39;graphene.xyz&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(graphene)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         C      0.000000      0.000000      0.000000</span>
<span class="sd">                2         C      1.230000      0.710000      0.000000</span>
<span class="sd">              Lattice:</span>
<span class="sd">                    2.4600000000     0.0000000000     0.0000000000</span>
<span class="sd">                    1.2300000000     2.1304224933     0.0000000000</span>

<span class="sd">            &gt;&gt;&gt; graphene_supercell = graphene.supercell(2,2) # diagonal supercell expansion</span>
<span class="sd">            &gt;&gt;&gt; print(graphene_supercell)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         C      0.000000      0.000000      0.000000</span>
<span class="sd">                2         C      1.230000      0.710000      0.000000</span>
<span class="sd">                3         C      1.230000      2.130422      0.000000</span>
<span class="sd">                4         C      2.460000      2.840422      0.000000</span>
<span class="sd">                5         C      2.460000      0.000000      0.000000</span>
<span class="sd">                6         C      3.690000      0.710000      0.000000</span>
<span class="sd">                7         C      3.690000      2.130422      0.000000</span>
<span class="sd">                8         C      4.920000      2.840422      0.000000</span>
<span class="sd">              Lattice:</span>
<span class="sd">                    4.9200000000     0.0000000000     0.0000000000</span>
<span class="sd">                    2.4600000000     4.2608449866     0.0000000000</span>

<span class="sd">            &gt;&gt;&gt; diamond = Molecule(&#39;diamond.xyz&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(diamond)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         C     -0.446100     -0.446200     -0.446300</span>
<span class="sd">                2         C      0.446400      0.446500      0.446600</span>
<span class="sd">              Lattice:</span>
<span class="sd">                    0.0000000000     1.7850000000     1.7850000000</span>
<span class="sd">                    1.7850000000     0.0000000000     1.7850000000</span>
<span class="sd">                    1.7850000000     1.7850000000     0.0000000000</span>

<span class="sd">            &gt;&gt;&gt; diamond_supercell = diamond.supercell([[-1,1,1],[1,-1,1],[1,1,-1]])</span>
<span class="sd">            &gt;&gt;&gt; print(diamond_supercell)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         C     -0.446100     -0.446200     -0.446300</span>
<span class="sd">                2         C      0.446400      0.446500      0.446600</span>
<span class="sd">                3         C      1.338900      1.338800     -0.446300</span>
<span class="sd">                4         C      2.231400      2.231500      0.446600</span>
<span class="sd">                5         C      1.338900     -0.446200      1.338700</span>
<span class="sd">                6         C      2.231400      0.446500      2.231600</span>
<span class="sd">                7         C     -0.446100      1.338800      1.338700</span>
<span class="sd">                8         C      0.446400      2.231500      2.231600</span>
<span class="sd">              Lattice:</span>
<span class="sd">                    3.5700000000     0.0000000000     0.0000000000</span>
<span class="sd">                    0.0000000000     3.5700000000     0.0000000000</span>
<span class="sd">                    0.0000000000     0.0000000000     3.5700000000</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">diagonal_supercell</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">supercell_lattice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">vec</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)]</span>
            <span class="n">cell_translations</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])]</span>
            <span class="k">return</span> <span class="n">supercell_lattice</span><span class="p">,</span> <span class="n">cell_translations</span>


        <span class="k">def</span> <span class="nf">general_supercell</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
            <span class="n">determinant</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">S</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">determinant</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;supercell: The determinant of the supercell transformation should be one or larger. Determinant: </span><span class="si">{determinant}</span><span class="s1">.&#39;</span><span class="p">)</span>

            <span class="n">supercell_lattice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">S</span><span class="nd">@np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)]</span>

            <span class="n">max_supercell_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
            <span class="n">all_possible_translations</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_supercell_index</span><span class="p">,</span><span class="n">max_supercell_index</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">))</span>
            <span class="n">S_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

            <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-10</span>
            <span class="n">cell_translations</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">all_possible_translations</span><span class="p">:</span>
                <span class="n">fractional_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">S_inv</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">fractional_coord</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">tol</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">fractional_coord</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="o">-</span><span class="n">tol</span><span class="p">):</span>
                    <span class="n">cell_translations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_translations</span><span class="p">)</span> <span class="o">!=</span> <span class="n">determinant</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;supercell: Failed to find the appropriate supercell translations. We expected to find </span><span class="si">{determinant}</span><span class="s1"> cells, but we found {len(cell_translations)}&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">supercell_lattice</span><span class="p">,</span> <span class="n">cell_translations</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;supercell: This function needs input arguments...&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
            <span class="c1"># diagonal supercell expansion</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;supercell: The lattice has </span><span class="si">{}</span><span class="s1"> vectors, but </span><span class="si">{}</span><span class="s1"> arguments were given&#39;</span><span class="o">.</span> <span class="nb">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
            <span class="n">supercell_lattice</span><span class="p">,</span> <span class="n">cell_translations</span> <span class="o">=</span> <span class="n">diagonal_supercell</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="c1"># general_supercell</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;supercell: For </span><span class="si">{n}</span><span class="s1">D system the supercell method expects a </span><span class="si">{n}</span><span class="s1">x</span><span class="si">{n}</span><span class="s1"> integer matrix (provided as a nested list or as numpy array) or </span><span class="si">{n}</span><span class="s1"> integers.&#39;</span><span class="p">)</span>

            <span class="n">supercell_lattice</span><span class="p">,</span> <span class="n">cell_translations</span> <span class="o">=</span> <span class="n">general_supercell</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;supercell: invalid input </span><span class="si">{args}</span><span class="s1">.&#39;</span><span class="p">)</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">parent</span><span class="p">,</span> <span class="n">son</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmp</span><span class="p">):</span>
            <span class="n">son</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">supercell</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">parent</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">cell_translations</span><span class="p">:</span>
            <span class="n">newmol</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">newmol</span><span class="p">:</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">supercell</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
            <span class="n">newmol</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">vec</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)))</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="n">newmol</span>

        <span class="n">ret</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">supercell_lattice</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="Molecule.unit_cell_volume"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.unit_cell_volume">[docs]</a>    <span class="k">def</span> <span class="nf">unit_cell_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the volume of the unit cell of a 3D system.</span>

<span class="sd">        *unit* is the unit of length, the cube of which will be used as the unit of volume.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">2</span><span class="p">]])))</span> <span class="o">*</span> <span class="n">Units</span><span class="o">.</span><span class="n">conversion_ratio</span><span class="p">(</span><span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="o">*</span> <span class="n">Units</span><span class="o">.</span><span class="n">conversion_ratio</span><span class="p">(</span><span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">Units</span><span class="o">.</span><span class="n">conversion_ratio</span><span class="p">(</span><span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate unit cell volume for a nonperiodic molecule&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(self.lattice) = </span><span class="si">{}</span><span class="s2">, should be &lt;=3.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Molecule.cell_lengths"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.cell_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">cell_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the lengths of the lattice vector. Returns a list with the same length as self.lattice&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">cell_lengths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.cell_angles"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.cell_angles">[docs]</a>    <span class="k">def</span> <span class="nf">cell_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;degree&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the angles between lattice vectors.</span>

<span class="sd">        unit : str</span>
<span class="sd">            output unit</span>

<span class="sd">        For 2D systems, returns a list [gamma]</span>

<span class="sd">        For 3D systems, returns a list [alpha, beta, gamma]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cell_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.set_integer_bonds"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.set_integer_bonds">[docs]</a>    <span class="k">def</span> <span class="nf">set_integer_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert non-integer bond orders into integers.</span>

<span class="sd">        For example, bond orders of aromatic systems are no longer set to the non-integer</span>
<span class="sd">        value of ``1.5``, instead adopting bond orders of ``1`` and ``2``.</span>

<span class="sd">        The implemented function walks a set of graphs constructed from all non-integer bonds,</span>
<span class="sd">        converting the orders of aforementioned bonds to integers by alternating calls to</span>
<span class="sd">        :func:`math.ceil` and :func:`math.floor`.</span>
<span class="sd">        The implication herein is that both :math:`i` and :math:`i+1` are considered valid</span>
<span class="sd">        (integer) values for any bond order within the :math:`(i, i+1)` interval.</span>
<span class="sd">        Floats which can be represented exactly as an integer, *e.g.* :math:`1.0`,</span>
<span class="sd">        are herein treated as integers.</span>

<span class="sd">        Can be used for sanitizaing any Molecules passed to the</span>
<span class="sd">        :mod:`rdkit&lt;scm.plams.interfaces.molecule.rdkit&gt;` module,</span>
<span class="sd">        as its functions are generally unable to handle Molecules with non-integer bond orders.</span>

<span class="sd">        By default this function will issue a warning if the total (summed) bond orders</span>
<span class="sd">        before and after are not equal to each other within a given *tolerance*.</span>
<span class="sd">        Accepted values are for *action* are ``&quot;ignore&quot;``, ``&quot;warn&quot;`` and ``&quot;raise&quot;``,</span>
<span class="sd">        which respectivelly ignore such cases, issue a warning or raise a :exc:`MoleculeError`.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            &gt;&gt;&gt; from scm.plams import Molecule</span>

<span class="sd">            &gt;&gt;&gt; benzene = Molecule(...)</span>
<span class="sd">            &gt;&gt;&gt; print(benzene)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         C      1.193860     -0.689276      0.000000</span>
<span class="sd">                2         C      1.193860      0.689276      0.000000</span>
<span class="sd">                3         C      0.000000      1.378551      0.000000</span>
<span class="sd">                4         C     -1.193860      0.689276      0.000000</span>
<span class="sd">                5         C     -1.193860     -0.689276      0.000000</span>
<span class="sd">                6         C     -0.000000     -1.378551      0.000000</span>
<span class="sd">                7         H      2.132911     -1.231437     -0.000000</span>
<span class="sd">                8         H      2.132911      1.231437     -0.000000</span>
<span class="sd">                9         H      0.000000      2.462874     -0.000000</span>
<span class="sd">               10         H     -2.132911      1.231437     -0.000000</span>
<span class="sd">               11         H     -2.132911     -1.231437     -0.000000</span>
<span class="sd">               12         H     -0.000000     -2.462874     -0.000000</span>
<span class="sd">              Bonds:</span>
<span class="sd">               (3)--1.5--(4)</span>
<span class="sd">               (5)--1.5--(6)</span>
<span class="sd">               (1)--1.5--(6)</span>
<span class="sd">               (2)--1.5--(3)</span>
<span class="sd">               (4)--1.5--(5)</span>
<span class="sd">               (1)--1.5--(2)</span>
<span class="sd">               (3)--1.0--(9)</span>
<span class="sd">               (6)--1.0--(12)</span>
<span class="sd">               (5)--1.0--(11)</span>
<span class="sd">               (4)--1.0--(10)</span>
<span class="sd">               (2)--1.0--(8)</span>
<span class="sd">               (1)--1.0--(7)</span>

<span class="sd">            &gt;&gt;&gt; benzene.set_integer_bonds()</span>
<span class="sd">            &gt;&gt;&gt; print(benzene)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         C      1.193860     -0.689276      0.000000</span>
<span class="sd">                2         C      1.193860      0.689276      0.000000</span>
<span class="sd">                3         C      0.000000      1.378551      0.000000</span>
<span class="sd">                4         C     -1.193860      0.689276      0.000000</span>
<span class="sd">                5         C     -1.193860     -0.689276      0.000000</span>
<span class="sd">                6         C     -0.000000     -1.378551      0.000000</span>
<span class="sd">                7         H      2.132911     -1.231437     -0.000000</span>
<span class="sd">                8         H      2.132911      1.231437     -0.000000</span>
<span class="sd">                9         H      0.000000      2.462874     -0.000000</span>
<span class="sd">               10         H     -2.132911      1.231437     -0.000000</span>
<span class="sd">               11         H     -2.132911     -1.231437     -0.000000</span>
<span class="sd">               12         H     -0.000000     -2.462874     -0.000000</span>
<span class="sd">              Bonds:</span>
<span class="sd">               (3)--1.0--(4)</span>
<span class="sd">               (5)--1.0--(6)</span>
<span class="sd">               (1)--2.0--(6)</span>
<span class="sd">               (2)--2.0--(3)</span>
<span class="sd">               (4)--2.0--(5)</span>
<span class="sd">               (1)--1.0--(2)</span>
<span class="sd">               (3)--1.0--(9)</span>
<span class="sd">               (6)--1.0--(12)</span>
<span class="sd">               (5)--1.0--(11)</span>
<span class="sd">               (4)--1.0--(10)</span>
<span class="sd">               (2)--1.0--(8)</span>
<span class="sd">               (1)--1.0--(7)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ignore, raise or warn</span>
        <span class="n">action_func</span> <span class="o">=</span> <span class="n">parse_action</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>

        <span class="n">ceil</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span>
        <span class="n">floor</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span>
        <span class="n">func_invert</span> <span class="o">=</span> <span class="p">{</span><span class="n">ceil</span><span class="p">:</span> <span class="n">floor</span><span class="p">,</span> <span class="n">floor</span><span class="p">:</span> <span class="n">ceil</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;Depth-first search algorithm for integer-ifying the bond orders.&quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">b2</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b2</span><span class="o">.</span><span class="n">_visited</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">b2</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">b2</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>  <span class="c1"># func = ``math.ceil()`` or ``math.floor()``</span>
                <span class="k">del</span> <span class="n">bond_dict</span><span class="p">[</span><span class="n">b2</span><span class="p">]</span>

                <span class="n">atom_new</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">atom_new</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func_invert</span><span class="p">[</span><span class="n">func</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">collect_and_mark_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">order_before</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">order_before_append</span> <span class="o">=</span> <span class="n">order_before</span><span class="o">.</span><span class="n">append</span>

            <span class="c1"># Mark all non-integer bonds; floats which can be represented exactly</span>
            <span class="c1"># by an integer (e.g. 1.0 and 2.0) are herein treated as integers</span>
            <span class="n">bond_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>  <span class="c1"># An improvised OrderedSet (as it does not exist)</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">order</span>
                <span class="n">order_before_append</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="s1">&#39;is_integer&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">bond</span><span class="o">.</span><span class="n">order</span><span class="o">.</span><span class="n">is_integer</span><span class="p">():</span>  <span class="c1"># Checking for ``is_integer()`` catches both float and np.float</span>
                    <span class="n">bond</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">bond_dict</span><span class="p">[</span><span class="n">bond</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bond</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">bond_dict</span><span class="p">,</span> <span class="n">order_before</span>

        <span class="n">bond_dict</span><span class="p">,</span> <span class="n">order_before</span> <span class="o">=</span> <span class="n">collect_and_mark_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">bond_dict</span><span class="p">:</span>
            <span class="n">b1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bond_dict</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">b1</span><span class="o">.</span><span class="n">order</span>

            <span class="c1"># Start with either ``math.ceil()`` if the ceiling is closer than the floor;</span>
            <span class="c1"># start with ``math.floor()`` otherwise</span>
            <span class="n">delta_ceil</span><span class="p">,</span> <span class="n">delta_floor</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="n">order</span><span class="p">,</span> <span class="n">floor</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="n">order</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">ceil</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta_ceil</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta_floor</span><span class="p">)</span> <span class="k">else</span> <span class="n">floor</span>

            <span class="n">b1</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
            <span class="n">b1</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">atom1</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func_invert</span><span class="p">[</span><span class="n">func</span><span class="p">])</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">atom2</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func_invert</span><span class="p">[</span><span class="n">func</span><span class="p">])</span>

        <span class="c1"># Remove the Bond._visited attribute</span>
        <span class="n">order_after_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">order_after_sum</span> <span class="o">+=</span> <span class="n">bond</span><span class="o">.</span><span class="n">order</span>
            <span class="k">del</span> <span class="n">bond</span><span class="o">.</span><span class="n">_visited</span>

        <span class="c1"># Check that the total (summed) bond order has not changed</span>
        <span class="n">order_before_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">order_before</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">order_before_sum</span> <span class="o">-</span> <span class="n">order_after_sum</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Bond orders before and after not equal to tolerance </span><span class="si">{tolerance!r}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="n">f</span><span class="s2">&quot;before: sum(...) == </span><span class="si">{order_before_sum!r}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="n">f</span><span class="s2">&quot;after: sum(...) == </span><span class="si">{order_after_sum!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">action_func</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">MoleculeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>  <span class="c1"># Restore the initial bond orders</span>
                <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">order_before</span><span class="p">)):</span>
                    <span class="n">b</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
                <span class="k">raise</span> <span class="n">ex</span></div>


<div class="viewcode-block" id="Molecule.index"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the first index of the specified Atom or Bond.</span>

<span class="sd">        Providing an |Atom| will return its 1-based index, while a |Bond| returns a 2-tuple with the 1-based indices of its atoms.</span>

<span class="sd">        Raises a |MoleculeError| if the provided is not an Atom/Bond or if the Atom/bond is not part of the molecule.</span>

<span class="sd">        .. code:: python</span>

<span class="sd">            &gt;&gt;&gt; from scm.plams import Molecule, Bond, Atom</span>

<span class="sd">            &gt;&gt;&gt; mol = Molecule(...)</span>
<span class="sd">            &gt;&gt;&gt; atom: Atom = Molecule[1]</span>
<span class="sd">            &gt;&gt;&gt; bond: Bond = Molecule[1, 2]</span>

<span class="sd">            &gt;&gt;&gt; print(mol.index(atom))</span>
<span class="sd">            1</span>

<span class="sd">            &gt;&gt;&gt; print(mol.index(bond))</span>
<span class="sd">            (1, 2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">start</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Correct for the 1-based indices used in Molecule</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">stop</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Bond</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">atom1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">atom2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>  <span class="c1"># Raised if the provided Atom/Bond is not in self</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Provided </span><span class="si">{value.__class__.__name__}</span><span class="s1"> is not in Molecule&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Raised if value is neither an Atom nor Bond</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;&#39;value&#39; expected an Atom or Bond; observed type: &#39;</span><span class="si">{value.__class__.__name__}</span><span class="s2">&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.round_coords"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.round_coords">[docs]</a>    <span class="k">def</span> <span class="nf">round_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Round the Cartesian coordinates of this instance to *decimals*.</span>

<span class="sd">        By default, with ``inplace=True``, the coordinates of this instance are updated inplace.</span>
<span class="sd">        If ``inplace=False`` then a new copy of this Molecule is returned with its</span>
<span class="sd">        coordinates rounded.</span>

<span class="sd">        .. code:: python</span>

<span class="sd">            &gt;&gt;&gt; from scm.plams import Molecule</span>

<span class="sd">            &gt;&gt;&gt; mol = Molecule(...)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         H      1.234567      0.000000      0.000000</span>
<span class="sd">                2         H      0.000000      0.000000      0.000000</span>

<span class="sd">            &gt;&gt;&gt; mol_rounded = round_coords(mol)</span>
<span class="sd">            &gt;&gt;&gt; print(mol_rounded)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         H      1.000000      0.000000      0.000000</span>
<span class="sd">                2         H      0.000000      0.000000      0.000000</span>

<span class="sd">            &gt;&gt;&gt; mol.round_coords(decimals=3)</span>
<span class="sd">            &gt;&gt;&gt; print(mol)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         H      1.234000      0.000000      0.000000</span>
<span class="sd">                2         H      0.000000      0.000000      0.000000</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>

        <span class="c1"># Follow the convention used in ``ndarray.round()``: always return floats,</span>
        <span class="c1"># even if ndigits=None</span>
        <span class="n">xyz_round</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">xyz_round</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mol_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">mol_copy</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">xyz_round</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mol_copy</span></div>

<div class="viewcode-block" id="Molecule.get_connection_table"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.get_connection_table">[docs]</a>    <span class="k">def</span> <span class="nf">get_connection_table</span> <span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a connection table with atom indices (starting at 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iat</span><span class="p">,</span><span class="n">at</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">at</span><span class="p">)])</span>
            <span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">table</span></div>

<div class="viewcode-block" id="Molecule.get_molecule_indices"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.get_molecule_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_molecule_indices</span> <span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use the bond information to identify submolecules</span>

<span class="sd">        Returns a list of lists of indices (e.g. for two methane molecules: [[0,1,2,3,4],[5,6,7,8,9]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">molecule_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">at</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
            <span class="n">v</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span><span class="o">.</span><span class="n">_visited</span><span class="p">:</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">iatom</span><span class="p">,</span><span class="n">src</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">src</span><span class="o">.</span><span class="n">_visited</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">iatom</span><span class="p">]</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
                <span class="n">molecule_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">at</span><span class="o">.</span><span class="n">_visited</span>

        <span class="k">return</span> <span class="n">molecule_indices</span></div>

<div class="viewcode-block" id="Molecule.get_fragment"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.get_fragment">[docs]</a>    <span class="k">def</span> <span class="nf">get_fragment</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a submolecule from self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># First the atoms</span>
        <span class="n">bro</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">iat</span> <span class="ow">in</span> <span class="n">indices</span> <span class="p">:</span>
            <span class="n">at</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">iat</span><span class="p">]</span>
            <span class="n">at_copy</span> <span class="o">=</span> <span class="n">smart_copy</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">owncopy</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span> <span class="n">without</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;mol&#39;</span><span class="p">,</span><span class="s1">&#39;bonds&#39;</span><span class="p">])</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">at_copy</span><span class="p">)</span>
            <span class="n">bro</span><span class="p">[</span><span class="n">at</span><span class="p">]</span> <span class="o">=</span> <span class="n">at_copy</span>
    
        <span class="c1"># Then the bonds</span>
        <span class="k">for</span> <span class="n">bo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bo</span><span class="o">.</span><span class="n">atom1</span> <span class="ow">in</span> <span class="n">bro</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bo</span><span class="o">.</span><span class="n">atom2</span> <span class="ow">in</span> <span class="n">bro</span><span class="p">):</span>
                <span class="n">bo_copy</span> <span class="o">=</span> <span class="n">smart_copy</span><span class="p">(</span><span class="n">bo</span><span class="p">,</span> <span class="n">owncopy</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span> <span class="n">without</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;atom1&#39;</span><span class="p">,</span> <span class="s1">&#39;atom2&#39;</span><span class="p">,</span> <span class="s1">&#39;mol&#39;</span><span class="p">])</span>
                <span class="n">bo_copy</span><span class="o">.</span><span class="n">atom1</span> <span class="o">=</span> <span class="n">bro</span><span class="p">[</span><span class="n">bo</span><span class="o">.</span><span class="n">atom1</span><span class="p">]</span>
                <span class="n">bo_copy</span><span class="o">.</span><span class="n">atom2</span> <span class="o">=</span> <span class="n">bro</span><span class="p">[</span><span class="n">bo</span><span class="o">.</span><span class="n">atom2</span><span class="p">]</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">bo_copy</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Molecule.locate_rings"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.locate_rings">[docs]</a>    <span class="k">def</span> <span class="nf">locate_rings</span> <span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the rings in the structure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">shortest_path_dijkstra</span> <span class="p">(</span><span class="n">conect</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Find the shortest paths (can be more than 1) </span>
<span class="sd">            between a source atom and a target</span>
<span class="sd">            atom in a molecule</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">huge</span> <span class="o">=</span> <span class="mf">100000.</span>
    
            <span class="n">dist</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conect</span><span class="p">))</span> <span class="p">:</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">huge</span>
                <span class="n">previous</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">Q</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">iat</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conect</span><span class="p">))</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">iat</span> <span class="o">!=</span> <span class="n">source</span> <span class="p">:</span>
                    <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iat</span><span class="p">)</span>

            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
                <span class="c1"># vertex in Q with smallest distance in dist</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">huge</span> <span class="p">:</span>
                    <span class="k">return</span> <span class="p">[]</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">target</span> <span class="p">:</span>
                    <span class="k">break</span>

                <span class="c1"># Select the neighbors of u, and loop over them</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="n">conect</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span> <span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">alt</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span>
                    <span class="k">if</span> <span class="n">alt</span> <span class="o">==</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="p">:</span>
                        <span class="n">previous</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">alt</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="p">:</span>
                        <span class="n">previous</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>
                        <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">alt</span>
                        <span class="c1"># Reorder Q</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">vertex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="p">:</span>
                            <span class="k">if</span> <span class="n">vertex</span> <span class="o">==</span> <span class="n">v</span> <span class="p">:</span>
                                <span class="n">ind</span> <span class="o">=</span> <span class="n">i</span>
                                <span class="k">break</span>
                        <span class="n">Q</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">vertex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="p">:</span>
                            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="p">:</span>
                                <span class="n">ind</span> <span class="o">=</span> <span class="n">i</span>
                                <span class="k">break</span>
                        <span class="n">Q</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

            <span class="n">bridgelist</span> <span class="o">=</span> <span class="p">[[</span><span class="n">u</span><span class="p">]]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="p">:</span>
                <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bridgelist</span><span class="p">)</span> <span class="p">:</span>
                    <span class="n">prevats</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">prevats</span> <span class="p">:</span>
                        <span class="n">newpath</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="p">[</span><span class="n">at</span><span class="p">]</span>
                        <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newpath</span><span class="p">)</span>
                <span class="n">bridgelist</span> <span class="o">=</span> <span class="n">paths</span>

            <span class="k">return</span> <span class="n">bridgelist</span>

        <span class="k">def</span> <span class="nf">bond_from_indices</span> <span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">iat1</span><span class="p">,</span> <span class="n">iat2</span><span class="p">)</span> <span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return a bond object from the atom indices</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">bond</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">bonds</span> <span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bond</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">iat1</span> <span class="ow">in</span> <span class="n">indices</span> <span class="ow">and</span> <span class="n">iat2</span> <span class="ow">in</span> <span class="n">indices</span> <span class="p">:</span>
                    <span class="k">break</span> 
            <span class="k">if</span> <span class="n">bond</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;This bond should exist (</span><span class="si">%i</span><span class="s1"> </span><span class="si">%i</span><span class="s1">), but does not!&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">iat1</span><span class="p">,</span><span class="n">iat2</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">bond</span>

        <span class="c1"># For each atom find the list of neighbors,</span>
        <span class="c1"># break the corresponding bond, and then find out if they are still</span>
        <span class="c1"># connected. If so, find the shortest bridge, using Dijkstra&#39;s algorithm</span>
        <span class="n">conect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connection_table</span><span class="p">()</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">at</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">allrings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">oldneighbors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iat</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">conect</span><span class="p">[</span><span class="n">iat</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">iatn</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">iatn</span> <span class="ow">in</span> <span class="n">oldneighbors</span> <span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">bond</span> <span class="o">=</span> <span class="n">bond_from_indices</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">iat</span><span class="p">,</span> <span class="n">iatn</span><span class="p">)</span>
                <span class="c1"># Delete the bond</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">delete_bond</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
                <span class="n">mollist</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">get_molecule_indices</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mollist</span> <span class="p">:</span>
                    <span class="n">connection</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="n">iatn</span> <span class="ow">in</span> <span class="n">m</span> <span class="p">:</span>
                        <span class="k">if</span> <span class="n">iat</span> <span class="ow">in</span> <span class="n">m</span> <span class="p">:</span>
                            <span class="n">connection</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">connection</span> <span class="p">:</span>
                    <span class="n">retconect</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">get_connection_table</span><span class="p">()</span>
                    <span class="n">rings</span> <span class="o">=</span> <span class="n">shortest_path_dijkstra</span><span class="p">(</span><span class="n">retconect</span><span class="p">,</span><span class="n">iat</span><span class="p">,</span><span class="n">iatn</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">rings</span> <span class="p">:</span>
                        <span class="n">ring</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">allrings</span> <span class="p">:</span>
                            <span class="n">allrings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
                    <span class="c1"># Put the bond back</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
            <span class="n">oldneighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iat</span><span class="p">)</span>

        <span class="n">allrings</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">order_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">allrings</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">allrings</span></div>

<div class="viewcode-block" id="Molecule.order_ring"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.order_ring">[docs]</a>    <span class="k">def</span> <span class="nf">order_ring</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring_indices</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Order the ring indices so that they are sequential along the ring</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connection_table</span><span class="p">()</span>
        <span class="n">new_ring</span> <span class="o">=</span> <span class="p">[</span><span class="n">ring_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">iat</span> <span class="ow">in</span> <span class="n">new_ring</span> <span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">jat</span> <span class="k">for</span> <span class="n">jat</span> <span class="ow">in</span> <span class="n">conect</span><span class="p">[</span><span class="n">iat</span><span class="p">]</span> <span class="k">if</span> <span class="n">jat</span> <span class="ow">in</span> <span class="n">ring_indices</span><span class="p">]</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">jat</span> <span class="k">for</span> <span class="n">jat</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">jat</span> <span class="ow">in</span> <span class="n">new_ring</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">new_ring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">new_ring</span></div>

<span class="c1">#===========================================================================</span>
<span class="c1">#==== Geometry operations ==================================================</span>
<span class="c1">#===========================================================================</span>


<div class="viewcode-block" id="Molecule.translate"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Move the molecule in space by *vector*, expressed in *unit*.</span>

<span class="sd">        *vector* should be an iterable container of length 3 (usually tuple, list or numpy array). *unit* describes unit of values stored in *vector*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">Units</span><span class="o">.</span><span class="n">conversion_ratio</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="s1">&#39;angstrom&#39;</span><span class="p">)</span>
        <span class="n">xyz_array</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">xyz_array</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.rotate_lattice"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.rotate_lattice">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotate **only** lattice vectors of the molecule with given rotation *matrix*.</span>

<span class="sd">        *matrix* should be a container with 9 numerical values. It can be a list (tuple, numpy array etc.) listing matrix elements row-wise, either flat (``[1,2,3,4,5,6,7,8,9]``) or in two-level fashion (``[[1,2,3],[4,5,6],[7,8,9]]``).</span>

<span class="sd">        .. note::</span>

<span class="sd">            This method does not check if *matrix* is a proper rotation matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">]</span></div>


<div class="viewcode-block" id="Molecule.rotate"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotate the molecule with given rotation *matrix*. If *lattice* is ``True``, rotate lattice vectors too.</span>

<span class="sd">        *matrix* should be a container with 9 numerical values. It can be a list (tuple, numpy array etc.) listing matrix elements row-wise, either flat (``[1,2,3,4,5,6,7,8,9]``) or in two-level fashion (``[[1,2,3],[4,5,6],[7,8,9]]``).</span>

<span class="sd">        .. note::</span>

<span class="sd">            This method does not check if *matrix* is a proper rotation matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">xyz_array</span> <span class="o">=</span> <span class="n">xyz_array</span><span class="nd">@matrix</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">xyz_array</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lattice</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotate_lattice</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.align_lattice"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.align_lattice">[docs]</a>    <span class="k">def</span> <span class="nf">align_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="s1">&#39;AMS&#39;</span><span class="p">,</span> <span class="n">zero</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotate the molecule in such a way that lattice vectors are aligned with the coordinate system.</span>

<span class="sd">        This method is meant to be used with periodic systems only. Using it on a |Molecule| instance with an empty ``lattice`` attribute has no effect.</span>

<span class="sd">        Possible values of the *convention* argument are:</span>

<span class="sd">        *   ``AMS`` (default) -- for 1D systems the lattice vector aligned with X axis. For 2D systems both lattice vectors aligned with XY plane. No constraints for 3D systems</span>
<span class="sd">        *   ``reax`` (convention used by `ReaxFF &lt;https://www.scm.com/product/reaxff&gt;`_) -- second lattice vector (if present) aligned with YZ plane. Third vector (if present) aligned with Z axis.</span>

<span class="sd">        *zero* argument can be used to specify the numerical tolerance for zero (used to determine if some vector is already aligned with a particular axis or plane).</span>

<span class="sd">        The returned boolean value indicates if any rotation happened.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="p">(</span><span class="s1">&#39;NOTE: align_lattice called on a Molecule without any lattice&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">rotated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">convention</span> <span class="o">==</span> <span class="s1">&#39;AMS&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">zero</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">):</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">rotated</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">zero</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">):</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">:</span>
                    <span class="n">mat</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">rotated</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="n">convention</span> <span class="o">==</span> <span class="s1">&#39;reax&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">zero</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">):</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">rotated</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">dim</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">rotated</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s2">&quot;align_lattice: unknown convention: </span><span class="si">{}</span><span class="s2">. Possible values are &#39;AMS&#39; or &#39;reax&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">convention</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rotated</span></div>


<div class="viewcode-block" id="Molecule.rotate_bond"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.rotate_bond">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond</span><span class="p">,</span> <span class="n">moving_atom</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;radian&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotate part of this molecule containing *moving_atom* along axis defined by *bond* by an *angle* expressed in *unit*.</span>

<span class="sd">        *bond* should be chosen in such a way, that it divides the molecule into two parts (using a bond that forms a ring results in a |MoleculeError|). *moving_atom* has to belong to *bond* and is used to pick which part of the molecule is rotated. A positive angle denotes counterclockwise rotation (when looking along the bond, from the stationary part of the molecule).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">moving_atom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bond</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;rotate_bond: atom has to belong to the bond&#39;</span><span class="p">)</span>

        <span class="n">atoms_to_rotate</span> <span class="o">=</span> <span class="p">{</span><span class="n">moving_atom</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">bond</span><span class="p">:</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms_to_rotate</span><span class="p">:</span>
                        <span class="n">atoms_to_rotate</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                        <span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

        <span class="n">dfs</span><span class="p">(</span><span class="n">moving_atom</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms_to_rotate</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;rotate_bond: chosen bond does not divide the molecule&#39;</span><span class="p">)</span>

        <span class="n">other_end</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">moving_atom</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other_end</span><span class="o">.</span><span class="n">vector_to</span><span class="p">(</span><span class="n">moving_atom</span><span class="p">))</span>
        <span class="n">rotmat</span> <span class="o">=</span> <span class="n">axis_rotation_matrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other_end</span><span class="o">.</span><span class="n">vector_to</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>

        <span class="n">xyz_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">atom_subset</span><span class="o">=</span><span class="n">atoms_to_rotate</span><span class="p">)</span>
        <span class="n">xyz_array</span> <span class="o">+=</span> <span class="n">trans</span>
        <span class="n">xyz_array</span> <span class="o">=</span> <span class="n">xyz_array</span><span class="nd">@rotmat</span><span class="o">.</span><span class="n">T</span>
        <span class="n">xyz_array</span> <span class="o">-=</span> <span class="n">trans</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">xyz_array</span><span class="p">,</span> <span class="n">atom_subset</span><span class="o">=</span><span class="n">atoms_to_rotate</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.resize_bond"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.resize_bond">[docs]</a>    <span class="k">def</span> <span class="nf">resize_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond</span><span class="p">,</span> <span class="n">moving_atom</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the length of *bond* to *length* expressed in *unit* by moving part of the molecule containing *moving_atom*</span>

<span class="sd">        *bond* should be chosen in such a way, that it divides the molecule into two parts (using a bond that forms a ring results in a |MoleculeError|). *moving_atom* has to belong to *bond* and is used to pick which part of the molecule is moved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">moving_atom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bond</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;resize_bond: atom has to belong to the bond&#39;</span><span class="p">)</span>

        <span class="n">atoms_to_move</span> <span class="o">=</span> <span class="p">{</span><span class="n">moving_atom</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">bond</span><span class="p">:</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms_to_move</span><span class="p">:</span>
                        <span class="n">atoms_to_move</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                        <span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

        <span class="n">dfs</span><span class="p">(</span><span class="n">moving_atom</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms_to_move</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;resize_bond: chosen bond does not divide molecule&#39;</span><span class="p">)</span>

        <span class="n">bond_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">as_vector</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">moving_atom</span><span class="p">))</span>
        <span class="n">trans_v</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">length</span><span class="o">/</span><span class="n">bond</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">unit</span><span class="p">))</span> <span class="o">*</span> <span class="n">bond_v</span>

        <span class="n">xyz_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">atom_subset</span><span class="o">=</span><span class="n">atoms_to_move</span><span class="p">)</span>
        <span class="n">xyz_array</span> <span class="o">+=</span> <span class="n">trans_v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">xyz_array</span><span class="p">,</span> <span class="n">atom_subset</span><span class="o">=</span><span class="n">atoms_to_move</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.closest_atom"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.closest_atom">[docs]</a>    <span class="k">def</span> <span class="nf">closest_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the atom of the molecule that is the closest one to some *point* in space.</span>

<span class="sd">        *point* should be an iterable container of length 3 (for example: tuple, |Atom|, list, numpy array). *unit* describes unit of values stored in *point*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">*</span> <span class="n">Units</span><span class="o">.</span><span class="n">conversion_ratio</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="s1">&#39;angstrom&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">*</span> <span class="n">Units</span><span class="o">.</span><span class="n">conversion_ratio</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="s1">&#39;angstrom&#39;</span><span class="p">)</span>

        <span class="n">xyz_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
        <span class="n">dist_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">point</span> <span class="o">-</span> <span class="n">xyz_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">dist_array</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="Molecule.distance_to_point"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.distance_to_point">[docs]</a>    <span class="k">def</span> <span class="nf">distance_to_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="n">result_unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the distance between the molecule and some *point* in space (distance between *point* and :meth:`closest_atom`).</span>

<span class="sd">        *point* should be an iterable container of length 3 (for example: tuple, |Atom|, list, numpy array). *unit* describes unit of values stored in *point*. Returned value is expressed in *result_unit*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">at</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_atom</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">at</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">result_unit</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.distance_to_mol"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.distance_to_mol">[docs]</a>    <span class="k">def</span> <span class="nf">distance_to_mol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">result_unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="n">return_atoms</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the distance between the molecule and some *other* molecule.</span>

<span class="sd">        The distance is measured as the smallest distance between any atom of this molecule and any atom of *other* molecule. Returned distance is expressed in *result_unit*.</span>

<span class="sd">        If *return_atoms* is ``False``, only a single number is returned.  If *return_atoms* is ``True``, the method returns a tuple ``(distance, atom1, atom2)`` where ``atom1`` and ``atom2`` are atoms fulfilling the minimal distance, with atom1 belonging to this molecule and atom2 to *other*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz_array1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
        <span class="n">xyz_array2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>

        <span class="n">dist_array</span> <span class="o">=</span> <span class="n">distance_array</span><span class="p">(</span><span class="n">xyz_array1</span><span class="p">,</span> <span class="n">xyz_array2</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">Units</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">dist_array</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="n">result_unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_atoms</span><span class="p">:</span>
            <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">dist_array</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> <span class="n">dist_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">atom1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">atom2</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">idx2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="Molecule.wrap"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.wrap">[docs]</a>    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="n">angle_unit</span><span class="o">=</span><span class="s1">&#39;radian&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;wrap(self, length, angle=2*pi, length_unit=&#39;angstrom&#39;, angle_unit=&#39;radian&#39;)</span>

<span class="sd">        Transform the molecule wrapping its x-axis around z-axis. This method is useful for building nanotubes or molecular wedding rings.</span>

<span class="sd">        Atomic coordinates are transformed in the following way:</span>

<span class="sd">        *   z coordinates remain untouched</span>
<span class="sd">        *   x axis gets wrapped around the circle centered in the origin of new coordinate system. Each segment of x axis of length *length* ends up as an arc of a circle subtended by an angle *angle*. The radius of this circle is R = *length*/*angle*.</span>
<span class="sd">        *   part of the plane between the x axis and the line y=R is transformed into the interior of the circle, with line y=R being squashed into a single point - the center of the circle.</span>
<span class="sd">        *   part of the plane above line y=R is dropped</span>
<span class="sd">        *   part of the plane below x axis is transformed into outside of the circle</span>
<span class="sd">        *   transformation is done in such a way that distances along y axis are preserved</span>

<span class="sd">        Before:</span>

<span class="sd">        .. image:: ../_static/wrap.*</span>

<span class="sd">        After:</span>

<span class="sd">        .. image:: ../_static/wrap2.*</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">Units</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">length_unit</span><span class="p">,</span> <span class="s1">&#39;angstrom&#39;</span><span class="p">)</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">Units</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">angle_unit</span><span class="p">,</span> <span class="s1">&#39;radian&#39;</span><span class="p">)</span>

        <span class="n">xy_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xy_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;wrap: x-extension of the molecule is larger than length&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">angle</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;wrap: angle must be between 0 and 2*pi&#39;</span><span class="p">)</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">angle</span>

        <span class="n">x_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">-</span> <span class="n">xy_array</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">xy_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">R</span><span class="p">)</span>
        <span class="n">y_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">-</span> <span class="n">xy_array</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">xy_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">R</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">at</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">x_array</span><span class="p">,</span> <span class="n">y_array</span><span class="p">):</span>
            <span class="n">at</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="Molecule.get_center_of_mass"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.get_center_of_mass">[docs]</a>    <span class="k">def</span> <span class="nf">get_center_of_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the center of mass of the molecule (as a tuple). Returned coordinates are expressed in *unit*.&quot;&quot;&quot;</span>
        <span class="n">mass_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">mass</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="n">xyz_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
        <span class="n">xyz_array</span> <span class="o">*=</span> <span class="n">mass_array</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">xyz_array</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">/=</span> <span class="n">mass_array</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">center</span> <span class="o">*</span> <span class="n">Units</span><span class="o">.</span><span class="n">conversion_ratio</span><span class="p">(</span><span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">))</span></div>


<div class="viewcode-block" id="Molecule.get_mass"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.get_mass">[docs]</a>    <span class="k">def</span> <span class="nf">get_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;amu&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the mass of the molecule, by default in atomic mass units.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">at</span><span class="o">.</span><span class="n">mass</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span> <span class="o">*</span> <span class="n">Units</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;amu&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.get_density"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.get_density">[docs]</a>    <span class="k">def</span> <span class="nf">get_density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the density in kg/m^3&quot;&quot;&quot;</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_cell_volume</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-30</span> <span class="c1"># in m^3</span>
        <span class="n">mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mass</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;kg&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mass</span><span class="o">/</span><span class="n">vol</span></div>

<div class="viewcode-block" id="Molecule.get_formula"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.get_formula">[docs]</a>    <span class="k">def</span> <span class="nf">get_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the molecular formula of the molecule according to the Hill system.</span>

<span class="sd">        Here molecular formula is a dictionary with keys being atomic symbols. The value for each key is the number of atoms of that type. If *as_dict* is ``True``, that dictionary is returned. Otherwise, it is converted into a string::</span>

<span class="sd">            &gt;&gt;&gt; mol = Molecule(&#39;Ubiquitin.xyz&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(m.get_formula(True))</span>
<span class="sd">            {&#39;N&#39;: 105, &#39;C&#39;: 378, &#39;O&#39;: 118, &#39;S&#39;: 1, &#39;H&#39;: 629}</span>
<span class="sd">            &gt;&gt;&gt; print(m.get_formula(False))</span>
<span class="sd">            C378H629N105O118S1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">occ</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">occ</span><span class="p">:</span>
                <span class="n">occ</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">occ</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">symbol</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">occ</span>

        <span class="k">def</span> <span class="nf">string_for_sym</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">occ</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">occ</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">occ</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">sym</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{sym}{n}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;C&#39;</span> <span class="ow">in</span> <span class="n">occ</span><span class="p">:</span>
            <span class="c1"># for organic molecules C and H come first</span>
            <span class="k">return</span> <span class="n">string_for_sym</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">occ</span><span class="p">)</span> <span class="o">+</span> <span class="n">string_for_sym</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="n">occ</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">string_for_sym</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">occ</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">occ</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for inorganic systems the order is strictly alphabetic</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">string_for_sym</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">occ</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">occ</span><span class="p">))</span></div>


<div class="viewcode-block" id="Molecule.apply_strain"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.apply_strain">[docs]</a>    <span class="k">def</span> <span class="nf">apply_strain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strain</span><span class="p">,</span> <span class="n">voigt_form</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a strain deformation to a periodic system (i.e. with a non-empty ``lattice`` attribute).</span>
<span class="sd">        The atoms in the unit cell will be strained accordingly, keeping the fractional atomic coordinates constant.</span>

<span class="sd">        If ``voigt_form=False``, *strain* should be a container with n*n numerical values, where n is the number of ``lattice`` vectors. It can be a list (tuple, numpy array etc.) listing matrix elements row-wise, either flat (e.g. ``[e_xx, e_xy, e_xz, e_yx, e_yy, e_yz, e_zx, e_zy, e_zz]``) or in two-level fashion (e.g. ``[[e_xx, e_xy, e_xz],[e_yx, e_yy, e_yz],[e_zx, e_zy, e_zz]]``).</span>
<span class="sd">        If ``voigt_form=True``, *strain* should be passed in voigt form (for 3D periodic systems: ``[e_xx, e_yy, e_zz, gamma_yz, gamma_xz, gamma_xy]``; for 2D periodic systems: ``[e_xx, e_yy, gamma_xy]``; for 1D periodic systems: ``[e_xx]``  with e_xy = gamma_xy/2,...). Example usage::</span>

<span class="sd">            &gt;&gt;&gt; graphene = Molecule(&#39;graphene.xyz&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(graphene)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         C      0.000000      0.000000      0.000000</span>
<span class="sd">                2         C      1.230000      0.710141      0.000000</span>
<span class="sd">              Lattice:</span>
<span class="sd">                    2.4600000000     0.0000000000     0.0000000000</span>
<span class="sd">                    1.2300000000     2.1304224900     0.0000000000</span>
<span class="sd">            &gt;&gt;&gt; graphene.apply_strain([0.1,0.2,0.0], voigt_form=True)])</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         C      0.000000      0.000000      0.000000</span>
<span class="sd">                2         C      1.353000      0.852169      0.000000</span>
<span class="sd">              Lattice:</span>
<span class="sd">                    2.7060000000     0.0000000000     0.0000000000</span>
<span class="sd">                    1.3530000000     2.5565069880     0.0000000000</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;apply_strain: can only be used for periodic systems.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">align_lattice</span><span class="p">(</span><span class="n">convention</span><span class="o">=</span><span class="s1">&#39;AMS&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;apply_strain: the lattice vectors should follow the convention of AMS (i.e. for 1D-periodic systems the lattice vector should be along the x-axis, while for 2D-periodic systems the two vectors should be on the XY plane. Consider using the align_lattice function.&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">from_voigt_to_matrix</span><span class="p">(</span><span class="n">strain_voigt</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strain_voigt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;apply_strain: strain for </span><span class="si">%i</span><span class="s1">-dim periodic system needs </span><span class="si">%i</span><span class="s1">-sized vector in Voigt format&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>

            <span class="n">strain_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">strain_voigt</span><span class="p">[:</span><span class="n">n</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">strain_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_voigt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">strain_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_voigt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">strain_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_voigt</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">strain_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_voigt</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">strain_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_voigt</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">strain_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_voigt</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">strain_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_voigt</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">strain_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_voigt</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="k">return</span> <span class="n">strain_matrix</span>

        <span class="k">if</span> <span class="n">voigt_form</span><span class="p">:</span>
            <span class="n">strain</span> <span class="o">=</span> <span class="n">from_voigt_to_matrix</span><span class="p">(</span><span class="n">strain</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">strain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strain</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;apply_strain: could not convert the strain to a (</span><span class="si">%i</span><span class="s1">,</span><span class="si">%i</span><span class="s1">) numpy array&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">lattice_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lattice_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)[:</span><span class="n">n</span><span class="p">,:</span><span class="n">n</span><span class="p">]</span>

        <span class="n">strained_lattice</span> <span class="o">=</span> <span class="n">lattice_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">strain</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
        <span class="n">frac_coords_transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">lattice_mat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">fractional_coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,:</span><span class="n">n</span><span class="p">]</span><span class="nd">@frac_coords_transf</span><span class="o">.</span><span class="n">T</span>
        <span class="n">coords</span><span class="p">[:,:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">strained_lattice</span><span class="o">.</span><span class="n">T</span><span class="nd">@fractional_coords</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">vec</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">)))</span> <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">strained_lattice</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span></div>


<div class="viewcode-block" id="Molecule.map_to_central_cell"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.map_to_central_cell">[docs]</a>    <span class="k">def</span> <span class="nf">map_to_central_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">around_origin</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maps all atoms to the original cell. If *around_origin=True* the atoms will be mapped to the cell with fractional coordinates [-0.5,0.5], otherwise to the the cell in which all fractional coordinates are in the [0:1] interval.&quot;&quot;&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;map_to_central_cell: can only be used for periodic systems.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">lattice_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lattice_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)[:</span><span class="n">n</span><span class="p">,:</span><span class="n">n</span><span class="p">]</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
        <span class="n">frac_coords_transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">lattice_mat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">fractional_coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,:</span><span class="n">n</span><span class="p">]</span><span class="nd">@frac_coords_transf</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">around_origin</span><span class="p">:</span>
            <span class="n">fractional_coords</span> <span class="o">=</span> <span class="n">fractional_coords</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">fractional_coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fractional_coords</span> <span class="o">=</span> <span class="n">fractional_coords</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">fractional_coords</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">[:,:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lattice_mat</span><span class="o">.</span><span class="n">T</span><span class="nd">@fractional_coords</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.perturb_atoms"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.perturb_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">perturb_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_displacement</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Randomly perturb the coordinates of the atoms in the molecule.</span>

<span class="sd">        Each Cartesian coordinate is displaced by a random value picked out of a uniform distribution in the interval *[-max_displacement, +max_displacement]* (converted to requested *unit*).</span>

<span class="sd">        By default, all atoms are perturbed. It is also possible to perturb only part of the molecule, indicated by *atoms* argument. It should be a list of atoms belonging to the molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Units</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">max_displacement</span><span class="p">,</span> <span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>

        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span></div>


<div class="viewcode-block" id="Molecule.perturb_lattice"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.perturb_lattice">[docs]</a>    <span class="k">def</span> <span class="nf">perturb_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_displacement</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="n">ams_convention</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Randomly perturb the lattice vectors.</span>

<span class="sd">        The Cartesian components of the lattice vectors are changed by a random value picked out of a uniform distribution in the interval *[-max_displacement, +max_displacement]* (converted to requested *unit*).</span>

<span class="sd">        If *ams_convention=True* then for 1D-periodic systems only the x-component of the lattice vector is perturbed, and for 2D-periodic systems only the xy-components of the lattice vectors are perturbed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Units</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">max_displacement</span><span class="p">,</span> <span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;perturb_lattice can only be applied to periodic systems&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ams_convention</span><span class="p">:</span>
                <span class="c1"># For 1D systems we only want to perturb the first number. For 2D systems only the first 2 numbers of each vector.</span>
                <span class="n">perturbed_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="n">n</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">perturbed_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">perturbed_vec</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.substitute"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.substitute">[docs]</a>    <span class="k">def</span> <span class="nf">substitute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connector</span><span class="p">,</span> <span class="n">ligand</span><span class="p">,</span> <span class="n">ligand_connector</span><span class="p">,</span> <span class="n">bond_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">cost_func_mol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cost_func_array</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Substitute a part of this molecule with *ligand*.</span>

<span class="sd">        *connector* should be a pair of atoms that belong to this molecule and form a bond. The first atom of *connector* is the atom to which the  ligand will be connected. The second atom of *connector* is removed from the molecule, together with all &quot;further&quot; atoms connected to it (that allows, for example, to substitute the whole functional group with another). Using *connector* that is a part or a ring triggers an exception.</span>

<span class="sd">        *ligand_connector* is a *connector* analogue, but for *ligand*. IT describes the bond in the *ligand* that will be connected with the bond in this molecule descibed by *connector*.</span>

<span class="sd">        If this molecule or *ligand* don&#39;t have any bonds, :meth:`guess_bonds` is used.</span>

<span class="sd">        After removing all unneeded atoms, the *ligand* is translated to a new position, rotated, and connected by bond with the core molecule. The new |Bond| is added between the first atom of *connector* and the first atom of *ligand_connector*. The length of that bond can be adjusted with *bond_length* argument, otherwise the default is the sum of atomic radii taken from |PeriodicTable|.</span>

<span class="sd">        Then the *ligand* is rotated along newly created bond to find the optimal position. The full 360 degrees angle is divided into *steps* equidistant rotations and each such rotation is evaluated using a cost function. The orientation with the minimal cost is chosen.</span>

<span class="sd">        The default cost function is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \sum_{i \in mol, j\in lig} e^{-R_{ij}}</span>

<span class="sd">        A different cost function can be also supplied by the user, using one of the two remaining arguments: *cost_func_mol* or *cost_func_array*. *cost_func_mol* should be a function that takes two |Molecule| instances: this molecule (after removing unneeded atoms) and ligand in a particular orientation (also without unneeded atoms) and returns a single number (the lower the number, the better the fit). *cost_func_array* is analogous, but instead of |Molecule| instances it takes two numpy arrays (with dimensions: number of atoms x 3) with coordinates of this molecule and the ligand. If both are supplied, *cost_func_mol* takes precedence over *cost_func_array*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_is_atom</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">mol</span> <span class="ow">is</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connector</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">_is_atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">_is_atom</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;substitute: connector argument must be a pair of atoms that belong to the current molecule&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">_is_atom</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">mol</span> <span class="ow">is</span> <span class="n">ligand</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ligand_connector</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">_is_atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">_is_atom</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;substitute: ligand_connector argument must be a pair of atoms that belong to ligand&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">)</span>


        <span class="n">_ligand</span> <span class="o">=</span> <span class="n">ligand</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_ligand_connector</span> <span class="o">=</span> <span class="p">[</span><span class="n">_ligand</span><span class="p">[</span><span class="n">ligand</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">)]</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">ligand_connector</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">guess_bonds</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_ligand</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_ligand</span><span class="o">.</span><span class="n">guess_bonds</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">stay</span><span class="p">,</span> <span class="n">go</span><span class="p">,</span> <span class="n">delete</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">neighbors</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="n">stay</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="n">go</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;substitute: </span><span class="si">{}</span><span class="s1"> is a part of a cycle&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">N</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">delete</span><span class="p">:</span>
                    <span class="n">delete</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">stay</span><span class="p">,</span> <span class="n">go</span><span class="p">,</span> <span class="n">delete</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="n">stay</span><span class="p">,</span> <span class="n">go</span> <span class="o">=</span> <span class="n">connector</span>
        <span class="n">stay_lig</span><span class="p">,</span> <span class="n">go_lig</span> <span class="o">=</span> <span class="n">_ligand_connector</span>

        <span class="c1">#remove &#39;go&#39; and all connected atoms from self</span>
        <span class="n">atoms_to_delete</span> <span class="o">=</span> <span class="p">{</span><span class="n">go</span><span class="p">}</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">go</span><span class="p">,</span> <span class="n">stay</span><span class="p">,</span> <span class="n">go</span><span class="p">,</span> <span class="n">atoms_to_delete</span><span class="p">,</span> <span class="s1">&#39;connector&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms_to_delete</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete_atom</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

        <span class="c1">#remove &#39;go_lig&#39; and all connected atoms from _ligand</span>
        <span class="n">atoms_to_delete</span> <span class="o">=</span> <span class="p">{</span><span class="n">go_lig</span><span class="p">}</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">go</span><span class="p">,</span> <span class="n">stay_lig</span><span class="p">,</span> <span class="n">go_lig</span><span class="p">,</span> <span class="n">atoms_to_delete</span><span class="p">,</span> <span class="s1">&#39;ligand_connector&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms_to_delete</span><span class="p">:</span>
            <span class="n">_ligand</span><span class="o">.</span><span class="n">delete_atom</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

        <span class="c1">#move the _ligand such that &#39;go_lig&#39; is in (0,0,0) and rotate it to its desired position</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stay</span><span class="o">.</span><span class="n">vector_to</span><span class="p">(</span><span class="n">go</span><span class="p">))</span>
        <span class="n">vec_lig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">go_lig</span><span class="o">.</span><span class="n">vector_to</span><span class="p">(</span><span class="n">stay_lig</span><span class="p">))</span>

        <span class="n">_ligand</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">go_lig</span><span class="o">.</span><span class="n">vector_to</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>
        <span class="n">_ligand</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">(</span><span class="n">vec_lig</span><span class="p">,</span> <span class="n">vec</span><span class="p">))</span>

        <span class="c1">#rotate the _ligand along the bond to create &#39;steps&#39; copies</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">steps</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">steps</span><span class="p">)]</span>
        <span class="n">axis_matrices</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis_rotation_matrix</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span> <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]</span>
        <span class="n">xyz_ligand</span> <span class="o">=</span> <span class="n">_ligand</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
        <span class="n">xyz_ligands</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xyz_ligand</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">xyz_ligand</span><span class="nd">@matrix</span> <span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">axis_matrices</span><span class="p">])</span>

        <span class="c1">#move all the _ligand copies to the right position</span>
        <span class="k">if</span> <span class="n">bond_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bond_length</span> <span class="o">=</span> <span class="n">stay</span><span class="o">.</span><span class="n">radius</span> <span class="o">+</span> <span class="n">stay_lig</span><span class="o">.</span><span class="n">radius</span>
        <span class="n">vec</span> <span class="o">*=</span> <span class="n">bond_length</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stay</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">+</span> <span class="n">vec</span>
        <span class="n">trans_vec</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stay_lig</span><span class="o">.</span><span class="n">vector_to</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>
        <span class="n">xyz_ligands</span> <span class="o">+=</span> <span class="n">trans_vec</span>

        <span class="c1">#find the best _ligand orientation</span>
        <span class="k">if</span> <span class="n">cost_func_mol</span><span class="p">:</span>
            <span class="n">best_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="n">xyz_ligands</span><span class="p">:</span>
                <span class="n">_ligand</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">lig</span><span class="p">)</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">cost_func_mol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_ligand</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="n">best_score</span><span class="p">:</span>
                    <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                    <span class="n">best_lig</span> <span class="o">=</span> <span class="n">lig</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xyz_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cost_func_array</span><span class="p">:</span>
                <span class="n">best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">cost_func_array</span><span class="p">(</span><span class="n">xyz_self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xyz_ligands</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">xyz_ligands</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance_array</span><span class="p">(</span><span class="n">xyz_ligands</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">),</span> <span class="n">xyz_self</span><span class="p">)</span>
                <span class="n">dist_matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist_matrix</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
            <span class="n">best_lig</span> <span class="o">=</span> <span class="n">xyz_ligands</span><span class="p">[</span><span class="n">best</span><span class="p">]</span>

        <span class="c1">#add the best _ligand to the molecule</span>
        <span class="n">_ligand</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">best_lig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_molecule</span><span class="p">(</span><span class="n">_ligand</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">stay</span><span class="p">,</span> <span class="n">stay_lig</span><span class="p">)</span></div>


<span class="c1">#===========================================================================</span>
<span class="c1">#==== Magic methods ========================================================</span>
<span class="c1">#===========================================================================</span>


<div class="viewcode-block" id="Molecule.__repr__"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># get_formula(), but with C,H first and counts of 1 not present in the string</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">at</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="s1">&#39;HC&#39;</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">at</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="n">at</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">syms</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">at</span><span class="p">]</span>
        <span class="n">uniq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">syms</span><span class="p">))</span> <span class="c1"># preserves order</span>
        <span class="n">cnts</span> <span class="o">=</span> <span class="p">[</span><span class="n">syms</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">uniq</span><span class="p">]</span>
        <span class="n">cnts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cnts</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{at}{cnt}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">at</span><span class="p">,</span><span class="n">cnt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">uniq</span><span class="p">,</span> <span class="n">cnts</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.__class__.__name__}</span><span class="s2">(&#39;</span><span class="si">{s}</span><span class="s2">&#39; at {hex(id(self))})&quot;</span></div>


<div class="viewcode-block" id="Molecule.__len__"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The length of the molecule is the number of atoms.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.__str__"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">str</span><span class="p">()</span></div>

<div class="viewcode-block" id="Molecule.str"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.str">[docs]</a>    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string representation of the molecule.</span>

<span class="sd">        Information about atoms is printed in ``xyz`` format fashion -- each atom in a separate, enumerated line. Then, if the molecule contains any bonds, they are printed. Each bond is printed in a separate line, with information about both atoms and bond order. Example:</span>

<span class="sd">        .. code-block:: none</span>

<span class="sd">                  Atoms:</span>
<span class="sd">                    1         N       0.00000       0.00000       0.38321</span>
<span class="sd">                    2         H       0.94218       0.00000      -0.01737</span>
<span class="sd">                    3         H      -0.47109       0.81595      -0.01737</span>
<span class="sd">                    4         H      -0.47109      -0.81595      -0.01737</span>
<span class="sd">                  Bonds:</span>
<span class="sd">                    (1)----1----(2)</span>
<span class="sd">                    (1)----1----(3)</span>
<span class="sd">                    (1)----1----(4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;  Atoms: </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%5i</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">+</span> <span class="n">atom</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">decimal</span><span class="o">=</span><span class="n">decimal</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">_tmpid</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  Bonds: </span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;   (</span><span class="si">%d</span><span class="s1">)--</span><span class="si">%1.1f</span><span class="s1">--(</span><span class="si">%d</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">_tmpid</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">_tmpid</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">atom</span><span class="o">.</span><span class="n">_tmpid</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  Lattice:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;    </span><span class="si">{:16.10f}</span><span class="s1"> </span><span class="si">{:16.10f}</span><span class="s1"> </span><span class="si">{:16.10f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="Molecule.__iter__"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over atoms.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.__getitem__"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The bracket notation can be used to access atoms or bonds directly.</span>

<span class="sd">        If *key* is a single int (``mymol[i]``), return i-th atom of the molecule. If *key* is a pair of ints (``mymol[(i,j)]``), return the bond between i-th and j-th atom (``None`` if such a bond does not exist). Negative integers can be used to access atoms enumerated in the reversed order.</span>

<span class="sd">        This notation is read only: things like ``mymol[3] = Atom(...)`` are forbidden.</span>

<span class="sd">        Numbering of atoms within a molecule starts with 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;__index__&#39;</span><span class="p">):</span>  <span class="c1"># Available in all &quot;int-like&quot; objects; see PEP 357</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="s1">&#39;Numbering of atoms starts with 1&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">key</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Molecule: argument ({repr(key)}) of invalid type inside []&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Molecule: argument ({repr(key)}) of invalid size inside []&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.__add__"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new molecule that is a sum of this molecule and some *other* molecule::</span>

<span class="sd">            newmol = mol1 + mol2</span>

<span class="sd">        The new molecule has atoms, bonds and all other elements distinct from both components. The ``properties`` of ``newmol`` are a copy of the ``properties`` of ``mol1`` :meth:`soft_updated&lt;scm.plams.core.settings.Settings.soft_update&gt;` with the ``properties`` of ``mol2``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">+=</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="Molecule.__iadd__"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.__iadd__">[docs]</a>    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy *other* molecule and add the copy to this one.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_molecule</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


<div class="viewcode-block" id="Molecule.__round__"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.__round__">[docs]</a>    <span class="k">def</span> <span class="nf">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndigits</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Magic method for rounding this instance&#39;s Cartesian coordinates; called by the builtin :func:`round` function.&quot;&quot;&quot;</span>
        <span class="n">ndigits</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">ndigits</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ndigits</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_coords</span><span class="p">(</span><span class="n">ndigits</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.__getstate__"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.__getstate__">[docs]</a>    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the object which is to-be pickled by, *e.g.*, :func:`pickle.dump`.</span>
<span class="sd">        As :class:`Molecule` instances are heavily nested objects,</span>
<span class="sd">        pickling them can raise a :exc:`RecursionError`.</span>
<span class="sd">        This issue is herein avoided relying on the :meth:`Molecule.as_dict()` method.</span>
<span class="sd">        See `Pickling Class Instances &lt;https://docs.python.org/3/library/pickle.html#pickling-class-instances&gt;`_</span>
<span class="sd">        for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span></div>


<div class="viewcode-block" id="Molecule.__setstate__"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.__setstate__">[docs]</a>    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Counterpart of :meth:`Molecule.__getstate__`; used for unpickling molecules.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mol_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">mol_new</span><span class="o">.</span><span class="vm">__dict__</span>

        <span class="c1"># Raised if *state* is the result of a pickled Molecule created prior to the introduction</span>
        <span class="c1"># of Molecule.__getstate__()</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">state</span>
            <span class="k">return</span>

        <span class="c1"># Molecule.from_dict() always returns a new instance</span>
        <span class="c1"># Simply steal this instance&#39;s attributes and changed its Atoms/Bonds parent Molecule</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">at</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">bond</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span></div>


<span class="c1">#===========================================================================</span>
<span class="c1">#==== Converters ===========================================================</span>
<span class="c1">#===========================================================================</span>



<div class="viewcode-block" id="Molecule.as_dict"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store all information about the molecule in a dictionary.</span>

<span class="sd">        The returned dictionary is, in principle, identical to ``self.__dict__`` of the current instance, apart from the fact that all |Atom| and |Bond| instances in ``atoms`` and ``bonds`` lists are replaced with dictionaries storing corresponing information.</span>

<span class="sd">        This method is a counterpart of :meth:`from_dict`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mol_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="n">atom_indices</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mol_dict</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">])}</span>
        <span class="n">bond_indices</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mol_dict</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">])}</span>
        <span class="n">atom_dicts</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mol_dict</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]]</span>
        <span class="n">bond_dicts</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">mol_dict</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">a_dict</span> <span class="ow">in</span> <span class="n">atom_dicts</span><span class="p">:</span>
            <span class="n">a_dict</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_indices</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a_dict</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bond_indices</span><span class="p">]</span>
            <span class="k">del</span><span class="p">(</span><span class="n">a_dict</span><span class="p">[</span><span class="s1">&#39;mol&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b_dict</span> <span class="ow">in</span> <span class="n">bond_dicts</span><span class="p">:</span>
            <span class="n">b_dict</span><span class="p">[</span><span class="s1">&#39;atom1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom_indices</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">b_dict</span><span class="p">[</span><span class="s1">&#39;atom1&#39;</span><span class="p">])]</span>
            <span class="n">b_dict</span><span class="p">[</span><span class="s1">&#39;atom2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom_indices</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">b_dict</span><span class="p">[</span><span class="s1">&#39;atom2&#39;</span><span class="p">])]</span>
            <span class="k">del</span><span class="p">(</span><span class="n">b_dict</span><span class="p">[</span><span class="s1">&#39;mol&#39;</span><span class="p">])</span>
        <span class="n">mol_dict</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom_dicts</span>
        <span class="n">mol_dict</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bond_dicts</span>
        <span class="k">return</span> <span class="n">mol_dict</span></div>


<div class="viewcode-block" id="Molecule.from_dict"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a new |Molecule| instance based on the information stored in a *dictionary*.</span>

<span class="sd">        This method is a counterpart of :meth:`as_dict`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">mol</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)</span>
        <span class="n">atom_dicts</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">bond_dicts</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">bonds</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">bonds</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">a_dict</span> <span class="ow">in</span> <span class="n">atom_dicts</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">()</span>
            <span class="n">a</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">a_dict</span>
            <span class="n">a</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">mol</span>
            <span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">mol</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b_dict</span> <span class="ow">in</span> <span class="n">bond_dicts</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">Bond</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">b_dict</span><span class="p">[</span><span class="s1">&#39;atom1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">b_dict</span><span class="p">[</span><span class="s1">&#39;atom1&#39;</span><span class="p">]]</span>
            <span class="n">b_dict</span><span class="p">[</span><span class="s1">&#39;atom2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">b_dict</span><span class="p">[</span><span class="s1">&#39;atom2&#39;</span><span class="p">]]</span>
            <span class="n">b</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">b_dict</span>
            <span class="n">b</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">mol</span>
            <span class="n">mol</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span></div>

<div class="viewcode-block" id="Molecule.from_elements"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.from_elements">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_elements</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">elements</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a new |Molecule| instance based on a list of *elements*.</span>

<span class="sd">        By default it sets all coordinates to zero</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span> <span class="p">:</span>
            <span class="n">at</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="n">symbol</span><span class="o">=</span><span class="n">el</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
            <span class="n">mol</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span></div>

<div class="viewcode-block" id="Molecule.as_array"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.as_array">[docs]</a>    <span class="k">def</span> <span class="nf">as_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return cartesian coordinates of this molecule&#39;s atoms as a numpy array.</span>

<span class="sd">        *atom_subset* argument can be used to specify only a subset of atoms, it should be an iterable container with atoms belonging to this molecule.</span>

<span class="sd">        Returned value is a n*3 numpy array where n is the number of atoms in the whole molecule, or in *atom_subset*, if used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atom_subset</span> <span class="o">=</span> <span class="n">atom_subset</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">at_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_subset</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># atom_subset is an iterator</span>
            <span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">at_len</span> <span class="o">*</span> <span class="mi">3</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">at_len</span><span class="p">,</span> <span class="mi">3</span>

        <span class="n">atom_iterator</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">coords</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">atom_subset</span><span class="p">)</span>
        <span class="n">xyz_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">atom_iterator</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">xyz_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="k">return</span> <span class="n">xyz_array</span></div>


<div class="viewcode-block" id="Molecule.from_array"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.from_array">[docs]</a>    <span class="k">def</span> <span class="nf">from_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz_array</span><span class="p">,</span> <span class="n">atom_subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the cartesian coordinates of this |Molecule|, containing n atoms, with coordinates provided by a (n)*3 numpy array *xyz_array*.</span>

<span class="sd">        *atom_subset* argument can be used to specify only a subset of atoms, it should be an iterable container with atoms belonging to this molecule. It should have the same length as the first dimenstion of *xyz_array*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atom_subset</span> <span class="o">=</span> <span class="n">atom_subset</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">for</span> <span class="n">at</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atom_subset</span><span class="p">,</span> <span class="n">xyz_array</span><span class="p">):</span>
            <span class="n">at</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.__array__"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.__array__">[docs]</a>    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A magic method for constructing numpy arrays.</span>

<span class="sd">        This method ensures that passing a |Molecule| instance to numpy.array_ produces an array of Cartesian coordinates (see :meth:`.Molecule.as_array`).</span>
<span class="sd">        The array `data type`_ can, optionally, be specified in *dtype*.</span>

<span class="sd">        .. _numpy.array: https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html</span>
<span class="sd">        .. _`data type`: https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<span class="c1">#===========================================================================</span>
<span class="c1">#==== File/format IO =======================================================</span>
<span class="c1">#===========================================================================</span>



<div class="viewcode-block" id="Molecule.readxyz"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.readxyz">[docs]</a>    <span class="k">def</span> <span class="nf">readxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;XYZ Reader:</span>

<span class="sd">            The xyz format allows to store more than one geometry of a particular molecule within a single file.</span>
<span class="sd">            In such cases the *geometry* argument can be used to indicate which (in order of appearance in the file) geometry to import.</span>
<span class="sd">            Default is the first one (*geometry* = 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">newatom</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="n">shift</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">new_atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="n">symbol</span><span class="o">=</span><span class="n">num</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">shift</span><span class="p">],</span><span class="n">lst</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="n">shift</span><span class="p">],</span><span class="n">lst</span><span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="n">shift</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="n">atnum</span><span class="o">=</span><span class="n">num</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">shift</span><span class="p">],</span><span class="n">lst</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="n">shift</span><span class="p">],</span><span class="n">lst</span><span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="n">shift</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">shift</span> <span class="o">+</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">new_atom</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">suffix</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="n">shift</span><span class="o">+</span><span class="mi">5</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">new_atom</span><span class="p">)</span>


        <span class="k">def</span> <span class="nf">newlatticevec</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="nb">float</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span><span class="nb">float</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">3</span><span class="p">])))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
            <span class="n">log</span><span class="p">(</span><span class="s2">&quot;WARNING: DEPRECATED A list was passed as &#39;f&#39; argument to the Molecule.readxyz method. &#39;f&#39; should be a file, and not a list. Tip: consider using io.StringIO if you want to pass a string as input to this function&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">fr</span> <span class="o">=</span> <span class="n">geometry</span>
        <span class="n">begin</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">nohead</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">last_pos</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="k">break</span>

            <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="p">:</span> <span class="k">continue</span>
                <span class="n">first</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                    <span class="n">fr</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">nohead</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">newatom</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nohead</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="p">:</span> <span class="k">break</span>
                <span class="k">if</span> <span class="s1">&#39;VEC&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
                    <span class="n">newlatticevec</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newatom</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">fr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                    <span class="n">fr</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">begin</span><span class="p">:</span>
                    <span class="n">begin</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;comment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
                        <span class="n">newatom</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="s1">&#39;VEC&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
                       <span class="n">newlatticevec</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># If we get here, it means that we just processed a line behond the last atom or VEC line</span>
                        <span class="c1"># If this xyz file contains more than one molecule, this line might be the header of the next molecule.</span>
                        <span class="c1"># Let&#39;s move back one step, so that if we call this function again the file pointer will be at the right position</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">last_pos</span><span class="p">)</span>
                        <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nohead</span> <span class="ow">and</span> <span class="n">fr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FileError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;readxyz: cannot read frame from </span><span class="si">{f.name}</span><span class="s1">&#39;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">writexyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;comment&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;comment&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comment</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="n">decimal</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;VEC</span><span class="si">{i}</span><span class="s2"> &quot;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">f</span><span class="s2">&quot;{v:&gt;</span><span class="si">{space}</span><span class="s2">.</span><span class="si">{decimal}</span><span class="s2">f}&quot;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vec</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">readmol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>

        <span class="n">comment</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">spl</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">spl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;V2000&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">==</span> <span class="mi">39</span><span class="p">:</span>
                        <span class="n">natom</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
                        <span class="n">nbond</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">natom</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">spl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">nbond</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">spl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natom</span><span class="p">):</span>
                        <span class="n">atomline</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomline</span><span class="p">)</span> <span class="o">==</span> <span class="mi">69</span><span class="p">:</span>
                            <span class="n">crd</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">atomline</span><span class="p">[:</span><span class="mi">10</span><span class="p">]),</span><span class="nb">float</span><span class="p">(</span><span class="n">atomline</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">20</span><span class="p">]),</span><span class="nb">float</span><span class="p">(</span><span class="n">atomline</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">30</span><span class="p">]))</span>
                            <span class="n">symb</span> <span class="o">=</span> <span class="n">atomline</span><span class="p">[</span><span class="mi">31</span><span class="p">:</span><span class="mi">34</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">tmp</span> <span class="o">=</span> <span class="n">atomline</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                            <span class="n">crd</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>
                            <span class="n">symb</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="n">symbol</span><span class="o">=</span><span class="n">symb</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">crd</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbond</span><span class="p">):</span>
                        <span class="n">bondline</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bondline</span><span class="p">)</span> <span class="o">==</span> <span class="mi">21</span> <span class="p">:</span>
                            <span class="n">at1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bondline</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
                            <span class="n">at2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bondline</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span>
                            <span class="n">ordr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bondline</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">tmp</span> <span class="o">=</span> <span class="n">bondline</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                            <span class="n">at1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">at2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="n">ordr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">ordr</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                            <span class="n">ordr</span> <span class="o">=</span> <span class="n">Bond</span><span class="o">.</span><span class="n">AR</span>
                        <span class="k">if</span> <span class="n">at1</span> <span class="o">&gt;</span> <span class="n">natom</span> <span class="ow">or</span> <span class="n">at2</span> <span class="o">&gt;</span> <span class="n">natom</span> <span class="p">:</span>
                            <span class="n">at1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bondline</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
                            <span class="n">at2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bondline</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span>
                            <span class="n">ordr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bondline</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">ordr</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                                <span class="n">ordr</span> <span class="o">=</span> <span class="n">Bond</span><span class="o">.</span><span class="n">AR</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">Bond</span><span class="p">(</span><span class="n">atom1</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">at1</span><span class="p">],</span> <span class="n">atom2</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">at2</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="n">ordr</span><span class="p">))</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">spl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;V3000&#39;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">FileError</span><span class="p">(</span><span class="s1">&#39;readmol: Molfile V3000 not supported. Please convert&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">comment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comment</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;comment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">comment</span>



    <span class="k">def</span> <span class="nf">writemol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>
        <span class="n">commentblock</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span>
        <span class="k">if</span> <span class="s1">&#39;comment&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;comment&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comment</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">commentblock</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">comment</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comment</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">comment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">commentblock</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">comment</span><span class="p">,</span><span class="n">commentblock</span><span class="p">)]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">commentblock</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_atoms_id</span><span class="p">()</span>

        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%3i</span><span class="s1"> </span><span class="si">%2i</span><span class="s1">  0  0  0  0  0  0  0  0999 V2000</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%10.4f</span><span class="s1"> </span><span class="si">%9.4f</span><span class="s1"> </span><span class="si">%9.4f</span><span class="s1"> </span><span class="si">%-3s</span><span class="s1"> 0  0  0  0  0  0  0  0  0  0  0  0</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">at</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">at</span><span class="o">.</span><span class="n">z</span><span class="p">,</span><span class="n">at</span><span class="o">.</span><span class="n">symbol</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">bo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">bo</span><span class="o">.</span><span class="n">order</span>
            <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="n">Bond</span><span class="o">.</span><span class="n">AR</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%3i</span><span class="s1"> </span><span class="si">%2i</span><span class="s1"> </span><span class="si">%2i</span><span class="s1">  0  0  0  0</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bo</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span><span class="n">bo</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">id</span><span class="p">,</span><span class="n">order</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unset_atoms_id</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;M  END</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">readmol2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>

        <span class="n">bondorders</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;am&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;ar&#39;</span><span class="p">:</span><span class="n">Bond</span><span class="o">.</span><span class="n">AR</span><span class="p">,</span> <span class="s1">&#39;du&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;un&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;nc&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;@&#39;</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">FileError</span><span class="p">(</span><span class="s1">&#39;readmol2: Error in </span><span class="si">%s</span><span class="s1"> line </span><span class="si">%i</span><span class="s1">: invalid @ record&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;MOLECULE&#39;</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">mode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span>
                <span class="k">elif</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span>
                <span class="k">elif</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;charge_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span>
                <span class="k">elif</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;flags&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span>
                <span class="k">elif</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;comment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span>

            <span class="k">elif</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ATOM&#39;</span><span class="p">:</span>
                <span class="n">spl</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">FileError</span><span class="p">(</span><span class="s1">&#39;readmol2: Error in </span><span class="si">%s</span><span class="s1"> line </span><span class="si">%i</span><span class="s1">: not enough values in line&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
                <span class="n">symb</span> <span class="o">=</span> <span class="n">spl</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">crd</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">spl</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]))</span>
                <span class="n">newatom</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="n">symbol</span><span class="o">=</span><span class="n">symb</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">crd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">spl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="n">spl</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">:</span>
                    <span class="n">newatom</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;subst_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spl</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">:</span>
                    <span class="n">newatom</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;subst_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spl</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
                    <span class="n">newatom</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;charge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">spl</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">:</span>
                    <span class="n">newatom</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;flags&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spl</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">newatom</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;BOND&#39;</span><span class="p">:</span>
                <span class="n">spl</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">FileError</span><span class="p">(</span><span class="s1">&#39;readmol2: Error in </span><span class="si">%s</span><span class="s1"> line </span><span class="si">%i</span><span class="s1">: not enough values in line&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">atom1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">spl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">atom2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">spl</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">FileError</span><span class="p">(</span><span class="s1">&#39;readmol2: Error in </span><span class="si">%s</span><span class="s1"> line </span><span class="si">%i</span><span class="s1">: wrong atom ID&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
                <span class="n">newbond</span> <span class="o">=</span> <span class="n">Bond</span><span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">bondorders</span><span class="p">[</span><span class="n">spl</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">spl</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">):</span>
                        <span class="n">newbond</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">newbond</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">writemol2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">write_prop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">separator</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">form_str</span> <span class="o">=</span> <span class="s1">&#39;%-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">space</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;s&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">form_str</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">name</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">replacement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">form_str</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">replacement</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span>

        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;@&lt;TRIPOS&gt;MOLECULE</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">write_prop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> </span><span class="si">%i</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)))</span>
        <span class="n">write_prop</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">write_prop</span><span class="p">(</span><span class="s1">&#39;charge_type&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">write_prop</span><span class="p">(</span><span class="s1">&#39;flags&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">write_prop</span><span class="p">(</span><span class="s1">&#39;comment&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">@&lt;TRIPOS&gt;ATOM</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">at</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%5i</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">write_prop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">symbol</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%10.4f</span><span class="s1"> </span><span class="si">%10.4f</span><span class="s1"> </span><span class="si">%10.4f</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="n">at</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">write_prop</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">symbol</span><span class="p">)</span>
            <span class="n">write_prop</span><span class="p">(</span><span class="s1">&#39;subst_id&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
            <span class="n">write_prop</span><span class="p">(</span><span class="s1">&#39;subst_name&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
            <span class="n">write_prop</span><span class="p">(</span><span class="s1">&#39;charge&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
            <span class="n">write_prop</span><span class="p">(</span><span class="s1">&#39;flags&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">at</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">@&lt;TRIPOS&gt;BOND</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">bo</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%5i</span><span class="s1"> </span><span class="si">%5i</span><span class="s1"> </span><span class="si">%5i</span><span class="s1"> </span><span class="si">%4s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bo</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">bo</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s1">&#39;ar&#39;</span> <span class="k">if</span> <span class="n">bo</span><span class="o">.</span><span class="n">is_aromatic</span><span class="p">()</span> <span class="k">else</span> <span class="n">bo</span><span class="o">.</span><span class="n">order</span><span class="p">))</span>
            <span class="n">write_prop</span><span class="p">(</span><span class="s1">&#39;flags&#39;</span><span class="p">,</span> <span class="n">bo</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unset_atoms_id</span><span class="p">()</span>


<div class="viewcode-block" id="Molecule.readpdb"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.readpdb">[docs]</a>    <span class="k">def</span> <span class="nf">readpdb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;PDB Reader:</span>

<span class="sd">            The pdb format allows to store more than one geometry of a particular molecule within a single file.</span>
<span class="sd">            In such cases the *geometry* argument can be used to indicate which (in order of appearance in the file) geometry to import.</span>
<span class="sd">            The default is the first one (*geometry* = 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pdb</span> <span class="o">=</span> <span class="n">PDBHandler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">models</span> <span class="o">=</span> <span class="n">pdb</span><span class="o">.</span><span class="n">get_models</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">models</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">FileError</span><span class="p">(</span><span class="s1">&#39;readpdb: There are only </span><span class="si">%i</span><span class="s1"> geometries in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">models</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="n">symbol_columns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">70</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">models</span><span class="p">[</span><span class="n">geometry</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ATOM  &#39;</span><span class="p">,</span><span class="s1">&#39;HETATM&#39;</span><span class="p">]:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">24</span><span class="p">:</span><span class="mi">32</span><span class="p">])</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">32</span><span class="p">:</span><span class="mi">40</span><span class="p">])</span>
                <span class="n">z</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">40</span><span class="p">:</span><span class="mi">48</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">symbol_columns</span><span class="p">:</span>
                    <span class="n">symbol</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">atnum</span> <span class="o">=</span> <span class="n">PT</span><span class="o">.</span><span class="n">get_atomic_number</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">except</span> <span class="n">PTError</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">symbol_columns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="n">FileError</span><span class="p">(</span><span class="s1">&#39;readpdb: Unable to deduce the atomic symbol in the following line:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="n">atnum</span><span class="o">=</span><span class="n">atnum</span><span class="p">,</span><span class="n">coords</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">pdb</span></div>


    <span class="k">def</span> <span class="nf">writepdb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>
        <span class="n">pdb</span> <span class="o">=</span> <span class="n">PDBHandler</span><span class="p">()</span>
        <span class="n">pdb</span><span class="o">.</span><span class="n">add_record</span><span class="p">(</span><span class="n">PDBRecord</span><span class="p">(</span><span class="s1">&#39;HEADER&#39;</span><span class="p">))</span>
        <span class="n">model</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">at</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;ATOM  </span><span class="si">%5i</span><span class="s1">                   </span><span class="si">%8.3f%8.3f%8.3f</span><span class="s1">                      </span><span class="si">%2s</span><span class="s1">  &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">at</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">at</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">at</span><span class="o">.</span><span class="n">z</span><span class="p">,</span><span class="n">at</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
            <span class="n">model</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PDBRecord</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="n">pdb</span><span class="o">.</span><span class="n">add_model</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="n">pdb</span><span class="o">.</span><span class="n">add_record</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">calc_master</span><span class="p">())</span>
        <span class="n">pdb</span><span class="o">.</span><span class="n">add_record</span><span class="p">(</span><span class="n">PDBRecord</span><span class="p">(</span><span class="s1">&#39;END&#39;</span><span class="p">))</span>
        <span class="n">pdb</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>


<div class="viewcode-block" id="Molecule._mol_from_rkf_section"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule._mol_from_rkf_section">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_mol_from_rkf_section</span><span class="p">(</span><span class="n">sectiondict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a |Molecule| instance constructed from the contents of the whole ``.rkf`` file section, supplied as a dictionary returned by :meth:`KFFile.read_section&lt;scm.plams.tools.kftools.KFFile.read_section&gt;`.&quot;&quot;&quot;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">()</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;Coords&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;Coords&#39;</span><span class="p">]),</span><span class="mi">3</span><span class="p">)]</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;AtomSymbols&#39;</span><span class="p">]</span>
        <span class="c1"># If the dictionary was read from memory and not from file, this is already a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="p">:</span>
                <span class="n">symbols</span> <span class="o">=</span> <span class="n">symbols</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">crd</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">symbols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sym</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Gh.&#39;</span><span class="p">):</span>
                <span class="n">isghost</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">sym</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isghost</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">sym</span><span class="p">:</span>
                <span class="n">elsym</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">newatom</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="n">symbol</span><span class="o">=</span><span class="n">elsym</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">crd</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;bohr&#39;</span><span class="p">)</span>
                <span class="n">newatom</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newatom</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="n">symbol</span><span class="o">=</span><span class="n">sym</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">crd</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;bohr&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isghost</span><span class="p">:</span> <span class="n">newatom</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">ghost</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">newatom</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;fromAtoms&#39;</span> <span class="ow">in</span> <span class="n">sectiondict</span> <span class="ow">and</span> <span class="s1">&#39;toAtoms&#39;</span> <span class="ow">in</span> <span class="n">sectiondict</span> <span class="ow">and</span> <span class="s1">&#39;bondOrders&#39;</span> <span class="ow">in</span> <span class="n">sectiondict</span><span class="p">:</span>
            <span class="n">fromAtoms</span> <span class="o">=</span> <span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;fromAtoms&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;fromAtoms&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;fromAtoms&#39;</span><span class="p">]]</span>
            <span class="n">toAtoms</span> <span class="o">=</span> <span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;toAtoms&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;toAtoms&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;toAtoms&#39;</span><span class="p">]]</span>
            <span class="n">bondOrders</span> <span class="o">=</span> <span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;bondOrders&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;bondOrders&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;bondOrders&#39;</span><span class="p">]]</span>

            <span class="k">for</span> <span class="n">fromAt</span><span class="p">,</span> <span class="n">toAt</span><span class="p">,</span> <span class="n">bondOrder</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fromAtoms</span><span class="p">,</span> <span class="n">toAtoms</span><span class="p">,</span> <span class="n">bondOrders</span><span class="p">):</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">fromAt</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="n">toAt</span><span class="p">],</span> <span class="n">bondOrder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;Charge&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;Charge&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;nLatticeVectors&#39;</span> <span class="ow">in</span> <span class="n">sectiondict</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">Units</span><span class="o">.</span><span class="n">convert</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;LatticeVectors&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;LatticeVectors&#39;</span><span class="p">]),</span><span class="mi">3</span><span class="p">)],</span> <span class="s1">&#39;bohr&#39;</span><span class="p">,</span> <span class="s1">&#39;angstrom&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;EngineAtomicInfo&#39;</span> <span class="ow">in</span> <span class="n">sectiondict</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Just one atom: Need to make the list of length 1 explicitly.</span>
                <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;EngineAtomicInfo&#39;</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;EngineAtomicInfo&#39;</span><span class="p">]:</span>
                <span class="c1"># AMS&gt;2020: Separated with C NULL characters.</span>
                <span class="n">suffixes</span> <span class="o">=</span> <span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;EngineAtomicInfo&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># AMS&lt;=2019: Separated with new line characters</span>
                <span class="n">suffixes</span> <span class="o">=</span> <span class="n">sectiondict</span><span class="p">[</span><span class="s1">&#39;EngineAtomicInfo&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">at</span><span class="p">,</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">):</span>
                <span class="n">at</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">suffix</span> <span class="o">=</span> <span class="n">suffix</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">readrkf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s1">&#39;Molecule&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>
        <span class="n">kf</span> <span class="o">=</span> <span class="n">KFFile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">sectiondict</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="n">read_section</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Molecule</span><span class="o">.</span><span class="n">_mol_from_rkf_section</span><span class="p">(</span><span class="n">sectiondict</span><span class="p">)</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span> <span class="n">at</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">bo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span> <span class="n">bo</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span>


<div class="viewcode-block" id="Molecule.readin"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.readin">[docs]</a>    <span class="k">def</span> <span class="nf">readin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a file containing a System block used in AMS driver input files.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">input_parser_available</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Reading from System blocks from AMS input files requires the AMS input parser to be available.&#39;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">scm.input_parser</span> <span class="k">import</span> <span class="n">InputParser</span>
        <span class="kn">from</span> <span class="nn">..interfaces.adfsuite.ams</span> <span class="k">import</span> <span class="n">AMSJob</span>
        <span class="n">sett</span> <span class="o">=</span> <span class="n">Settings</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">InputParser</span><span class="p">()</span> <span class="k">as</span> <span class="n">parser</span><span class="p">:</span>
            <span class="n">sett</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">AMS</span> <span class="o">=</span> <span class="n">Settings</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">_run</span><span class="p">(</span><span class="s1">&#39;ams&#39;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">string_leafs</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;System&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sett</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">AMS</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No System block found in file.&#39;</span><span class="p">)</span>
        <span class="n">sysname</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sysname&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">mols</span> <span class="o">=</span> <span class="n">AMSJob</span><span class="o">.</span><span class="n">settings_to_mol</span><span class="p">(</span><span class="n">sett</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sysname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mols</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;No System block with id &quot;</span><span class="si">{sysname}</span><span class="s1">&quot; found in file.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mols</span><span class="p">[</span><span class="n">sysname</span><span class="p">]</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span> <span class="n">at</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">bo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span> <span class="n">bo</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Molecule.writein"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.writein">[docs]</a>    <span class="k">def</span> <span class="nf">writein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the Molecule instance to a file as a System block from the AMS driver input files.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..interfaces.adfsuite.ams</span> <span class="k">import</span> <span class="n">AMSJob</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">AMSJob</span><span class="p">(</span><span class="n">molecule</span><span class="o">=</span><span class="p">{</span><span class="n">other</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sysname&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">):</span><span class="bp">self</span><span class="p">})</span><span class="o">.</span><span class="n">get_input</span><span class="p">())</span></div>


<div class="viewcode-block" id="Molecule.read"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">inputformat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read molecular coordinates from a file.</span>

<span class="sd">        *filename* should be a string with a path to a file. If *inputformat* is not ``None``, it should be one of supported formats or engines (keys occurring in the class attribute ``_readformat``). Otherwise, the format is deduced from the file extension. For files without an extension the `xyz` format is used.</span>

<span class="sd">        All *other* options are passed to the chosen format reader.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">inputformat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">inputformat</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">extension</span> <span class="k">else</span> <span class="s1">&#39;xyz&#39;</span>
        <span class="k">if</span> <span class="n">inputformat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_readformat</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inputformat</span> <span class="o">==</span> <span class="s1">&#39;rkf&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">readrkf</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readformat</span><span class="p">[</span><span class="n">inputformat</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;read: Unsupported file format &#39;</span><span class="si">{inputformat}</span><span class="s2">&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Molecule.write"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">outputformat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write molecular coordinates to a file.</span>

<span class="sd">        *filename* should be a string with a path to a file. If *outputformat* is not ``None``, it should be one of supported formats or engines (keys occurring in the class attribute ``_writeformat``). Otherwise, the format is deduced from the file extension. For files without an extension the `xyz` format is used.</span>

<span class="sd">        *mode* can be either &#39;w&#39; (overwrites the file if the file exists) or &#39;a&#39; (appends to the file if the file exists).</span>

<span class="sd">        All *other* options are passed to the chosen format writer.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;invalid mode </span><span class="si">{mode}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outputformat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">outputformat</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">extension</span> <span class="k">else</span> <span class="s1">&#39;xyz&#39;</span>
        <span class="k">if</span> <span class="n">outputformat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_writeformat</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_writeformat</span><span class="p">[</span><span class="n">outputformat</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;write: Unsupported file format &#39;</span><span class="si">{outputformat}</span><span class="s2">&#39;&quot;</span><span class="p">)</span></div>

    <span class="c1"># Support for the ASE engine is added if available by interfaces.molecules.ase</span>
    <span class="n">_readformat</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;xyz&#39;</span><span class="p">:</span><span class="n">readxyz</span><span class="p">,</span> <span class="s1">&#39;mol&#39;</span><span class="p">:</span><span class="n">readmol</span><span class="p">,</span> <span class="s1">&#39;mol2&#39;</span><span class="p">:</span><span class="n">readmol2</span><span class="p">,</span> <span class="s1">&#39;pdb&#39;</span><span class="p">:</span><span class="n">readpdb</span><span class="p">,</span> <span class="s1">&#39;rkf&#39;</span><span class="p">:</span><span class="n">readrkf</span><span class="p">}</span>
    <span class="n">_writeformat</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;xyz&#39;</span><span class="p">:</span><span class="n">writexyz</span><span class="p">,</span> <span class="s1">&#39;mol&#39;</span><span class="p">:</span><span class="n">writemol</span><span class="p">,</span> <span class="s1">&#39;mol2&#39;</span><span class="p">:</span><span class="n">writemol2</span><span class="p">,</span> <span class="s1">&#39;pdb&#39;</span><span class="p">:</span> <span class="n">writepdb</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">input_parser_available</span><span class="p">:</span>
        <span class="n">_readformat</span><span class="p">[</span><span class="s1">&#39;in&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">readin</span>
        <span class="n">_writeformat</span><span class="p">[</span><span class="s1">&#39;in&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">writein</span>


<div class="viewcode-block" id="Molecule.add_hatoms"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.add_hatoms">[docs]</a>    <span class="k">def</span> <span class="nf">add_hatoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Molecule&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds missing hydrogen atoms to the current molecule.</span>
<span class="sd">        Returns a new Molecule instance.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; o = Molecule()</span>
<span class="sd">            &gt;&gt;&gt; o.add_atom(Atom(atnum=8))</span>
<span class="sd">            &gt;&gt;&gt; print(o)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         O      0.000000       0.000000       0.000000</span>
<span class="sd">            &gt;&gt;&gt; h2o = o.add_hatoms()</span>
<span class="sd">            &gt;&gt;&gt; print(h2o)</span>
<span class="sd">              Atoms:</span>
<span class="sd">                1         O      0.000000       0.000000       0.000000</span>
<span class="sd">                2         H     -0.109259       0.893161       0.334553</span>
<span class="sd">                3         H      0.327778       0.033891      -0.901672</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">subprocess</span> <span class="k">import</span> <span class="n">Popen</span>
        <span class="kn">from</span> <span class="nn">tempfile</span> <span class="k">import</span> <span class="n">NamedTemporaryFile</span>
        <span class="k">with</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;.xyz&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_in</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writexyz</span><span class="p">(</span><span class="n">f_in</span><span class="p">)</span>
            <span class="n">f_in</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;.xyz&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_out</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;amsprep -t SP -m </span><span class="si">{f_in.name}</span><span class="s1"> -addhatoms -exportcoordinates </span><span class="si">{f_out.name}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
                <span class="n">retmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">f_out</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">retmol</span></div>


<div class="viewcode-block" id="Molecule.rmsd"><a class="viewcode-back" href="../../../../components/mol_api.html#scm.plams.mol.molecule.Molecule.rmsd">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">rmsd</span><span class="p">(</span><span class="n">mol1</span><span class="p">,</span> <span class="n">mol2</span><span class="p">,</span> <span class="n">return_rotmat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses the</span>
<span class="sd">        `Kabsch algorithm &lt;https://en.wikipedia.org/wiki/Kabsch_algorithm&gt;`_ to align and</span>
<span class="sd">        calculate the root-mean-square deviation of two systems&#39; atomic positions.</span>

<span class="sd">        Assumes all elements and their order is the same in both systems, will check this if `check == True`.</span>

<span class="sd">        :Returns:</span>

<span class="sd">        rmsd : float</span>
<span class="sd">            Root-mean-square-deviation of atomic coordinates</span>
<span class="sd">        rotmat : ndarray</span>
<span class="sd">            If `return_rotmat` is `True`, will additionally return the rotation matrix</span>
<span class="sd">            that aligns `mol2` onto `mol1`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">kabsch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotmat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Rotate a set of points `y` such that they are aligned with `x`</span>
<span class="sd">            using the Kabsch algorithm (thanks to Toon for the idea).</span>
<span class="sd">            Same as `scipy.spatial.transform.Rotation.align_vectors`.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">x</span>       <span class="o">-=</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">y</span>       <span class="o">-=</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">covar</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">covar</span><span class="p">)</span>
            <span class="n">det</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">det</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span> <span class="n">Vt</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="p">))</span>
            <span class="n">R</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ji,j,kj&quot;</span><span class="p">,</span> <span class="n">Vt</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
            <span class="n">y</span>        <span class="o">=</span> <span class="n">y</span><span class="nd">@R</span>
            <span class="n">rmsd</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">rmsd</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span> <span class="k">if</span> <span class="n">rotmat</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">rmsd</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol2</span><span class="p">),</span> <span class="s2">&quot;Can only calculate the RMSD of same-sized molecules&quot;</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">nums1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">atnum</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mol1</span><span class="p">])</span>
            <span class="n">nums2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">atnum</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mol2</span><span class="p">])</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">nums1</span> <span class="o">==</span> <span class="n">nums2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="n">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Atoms are not the same (or not in the same order). Use `check==False` if you do not care about this.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">kabsch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mol1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mol2</span><span class="p">),</span> <span class="n">rotmat</span><span class="o">=</span><span class="n">return_rotmat</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Return an array of all atomic numbers in the Molecule. Can also be used to set all numbers at once. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">atnum</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
    
    <span class="nd">@numbers</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Number of elements in array ({len(values)}) does not match the molecule size ({len(self)}).&quot;</span><span class="p">)</span>
        <span class="p">[</span><span class="nb">setattr</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="s1">&#39;atnum&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">at</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)]</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Return an array of all atomic symbols in the Molecule. Can also be used to set all symbols at once. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
    
    <span class="nd">@symbols</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Number of elements in array ({len(values)}) does not match the molecule size ({len(self)}).&quot;</span><span class="p">)</span>
        <span class="p">[</span><span class="nb">setattr</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="s1">&#39;symbol&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">at</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)]</span></div>
</pre></div>

           </div>
          </div>
          <!--STARTNOSOLR-->
<footer>
  

  <hr/> 

<!-- start :: footer -->
		<footer class="site-footer block">
			<div class="container">
				<div class="row">
					<div class="footer-column" >
	<ul>
		<li id="nav_menu-2" class="widget widget_nav_menu "><h3>Application Areas</h3><div class="menu-application-areas-container"><ul id="menu-application-areas" class="menu">
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/batteries/">Batteries &#038; PVs</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/chemical-bonding-analysis/">Bonding Analysis</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/catalysis/">Catalysis</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/heavy-elements/">Heavy Elements</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/inorganic-chemistry/">Inorganic Chemistry</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/pharma/">Life Sciences</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/materials-science/">Materials Science</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/nanotechnology/">Nanotechnology</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/oil-and-gas/">Oil and Gas</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/organic-electronics/">Organic Electronics</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/polymers/">Polymers</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/spectroscopy/">Spectroscopy</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/teaching/">Teaching</a></li>
</ul></div></li>	</ul>
</div><div class="footer-column" >
	<ul>
		<li id="nav_menu-7" class="widget widget_nav_menu "><h3>Products</h3><div class="menu-product-navigation-container"><ul id="menu-product-navigation" class="menu">
<li id="menu-item-40263" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-40263"><a href="https://www.scm.com/product/ams/">AMS Driver</a></li>
<li id="menu-item-7235" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7235"><a href="https://www.scm.com/product/adf/">ADF</a></li>
<li id="menu-item-7236" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7236"><a href="https://www.scm.com/product/band_periodicdft/">BAND</a></li>
<li id="menu-item-7237" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7237"><a href="https://www.scm.com/product/cosmo-rs/">COSMO-RS</a></li>
<li id="menu-item-7238" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7238"><a href="https://www.scm.com/product/dftb/">DFTB</a></li>
<li id="menu-item-7239" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7239"><a href="https://www.scm.com/product/gui/">GUI</a></li>
<li id="menu-item-44383" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-44383"><a href="https://www.scm.com/product/machine-learning-potentials/">MLPotential</a></li>
<li id="menu-item-7240" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7240"><a href="https://www.scm.com/product/mopac/">MOPAC</a></li>
<li id="menu-item-40262" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-40262"><a href="https://www.scm.com/product/plams/">PLAMS</a></li>
<li id="menu-item-43701" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-43701"><a href="https://www.scm.com/product/quantum-espresso/">Quantum ESPRESSO</a></li>
<li id="menu-item-7241" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7241"><a href="https://www.scm.com/product/reaxff/">ReaxFF</a></li></ul></div></li><li id="nav_menu-26" class="widget widget_nav_menu "><div class="menu-licensing-container"><ul id="menu-licensing" class="menu"><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/pricing-licensing/">Pricing &#038; Licensing</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/pricing-licensing/price-quote/">Price Quote</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/pricing-licensing/price-quote/calculate-your-price/">Price Calculator</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/consulting/">Scientific Consulting</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/pricing-licensing/adf-resellers/">Resellers</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/pricing-licensing/scm-license-terms/">License Terms</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/pricing-licensing/ordering-procedure/">Ordering</a></li>
</ul></div></li>	</ul>
</div><div class="footer-column" >
	<ul>
		<li id="nav_menu-6" class="widget widget_nav_menu "><h3>Support</h3><div class="menu-support-navigation-container"><ul id="menu-support-navigation" class="menu"><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/support/">Support Overview</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/support/ams-installation-videos/">Installation</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/support/ams-tutorials-and-manuals/">Documentation</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/doc/Tutorials/GUI_overview/GUI_overview_tutorials.html">GUI Tutorials</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/support/downloads/">Downloads</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/faq/">FAQs</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/adf-discussion-list/">Discussion List</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/support/documentation-previous-versions/release-notes/">Release Notes</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/support/adf-teaching-materials/">Teaching Materials</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/news-agenda/adf-hands-on-workshops/">Workshops</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/news-agenda/web-presentations-by-adf-experts/">Webinars</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/videos-tutorials-and-web-presentations/">Videos</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/brochures/">Brochure</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/amsterdam-modeling-suite/research-papers-citing-adf/">Papers Citing ADF</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/category/highlights/">Literature Highlights</a></li>
</ul></div></li>	</ul>
</div><div class="footer-column" >
	<ul>
		<li id="nav_menu-28" class="widget widget_nav_menu "><h3>About Us</h3><div class="menu-about-us-container"><ul id="menu-about-us" class="menu"><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/contact-us/">Contact Us</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/eu-projects/">EU Projects</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/our-authors/">Contributors</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/our-people/">The SCM Team</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/collaborations/">Collaborations</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/careers/">Careers</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/mission-vision/">Mission &#038; Vision</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/newsletters/">Newsletters</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/category/news/">News</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/news-agenda/">Events</a></li>
</ul></div></li>	</ul>
</div><div class="footer-column" >
	<ul>
			</ul>
</div>				</div>
			</div>
		</footer>
		<footer class="disclaimer-footer">
			<img src="https://www.scm.com/wp-content/themes/scm/images/logos/scm-logo-compact.svg" alt="">
			<nav class="menu-service-navigation-container"><ul id="menu-service-navigation" class="menu-service navbar-nav"><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-73"><a href="https://www.scm.com/copyright/">Copyright</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-72"><a href="https://www.scm.com/terms-of-use/">Terms of Use</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-privacy-policy menu-item-71"><a href="https://www.scm.com/privacy-policy/">Privacy Policy</a></li>
</ul></nav></footer>	
		<!-- end :: footer -->

<!--ENDNOSOLR-->
        </div>
      </div>

    </section>
  </div>
  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'2021.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>

    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NCRWHZZ"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../../_static/language_data.js"></script>
      <script type="text/javascript" src="../../../../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.js"></script>
      <script type="text/javascript" src="../../../../_static/sphinx_tabs/tabs.js"></script>
      <script type="text/javascript" src="../../../../_static/../../MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>