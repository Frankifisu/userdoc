

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
<META name="ROBOTS" content="NOINDEX, NOFOLLOW">
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Vibrational Spectroscopy &mdash; AMS 2021.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/css/theme_tabs.css" type="text/css" />
  
    <link rel="stylesheet" href="_static/panels-bootstrap.min.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="AMS 2021.1 documentation" href="index.html"/>
        <link rel="next" title="Vibrationally resolved electronic spectra" href="Vibrationally_resolved_electronic_spectra.html"/>
        <link rel="prev" title="Gradients, Hessian, Stress tensor, Elasticity" href="Gradients_Stress_Elasticity.html"/> 

  
  <script src="_static/js/jquery.min.js"></script>
  <script src="_static/js/bootstrap.min.js"></script>
  <script src="_static/js/modernizr.min.js"></script>
  <script src="_static/js/app.js"></script>
<script type="text/javascript">
</script>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NCRWHZZ');</script>
<!-- End Google Tag Manager -->

</head>

<body class="wy-body-for-nav" role="document">
  <!--STARTNOSOLR-->
  <header class="site-header navbar-fixed-top compact">
      <nav class="main navbar navbar-default">
        <div class="headerbar_container">
          <a role="button" href="/free-trial/" class="btn btn-sm btn-primary">Free trial</a>
          <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <div class="navbar-brand">
              <a class="logo" href="https://www.scm.com">
                <img class="logo-small" src="https://www.scm.com/wp-content/themes/scm/images/logos/scm-logo-compact.svg" alt="Software for Chemistry &amp; Materials" />
                <img class="logo-full" src="https://www.scm.com/wp-content/themes/scm/images/logos/scm-logo.svg" alt="Software for Chemistry &amp; Materials" />
              </a>
            </div>
          </div>
          <div class="nav-wrapper">
            <div class="collapse navbar-collapse">
              <ul id="menu-primary-navigation" class="nav navbar-nav"><li id="menu-item-40077" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-40077"><a title="Applications" href="https://www.scm.com/applications/">Applications</a></li>
<li id="menu-item-35" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-35"><a title="Products" href="https://www.scm.com/amsterdam-modeling-suite/">Products</a></li>
<li id="menu-item-36" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-36"><a title="Support" href="https://www.scm.com/support/">Support</a></li>
<li id="menu-item-37" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-37"><a title="About us" href="https://www.scm.com/about-us/">About us</a></li>
</ul>                           <span class="search"><a class="menu_search_link" href="https://www.scm.com/search.php"></a><span class="sr-only">Search</span></span>
            </div>
          </div>
        </div>
      </nav>
 </header>
    

   
  <div id="doc-wrapper">
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html">
          

          
            
            <img src="_static/logo.png" class="logo" />
          
          </a>

          
          
  <ul>
      <li class="wy-breadcrumbs-aside">
        
           
           <a class="keyword-spacing" href="keywords.html">Keywords</a>
           
           
           <a href="genindex.html">Index</a>
           
        
      </li>
  </ul>
 
<!--ENDNOSOLR-->
             <!--STARTNOSOLR-->
<div role="search">
  <form id="rtd-search-form" class="wy-form search-docs-form" action="https://www.scm.com/search.php" method="get">
  <div class="input-group">
    <input type="text" name="search" placeholder="Search AMS" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
    <input type="hidden" name="root" value="doctrunk" />


    <input type="hidden" name="cat" value="doc-AMS" />


    <span class="input-group-btn">
			<button type="submit" class="btn btn-primary"><span class="sr-only">Search</span><span class="fa fa-search"></span></button>
		</span>
	</div>
  </form>
</div>
<!--ENDNOSOLR-->
          

          
        </div>
<!--STARTNOSOLR-->
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="General.html">General</a><ul>
<li class="toctree-l2"><a class="reference internal" href="General.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="General.html#what-s-new-in-the-ams-driver">What’s new in the AMS driver?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="General.html#new-in-ams2021-3">New in AMS2021.3</a></li>
<li class="toctree-l3"><a class="reference internal" href="General.html#new-in-ams2021-1">New in AMS2021.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="General.html#new-in-ams2020-1">New in AMS2020.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="General.html#new-in-ams2019-3">New in AMS2019.3</a></li>
<li class="toctree-l3"><a class="reference internal" href="General.html#new-in-ams2019-1">New in AMS2019.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="General.html#motivation-and-progress">Motivation and progress</a></li>
<li class="toctree-l2"><a class="reference internal" href="General.html#input-execution-and-output">Input, execution and output</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Input_Output.html">Input, execution and output</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Input_Output.html#input">Input</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#tasks">Tasks</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#properties">Properties</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#general-remarks-on-input-structure-and-parsing">General remarks on input structure and parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#keys">Keys</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#blocks">Blocks</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#including-an-external-file">Including an external file</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#units">Units</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Input_Output.html#execution">Execution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#shell-script">Shell script</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#interactive-input-file">Interactive input file</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#running-ams-on-compute-clusters">Running AMS on compute clusters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Input_Output.html#output">Output</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#index-13">Results directory</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#logfile-ams-log">Logfile ams.log</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#binary-output-files">Binary output files</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#standard-output">Standard output</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#optimized-geometry-in-xyz-format">Optimized geometry in xyz format</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#ams-environment-variables">AMS environment variables</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Input_Output.html#driver-level-parallelism">Driver level parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="Input_Output.html#python-interface">Python interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="Input_Output.html#pipe-interface">Pipe interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Pipe_protocol.html">AMSPipe protocol specification</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Pipe_protocol.html#low-level-message-encoding">Low-level message encoding</a></li>
<li class="toctree-l4"><a class="reference internal" href="Pipe_protocol.html#return-messages-and-error-handling">Return messages and error handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="Pipe_protocol.html#methods">Methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#ams-as-a-pipe-master">AMS as a pipe master</a></li>
<li class="toctree-l3"><a class="reference internal" href="Input_Output.html#ams-as-a-pipe-worker">AMS as a pipe worker</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="System.html">Geometry, System definition</a><ul>
<li class="toctree-l2"><a class="reference internal" href="System.html#geometry-lattice">Geometry, Lattice</a><ul>
<li class="toctree-l3"><a class="reference internal" href="System.html#modifying-the-geometry">Modifying the geometry</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="System.html#symmetry">Symmetry</a></li>
<li class="toctree-l2"><a class="reference internal" href="System.html#regions">Regions</a></li>
<li class="toctree-l2"><a class="reference internal" href="System.html#charge-atomic-masses-input-bond-orders">Charge, atomic masses, input bond orders</a></li>
<li class="toctree-l2"><a class="reference internal" href="System.html#homogeneous-electric-field-and-multipole-charges">Homogeneous electric field and multipole charges</a></li>
<li class="toctree-l2"><a class="reference internal" href="System.html#load-a-system-from-file">Load a System from file</a></li>
<li class="toctree-l2"><a class="reference internal" href="System.html#atom-attributes">Atom attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="System.html#force-field-related-extensions">Force field related extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="System.html#load-charges-for-a-forcefield-into-regions">Load charges for a forcefield into regions</a></li>
<li class="toctree-l3"><a class="reference internal" href="System.html#load-forcefield-atom-types">Load forcefield atom types</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Tasks/TOC.html">Structure and Reactivity, Molecular Dynamics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Tasks/Single_Point.html">Single point calculations</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tasks/Bond_Energy.html">Bond energy calculations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Bond_Energy.html#ground-state-energy">Ground state energy</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Bond_Energy.html#formation-energy">Formation energy</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Bond_Energy.html#atomization-energies">Atomization energies</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Bond_Energy.html#chemisorption-energies">Chemisorption energies</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Bond_Energy.html#atomic-corrections">Atomic corrections</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Bond_Energy.html#open-shell-systems">Open shell systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Bond_Energy.html#impurities">Impurities</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Tasks/Geometry_Optimization.html">Geometry optimization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Geometry_Optimization.html#constrained-optimization">Constrained optimization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Geometry_Optimization.html#restraints">Restraints</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Geometry_Optimization.html#optimization-under-pressure-external-stress">Optimization under pressure / external stress</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Geometry_Optimization.html#optimization-methods">Optimization methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Geometry_Optimization.html#quasi-newton">Quasi-Newton</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Geometry_Optimization.html#fire">FIRE</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Geometry_Optimization.html#index-17">SCMGO</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Geometry_Optimization.html#limited-memory-bfgs">Limited-memory BFGS</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Geometry_Optimization.html#conjugate-gradients">Conjugate gradients</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Geometry_Optimization.html#troubleshooting">Troubleshooting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Geometry_Optimization.html#failure-to-converge">Failure to converge</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Geometry_Optimization.html#restarting-a-geometry-optimization">Restarting a geometry optimization</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Tasks/Transition_State_Search.html">Transition state search</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tasks/PES_Scan.html">Linear Transit, PES scan</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Scan.html#distance-angle-and-dihedral-angle-coordinates">Distance, angle, and dihedral angle coordinates</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Scan.html#joint-scan-coordinates">Joint scan coordinates</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Scan.html#multidimensional-pes-scan">Multidimensional PES scan</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Scan.html#lattice-scan-coordinates-for-periodic-systems">Lattice scan coordinates for periodic systems</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/PES_Scan.html#isotropic-scaling-of-the-unit-cell-volume-or-area">Isotropic scaling of the unit cell volume or area</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/PES_Scan.html#scaling-of-the-lattice-vector-lengths">Scaling of the lattice vector lengths</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/PES_Scan.html#strain-matrix-in-voigt-notation">Strain matrix in Voigt notation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/PES_Scan.html#scan-arbitrary-lattices">Scan arbitrary lattices</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Scan.html#calculate-properties-for-all-pes-points">Calculate properties for all PES points</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Scan.html#troubleshooting">Troubleshooting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Tasks/NEB.html">Nudged Elastic Band (NEB)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Tasks/NEB.html#input">Input</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/NEB.html#frozen-atom-constraints">Frozen atom constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/NEB.html#optimizations-and-convergence-criteria">Optimizations and convergence criteria</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/NEB.html#output">Output</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/NEB.html#troubleshooting">Troubleshooting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Tasks/IRC.html">Intrinsic Reaction Coordinate (IRC)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Tasks/IRC.html#method-details">Method details</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/IRC.html#input">Input</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/IRC.html#output">Output</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Tasks/Excited_State_Optimizations.html">Excited state optimizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tasks/Molecular_Dynamics.html">Molecular dynamics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#general">General</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#constrained-molecular-dynamics">Constrained molecular dynamics</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#re-starting-a-simulation">(Re-)Starting a simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#thermostats-and-barostats">Thermostats and barostats</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#temperature-and-pressure-regimes">Temperature and pressure regimes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#trajectory-sampling-and-output">Trajectory sampling and output</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#lattice-deformations-volume-regimes">Lattice deformations (volume regimes)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#molecule-gun-adding-molecules-during-simulation">Molecule Gun: adding molecules during simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#removing-molecules-during-simulation">Removing molecules during simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#accelerated-dynamics">Accelerated dynamics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#the-plumed-library-support-in-ams">The PLUMED library support in AMS</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#metadynamics-for-conformer-rotamer-ensemble-sampling-crest-mtd">Metadynamics for Conformer-Rotamer Ensemble Sampling (CREST-MTD)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#collective-variable-driven-hyperdynamics-cvhd">Collective Variable-driven HyperDynamics (CVHD)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#temperature-replica-exchange">Temperature Replica Exchange</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#bond-boost-method">Bond Boost Method</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#force-bias-monte-carlo-fbmc">Force bias Monte Carlo (fbMC)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#non-equilibrium-md-nemd">Non-equilibrium MD (NEMD)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/Molecular_Dynamics.html#t-nemd-for-thermoconductivity-heat-exchange">T-NEMD for thermoconductivity: heat exchange</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Tasks/TrajectoryReplay.html">Trajectory replay</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tasks/GCMC.html">Grand Canonical Monte Carlo (GCMC)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Tasks/GCMC.html#general-info">General info</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/GCMC.html#method-details">Method Details</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/GCMC.html#input">Input</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/GCMC.html#output">Output</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Tasks/PES_Exploration.html">Automated PES Exploration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#job-selection-and-main-options">Job selection and main options</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#results-the-energy-landscape">Results: the “Energy Landscape”</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/PES_Exploration.html#results-on-the-text-output">Results on the text output</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#continue-a-pes-exploration-from-a-previous-calculation">Continue a PES exploration from a previous calculation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#structure-comparison">Structure comparison</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#process-search-job">Process Search job</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/PES_Exploration.html#id2">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/PES_Exploration.html#input-options">Input options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#saddle-search-job">Saddle Search job</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/PES_Exploration.html#id3">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/PES_Exploration.html#id8">Input options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#basin-hopping-job">Basin Hopping job</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/PES_Exploration.html#id9">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/PES_Exploration.html#id11">Input options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#landscape-refinement">Landscape Refinement</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#optimizer">Optimizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#binding-sites">Binding Sites</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/PES_Exploration.html#id12">Input options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/PES_Exploration.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Gradients_Stress_Elasticity.html">Gradients, Hessian, Stress tensor, Elasticity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Gradients_Stress_Elasticity.html#nuclear-gradients">Nuclear gradients</a></li>
<li class="toctree-l2"><a class="reference internal" href="Gradients_Stress_Elasticity.html#index-3">Hessian</a></li>
<li class="toctree-l2"><a class="reference internal" href="Gradients_Stress_Elasticity.html#pes-point-character">PES point character</a></li>
<li class="toctree-l2"><a class="reference internal" href="Gradients_Stress_Elasticity.html#thermodynamics-gas-phase-gibbs-free-energy">Thermodynamics, gas phase Gibbs free energy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Gradients_Stress_Elasticity.html#stress-tensor">Stress tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="Gradients_Stress_Elasticity.html#elastic-tensor">Elastic tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="Gradients_Stress_Elasticity.html#numerical-differentiation-options">Numerical differentiation options</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Vibrational Spectroscopy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#general">General</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#where-are-the-results">Where are the results?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ir-frequencies-and-normal-modes">IR frequencies and normal modes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#all-vibrational-modes">All vibrational Modes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rescanning-imaginary-modes">Rescanning Imaginary modes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#symmetric-displacements">Symmetric Displacements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mobile-block-hessian-mbh">Mobile Block Hessian (MBH)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mode-scanning">Mode Scanning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#theory">Theory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#input">Input</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mode-refinement">Mode Refinement</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">Theory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">Input</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mode-tracking">Mode Tracking</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">Theory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">Input</a></li>
<li class="toctree-l4"><a class="reference internal" href="#input-tracking-methods">Input: Tracking methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#input-selecting-modes">Input: Selecting modes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#input-convergence">Input: Convergence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#selecting-modes">Selecting modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#thermodynamics-ideal-gas">Thermodynamics (ideal gas)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gibbs-free-energy-change-for-a-gas-phase-reaction">Gibbs free energy change for a gas phase reaction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#moments-of-inertia">Moments of inertia</a></li>
<li class="toctree-l3"><a class="reference internal" href="#partial-vibrational-spectra-pvdos">Partial Vibrational Spectra (PVDOS)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#phonons">Phonons</a></li>
<li class="toctree-l2"><a class="reference internal" href="#resonance-raman">(Resonance) Raman</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id19">Raman</a></li>
<li class="toctree-l3"><a class="reference internal" href="#resonance-raman-excited-state-finite-lifetime">Resonance Raman: excited-state finite lifetime</a></li>
<li class="toctree-l3"><a class="reference internal" href="#resonance-raman-vg-fc">Resonance Raman: VG-FC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id22">Theory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id24">Input</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vroa-resonance-vibrational-raman-optical-activity">VROA: (Resonance) vibrational Raman optical activity</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#engine-adf">Engine ADF</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vcd-vibrational-circular-dichroism">VCD: Vibrational Circular Dichroism</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#atomic-polar-tensor-apt-model">Atomic polar tensor (APT) model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#analytical-vcd-in-adf">Analytical VCD in ADF</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Vibrationally_resolved_electronic_spectra.html">Vibrationally resolved electronic spectra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Utilities/FCF_module.html">AH-FC: Adiabatic Hessian Franck-Condon</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Utilities/FCF_module.html#fcf-module-franck-condon-factors">FCF module: Franck-Condon Factors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Utilities/FCF_module.html#theory">Theory</a></li>
<li class="toctree-l4"><a class="reference internal" href="Utilities/FCF_module.html#algorithm">Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="Utilities/FCF_module.html#input">Input</a></li>
<li class="toctree-l4"><a class="reference internal" href="Utilities/FCF_module.html#result-tape61">Result: TAPE61</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/FCF_module.html#fcf-example-absorption-and-fluorescence">FCF example absorption and fluorescence</a></li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/FCF_module.html#fcf-example-phosphorescence">FCF Example phosphorescence</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html">VG-FC: Vertical Gradient Franck-Condon</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#theory">Theory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#theory-vibronic-structure-tracking">Theory: Vibronic-Structure Tracking</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#theory-vibronic-structure-refinement">Theory: Vibronic-Structure Refinement</a></li>
<li class="toctree-l4"><a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#theory-adiabatic-excitation-energy">Theory: Adiabatic excitation energy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#input-vibronic-structure-all-modes">Input: Vibronic-Structure all modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#input-vibronic-structure-tracking">Input: Vibronic-Structure Tracking</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#input-restarting-vst">Input: Restarting VST</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#input-vibronic-structure-refinement">Input: Vibronic-Structure Refinement</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#input-excited-state">Input: Excited State</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#input-producing-the-spectrum">Input: Producing the spectrum</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Properties.html">Dipole moment, Polarizability, Bond orders</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Properties.html#charges-dipole-moment-polarizability">Charges, Dipole Moment, Polarizability</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html#bond-orders-molecule-detection">Bond orders &amp; Molecule detection</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Engines.html">Engines</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Engines.html#index-2">Available engines</a></li>
<li class="toctree-l2"><a class="reference internal" href="Engines.html#summary-of-engine-capabilities">Summary of engine capabilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="Engines.html#external-programs-as-engines">External programs as engines</a></li>
<li class="toctree-l2"><a class="reference internal" href="Engines.html#toy-engines">Toy engines</a></li>
<li class="toctree-l2"><a class="reference internal" href="Engines.html#engine-add-ons">Engine add-ons</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Engines.html#dispersion-corrections">Dispersion corrections</a></li>
<li class="toctree-l3"><a class="reference internal" href="Engines.html#pressure">Pressure</a></li>
<li class="toctree-l3"><a class="reference internal" href="Engines.html#non-isotropic-external-stress">Non-isotropic external stress</a></li>
<li class="toctree-l3"><a class="reference internal" href="Engines.html#atom-energies">Atom energies</a></li>
<li class="toctree-l3"><a class="reference internal" href="Engines.html#restraints">Restraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="Engines.html#wall-potential">Wall potential</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Utilities/TOC.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Utilities/ChemTraYzer.html">ChemTraYzer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Utilities/ChemTraYzer.html#general-information">General information</a></li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/ChemTraYzer.html#graphical-user-interface">Graphical user interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/ChemTraYzer.html#command-line-execution">Command line execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/ChemTraYzer.html#results">Results</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Utilities/ChemTraYzer2.html">ChemTraYzer2 (beta version)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Utilities/ChemTraYzer2.html#using-chemtrayzer2-via-the-graphical-user-interface">Using ChemTraYzer2 via the graphical user interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/ChemTraYzer2.html#minimal-input">Minimal input</a></li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/ChemTraYzer2.html#input-options">Input options</a></li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/ChemTraYzer2.html#ouput">Ouput</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Utilities/TrajectoryAnalysis.html">Trajectory Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Utilities/TrajectoryAnalysis.html#radial-distribution-function-rdf">Radial Distribution Function (RDF)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Utilities/TrajectoryAnalysis.html#description">Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="Utilities/TrajectoryAnalysis.html#options">Options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/TrajectoryAnalysis.html#histogram">Histogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/TrajectoryAnalysis.html#autocorrelation-functions">Autocorrelation Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Utilities/TrajectoryAnalysis.html#id2">Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="Utilities/TrajectoryAnalysis.html#id3">Options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/TrajectoryAnalysis.html#diffusion-coefficient">Diffusion Coefficient</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Utilities/VCDtools.html">VCD Analysis: VCDtools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Utilities/VCDtools.html#general-theory">General Theory</a></li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/VCDtools.html#general-coupled-oscillator-analysis">General Coupled Oscillator Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="Utilities/VCDtools.html#available-options">Available options</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Examples.html#geometry-optimization">Geometry optimization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Examples/GO_formaldehyde_noSCC.html">Example: Simple geometry optimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/2StepGO.html">Example: Two-stage geometry optimization with initial Hessian</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/Diamond_under_pressure.html">Example: Periodic lattice optimization under pressure</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/Diamond_from_pressure.html">Example: Phase Transition Due To External Nonuniform Stress</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/ExternalStress_BN.html">Example: Boron nitride optimization under external stress</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/ExternalStress_graphene.html">Example: Graphene optimization under external stress</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/constraints.html">Example: Constrained optimizations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Examples.html#transition-state-search">Transition state search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Examples/COChainFreqTS.html">Example: TS search starting from initial Hessian</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/PESScan_and_TS_H2_on_Graphene.html">Example: PES scan and TS search for H2 on graphene</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Examples.html#nudged-elastic-band-neb">Nudged Elastic Band (NEB)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Examples/NEB.html">Nudged Elastic Band (NEB) Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Examples/NEB.html#hcn-isomerization-reaction-with-neb">HCN isomerization reaction with NEB</a></li>
<li class="toctree-l4"><a class="reference internal" href="Examples/NEB.html#h2-dissociation-on-graphene">H2 dissociation on graphene</a></li>
<li class="toctree-l4"><a class="reference internal" href="Examples/NEB.html#running-multiple-neb-calculations-using-plams">Running multiple NEB calculations using PLAMS</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Examples.html#intrinsic-reaction-coordinate-irc">Intrinsic reaction coordinate (IRC)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Examples/IRC_HCN.html">Example: IRC for HCN</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/TS_and_IRC_Claisen.html">Example: TS and IRC for Claisen reaction</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Examples.html#pes-scan">PES scan</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Examples/LinearTransit.html">Example: Linear transit</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/PESScan.html">Example: 2D PES scan</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/PESScan_lattice.html">Example: PES scan for lattice degrees of freedom</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Examples.html#pes-exploration">PES Exploration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Examples/BasinHopping_Ar13.html">Example: Basin Hopping for Ar 13 cluster</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/ProcessSearch_alanine.html">Example: PES Exploration, Process Search for alanine with PLAMS</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/BindingSites_O+Pt111.html">Example: PES Exploration, Binding Sites for O on Pt 111</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Examples.html#molecular-dynamics">Molecular dynamics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Examples/MD_hydrogen_longrun.html">Example: Simple MD for H2</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/H2O_nreac.html">Example: MD for a box of water</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/MD_Deformation.html">Example: Lattice deformations in MD</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Examples.html#trajectory-replay">Trajectory replay</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Examples/TrajectoryReplay.html">Example: Trajectory replays for PES scans, NEB and MD calculations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Examples.html#vibrational-analysis">Vibrational analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Examples/VATools_dydrogesterone.html">Example: Mode Refinement</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/VATools_cyclohexanone.html">Example: Mode Tracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/VST_pyrene.html">Example: Vibronic-Structure Tracking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Examples.html#pes-point-properties">PES point properties</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Examples/Phonons_Graphene.html">Example: Phonons for graphene</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/Phonons_Isotopes.html">Example: Phonons with isotopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/Phonons_UserBZPath.html">Example: User-defined Brillouin zone for phonon dispersion</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/ElasticTensor.html">Example: Elastic tensor</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Examples.html#pipe-interface">Pipe interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Examples/Pipe_ASEWorker.html">Example: ASE calculator as a pipe worker</a></li>
<li class="toctree-l3"><a class="reference internal" href="Examples/Pipe_AMSonAMS.html">Example: AMS as a pipe worker</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Appendices.html">Appendices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Appendices.html#extended-xyz-file-format">Extended XYZ file format</a></li>
<li class="toctree-l2"><a class="reference internal" href="Appendices.html#developer-options">Developer options</a></li>
<li class="toctree-l2"><a class="reference internal" href="Appendices.html#symmetry">Symmetry</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Appendices.html#schonfliess-symbols-and-symmetry-labels">Schönfliess symbols and symmetry labels</a></li>
<li class="toctree-l3"><a class="reference internal" href="Appendices.html#molecular-orientation-requirements">Molecular orientation requirements</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Required_citations.html">Required citations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Required_citations.html#general-references">General references</a></li>
<li class="toctree-l2"><a class="reference internal" href="Required_citations.html#feature-references">Feature references</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Required_citations.html#frequencies-ir-intensities-raman-vcd">Frequencies, IR Intensities, Raman, VCD</a></li>
<li class="toctree-l3"><a class="reference internal" href="Required_citations.html#pes-exploration">PES Exploration</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Required_citations.html#external-programs-and-libraries">External programs and Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="keywords.html">Keywords</a><ul>
<li class="toctree-l2"><a class="reference internal" href="keywords.html#links-to-manual-entries">Links to manual entries</a></li>
<li class="toctree-l2"><a class="reference internal" href="keywords.html#summary-of-all-keywords">Summary of all keywords</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">AMS</a>
      </nav>
<!--ENDNOSOLR-->

      
      <div class="wy-nav-content">
        <div class="rst-content">
        <!--STARTNOSOLR-->
<div class="header" role="navigation" aria-label="breadcrumbs navigation">
 
  <ul class="wy-breadcrumbs">
    <li><a href="AMS.html/../../Documentation/index.html">Documentation</a>/</li>
    <li><a href="index.html">AMS</a>/</li>
      
    <li class="orange-text">Vibrational Spectroscopy</li>
  </ul>
  <p>
 
</div>
<!--ENDNOSOLR-->
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="pesvibrations"></span><div class="section" id="vibrational-spectroscopy">
<span id="index-0"></span><h1>Vibrational Spectroscopy<a class="headerlink" href="#vibrational-spectroscopy" title="Permalink to this headline">¶</a></h1>
<div class="section" id="general">
<h2>General<a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h2>
<p>The starting point is the Hessian of the system, being the second derivative of the energy with respect to the atomic coordinates.</p>
<p>The eigenvalues of the Hessian are the frequencies and the eigen vectors are the normal modes.</p>
<p>As the calculation of the full Hessian is very expensive there are several ways to avoid it, so that you only get a part of the full spectrum, or only modes for a region of the system, see <a class="reference internal" href="#irfrequencies"><span class="std std-ref">IR frequencies and normal modes</span></a> section.</p>
<p>A full, partial, or approximate Hessian in itself can be useful for a (Hessian-based) geometry optimization or a transition state search.</p>
<p>Vibrational spectra are obtained by differentiating a property along the normal modes at a (local) minimum of the PES. So for spectra you need to optimize the geometry first, otherwise you get negative frequencies.</p>
<p>The Normal modes and or vibrational spectra can be requested via the <code class="docutils literal notranslate"><span class="pre">Properties</span></code> block</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Properties
   NormalModes Yes/No
   Raman Yes/No
   VROA Yes/No
   VCD Yes/No
   Phonons Yes/No
End
</pre></div>
</div>
<p>When requesting the normal modes, the IR intensities are calculated, as they are very cheap.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="../Tutorials/VibrationalSpectroscopy/index.html">Tutorials on Vibrational Spectroscopy</a></p>
</div>
<div class="section" id="where-are-the-results">
<h3>Where are the results?<a class="headerlink" href="#where-are-the-results" title="Permalink to this headline">¶</a></h3>
<p>Because the results of a vibrational spectroscopy calculation
are tied to a particular point on the
potential energy surface, they are found on the <a class="reference internal" href="Input_Output.html#engine-output-files"><span class="std std-ref">engine output
files</span></a>. Note also that the properties are not always
calculated in every PES point that the AMS driver visits during a calculation.
By default they are only calculated in <em>special</em> PES points, where the
definition of special depends on the <a class="reference internal" href="Tasks/TOC.html#tasks"><span class="std std-ref">task</span></a> AMS is performing: For
a <a class="reference internal" href="Tasks/Geometry_Optimization.html#geometryoptimization"><span class="std std-ref">geometry optimization</span></a> properties would for
example only be calculated at the final, converged geometry. This behavior can
often be modified by keywords special to the particular running task.</p>
<span class="target" id="irfrequencies"></span><span class="target" id="index-1"></span></div>
</div>
<div class="section" id="ir-frequencies-and-normal-modes">
<span id="index-2"></span><h2>IR frequencies and normal modes<a class="headerlink" href="#ir-frequencies-and-normal-modes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="all-vibrational-modes">
<span id="amsfullvibrationalanalysis"></span><h3>All vibrational Modes<a class="headerlink" href="#all-vibrational-modes" title="Permalink to this headline">¶</a></h3>
<p>The calculation of the normal modes of vibration can be requested with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Properties
   NormalModes Yes/No
End
</pre></div>
</div>
<p>Typically used icw with <a class="reference internal" href="Tasks/Single_Point.html#singlepoint"><span class="std std-ref">Task SinglePoint</span></a>, <a class="reference internal" href="Tasks/Geometry_Optimization.html#geometryoptimization"><span class="std std-ref">Task GeometryOptimization</span></a>,
or <a class="reference internal" href="Tasks/Transition_State_Search.html#transitionstatesearch"><span class="std std-ref">Task TransitionStateSearch</span></a>.
In case of geometry optimization or transition state search the
normal modes will only be calculated at the final, converged geometry.</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Properties</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">NormalModes</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Bool</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">No</td>
</tr>
<tr class="field-odd field"><th class="field-name">GUI name:</th><td class="field-body">Frequencies</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Calculate the frequencies and normal modes of vibration, and for molecules also the corresponding IR intensities if the engine supports the calculation of dipole moments.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<p>The molecular normal modes are normally calculated within the harmonic oscillation model.
If the molecule is in its equilibrium conformation, it sits in the lowest point
(at least locally) on the PES. The cross-section of the PES profile close to
this point can then be assumed to be approximately parabolic, such that the
second derivative of the energy w.r.t a nuclear coordinate can be interpreted
as a force constant for the harmonic oscillation of an atom along this
coordinate. Since molecular vibrations in polyatomics involve the simultaneous
displacement of multiple atoms, this harmonic oscillator model can be
generalized to multiple nuclear coordinates. The normal modes and their
frequencies then become eigenvectors and eigenvalues of a force constant
matrix, the Hessian:</p>
<div class="math notranslate nohighlight">
\[H_{ij} = \frac{\partial^2E}{\partial{}R_i\partial{}R_j}\]</div>
<p>The (non-mass-weighted) Hessian is saved in the engine result file as variable
<code class="docutils literal notranslate"><span class="pre">AMSResults%Hessian</span></code>. It is not printed to the text output. The column/row
indices are ordered as: x-component of atom 1, y-component of atom 1,
z-component of atom 1, x-component of atom 2, etc.</p>
<p>Most <a class="reference internal" href="Engines.html#engines"><span class="std std-ref">engines</span></a> cannot calculate the Hessian analytically. The
Hessian is then constructed column-wise through numerical differentiation of
the energy gradients w.r.t. each nuclear coordinate. AMS will set up 2
single-point calculations (1 for the positive displacement, 1 for the negative
displacement), and the requested engine will return the energy gradients at
these displacements. These gradients are calculated analytically for most
engines.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Numerical calculation of the full Hessian requires 6N single points calculation,
which can take a considerable amount of time for large systems.
A mode selective method can be a fast alternative,
see <a class="reference internal" href="#modescanning"><span class="std std-ref">mode scanning</span></a>, <a class="reference internal" href="#moderefinement"><span class="std std-ref">mode refinement</span></a>,
and <a class="reference internal" href="#modetracking"><span class="std std-ref">mode tracking</span></a>.</p>
</div>
<p>When requesting the normal modes calculation, integrated IR intensities are
simultaneously calculated during the finite differentiation steps when
constructing the Hessian (as long as dipole moments are supported by the
engine). These IR intensities are calculated from the numerical dipole
gradients:</p>
<div class="math notranslate nohighlight">
\[I_{IR} = \frac{N\pi}{3c^2}\sum_\alpha\Big(\sum_j\frac{\partial{}\mu_\alpha}{\partial{}R_j^m}Q_{j}^m\Big)^2\]</div>
<p>Where <span class="math notranslate nohighlight">\(\alpha\)</span> denotes the x-,y- and z-components of the dipole moment
<span class="math notranslate nohighlight">\(\mu\)</span>, and <span class="math notranslate nohighlight">\(Q^m\)</span> is the mass-weighted vibrational normal mode.</p>
<p>The resulting IR spectrum can be visualized by opening the engine result file with AMSspectra.
The normal modes of vibration and the IR intensities are saved to the
<a class="reference internal" href="Input_Output.html#engine-output-files"><span class="std std-ref">engine result file</span></a> in the <code class="docutils literal notranslate"><span class="pre">Vibrations</span></code> section.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The calculation of the normal modes of vibration needs to be done the
system’s equilibrium geometry. So one should either run the normal modes
calculation using an already optimized geometry, or combine both steps into
one job by using the <a class="reference internal" href="Tasks/Geometry_Optimization.html#geometryoptimization"><span class="std std-ref">geometry optimization task</span></a>
together with the <code class="docutils literal notranslate"><span class="pre">Properties%NormalModes</span></code> keyword.</p>
</div>
<p>Symmetry labels of the normal modes may be calculated if AMS uses symmetry in the calculation (key <code class="docutils literal notranslate"><span class="pre">UseSymmetry</span></code>).
If symmetry is used, the normal modes are projected against symmetric displacements for each irrep. If that is not successful the symmetry label is ‘MIX’.
Symmetry is only recognized if the geometry is (almost) perfectly symmetric and has a specific orientation in space.
You can use the <code class="docutils literal notranslate"><span class="pre">Symmetrize</span></code> key in the <a class="reference internal" href="System.html#ams-key-system"><span class="std std-ref">System block</span></a> to symmetrize and reorient the molecule.
If the AMSinput GUI module is used, one can click the Symmetrize button (the star) and the GUI will try to symmetrize and reorient the molecule.</p>
<span class="target" id="index-3"></span><div class="section" id="rescanning-imaginary-modes">
<span id="index-4"></span><h4>Rescanning Imaginary modes<a class="headerlink" href="#rescanning-imaginary-modes" title="Permalink to this headline">¶</a></h4>
<p id="automaticmodescanning">The <code class="docutils literal notranslate"><span class="pre">ReScanModes</span></code> keyword can be used to calculate more accurately frequencies of specific modes
after a normal modes calculation. It is identical to the <code class="docutils literal notranslate"><span class="pre">ScanFreq</span></code> option
that was available for older versions of ADF and BAND.
Primarily used to identify spurious imaginary modes, and is on by default for this purpose.
See also the <a class="reference internal" href="#modescanning"><span class="std std-ref">Mode Scanning</span></a> task, which is an extension of this method, but which is not on by default.</p>
<div class="highlight-none notranslate" id="ams-key-normalmodes"><div class="highlight"><pre><span></span>NormalModes
   ReScanModes Yes/No
   ReScanFreqRange float_list
End
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">NormalModes</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ReScanModes</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Bool</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">Yes</td>
</tr>
<tr class="field-odd field"><th class="field-name">GUI name:</th><td class="field-body">Re-scan modes</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Whether or not to scan imaginary modes after normal modes calculation has concluded.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ReScanFreqRange</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float List</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">[-10000000.0, 10.0]</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">cm-1</td>
</tr>
<tr class="field-even field"><th class="field-name">Recurring:</th><td class="field-body">True</td>
</tr>
<tr class="field-odd field"><th class="field-name">GUI name:</th><td class="field-body">Re-scan range</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Specifies a frequency range within which all modes will be scanned. 2 numbers: an upper and a lower bound.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
</div>
</div>
<div class="section" id="symmetric-displacements">
<span id="index-5"></span><h3>Symmetric Displacements<a class="headerlink" href="#symmetric-displacements" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate" id="index-6"><div class="highlight"><pre><span></span><span class="n">NormalModes</span>
   <span class="n">Displacements</span> <span class="n">Symmetric</span>
<span class="n">End</span>
</pre></div>
</div>
<p>Specify <code class="docutils literal notranslate"><span class="pre">Displacements</span> <span class="pre">Symmetric</span></code> to calculate the energy Hessian using finite differences in symmetry-adapted displacements, and the corresponding normal modes.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NormalModes
   SymmetricDisplacements
      Type [All | Infrared | Raman | InfraredAndRaman]
   End
End
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">InfraRed</span></code> or <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">Raman</span></code> is specified then only irreps that result in non-zero intensities for the corresponding spectroscopy will be included in the calculation.
Using this feature may save a lot of time for large symmetric molecules by skipping calculation of normal modes that would not contribute to the spectrum anyway.
If <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">InfraRedAndRaman</span></code> is specified then vibrations that have a non-zero IR or Raman intensity will be calculated.
If <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">All</span></code> is specified then all vibrations will be calculated. For multi-dimensional irreps (such as E and T) only the first component will be computed.
For any component beyond the first, the frequencies and intensities will be copied from the first one.</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">NormalModes</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SymmetricDisplacements</span></code></dt>
<dd><table class="first docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Block</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Configures details of the calculation of the frequencies and normal modes of vibration in symmetric displacements.</td>
</tr>
</tbody>
</table>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Type</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Multiple Choice</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">All</td>
</tr>
<tr class="field-odd field"><th class="field-name">Options:</th><td class="field-body">[All, Infrared, Raman, InfraredAndRaman]</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body">Symm Frequencies</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">For symmetric molecules it is possible to choose only the modes that have non-zero IR or Raman intensity (or either of them) by symmetry.

In order to calculate the Raman intensities the Raman property must be requested.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Specifying <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">Raman</span></code> alone does not trigger calculation of the Raman intensities. In order to calculate the Raman spectrum one should also specify <code class="docutils literal notranslate"><span class="pre">Raman</span> <span class="pre">True</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">Displacements</span> <span class="pre">Symmetric</span></code> will also produce a <em>3N</em>-by-<em>3N</em> Hessian matrix but if the Type key’s argument is not <code class="docutils literal notranslate"><span class="pre">All</span></code> then this matrix will likely have many zero eigenvalues.</p>
</div>
<span class="target" id="mbh"></span><span class="target" id="index-7"></span><span class="target" id="index-8"></span></div>
<div class="section" id="mobile-block-hessian-mbh">
<span id="index-9"></span><h3>Mobile Block Hessian (MBH)<a class="headerlink" href="#mobile-block-hessian-mbh" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NormalModes</span>
   <span class="n">Displacements</span> <span class="n">Block</span>
<span class="n">End</span>
</pre></div>
</div>
<p>Specify <code class="docutils literal notranslate"><span class="pre">Displacements</span> <span class="pre">Block</span></code> for the Block Normal Modes option (also known as <strong>Mobile Block Hessian</strong>, or <strong>MBH</strong> <a class="footnote-reference" href="#ref1" id="id1">[1]</a> <a class="footnote-reference" href="#ref2" id="id2">[2]</a>).
MBH is useful when calculating vibrational frequencies of a small part of a very large system (molecule or cluster).  Calculation of the full spectrum of such a system may be inefficient and is unnecessary if one is interested in one particular part. Besides, it may be difficult to extract normal modes related to the interesting sub-system out of the whole spectrum. Using Block Normal Modes it is possible to treat parts of the system as rigid blocks. Each block will usually have only six frequencies related to its rigid motions compared to 3*N for when each atom of the block is treated separately.</p>
<p>MBH is suitable to calculate frequencies in partially optimized structures. Assume a geometry optimization is performed with the Block key in the Constraints input block [see constrained geometry optimizations]. During the geometry optimization, the shape of the block is not changed. The internal geometry of the block is kept fixed, but the block as a whole can still translate or rotate.</p>
<p>At the end of such a partial geometry optimization, the position and orientation of the block is optimized, thus the total force on the block is zero. However, there might be still some residual forces within a block, since those degrees of freedom were not optimized. A traditional frequency calculation performed on this partially optimized structure might result in non-physical imaginary frequencies without a clear interpretation. Therefore one should use an adapted formulation of normal mode analysis: the Mobile Block Hessian method. MBH does not consider the internal degrees of freedom of the block (on which residual forces) apply, but instead uses the position/orientation of the block as coordinates. In the resulting normal mode eigenvectors, all atoms within the same block move collectively.</p>
<p>Of course, MBH can also be applied on a fully optimized structure.</p>
<p><strong>Accuracy</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NormalModes
   BlockDisplacements
      AngularDisplacement float
      BlockAtoms integer_list
      BlockRegion string
      Parallel
         nCoresPerGroup integer
         nGroups integer
         nNodesPerGroup integer
      End
      RadialDisplacement float
   End
End
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">NormalModes</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">BlockDisplacements</span></code></dt>
<dd><table class="first docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Block</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Configures details of a Block Normal Modes (a.k.a. Mobile Block Hessian, or MBH) calculation.</td>
</tr>
</tbody>
</table>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">AngularDisplacement</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">0.5</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">Degree</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Relative step size for rotational degrees of freedom during Block Normal Modes finite difference calculations. It will be scaled with the characteristic block size.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BlockAtoms</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer List</td>
</tr>
<tr class="field-even field"><th class="field-name">Recurring:</th><td class="field-body">True</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">List of atoms belonging to a block. You can have multiple BlockAtoms.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BlockRegion</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">String</td>
</tr>
<tr class="field-even field"><th class="field-name">Recurring:</th><td class="field-body">True</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">The region to to be considered a block. You can have multiple BlockRegions, also in combination with BlockAtoms.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Parallel</span></code></dt>
<dd><table class="first docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Block</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Configuration for how the individual displacements are calculated in parallel.</td>
</tr>
</tbody>
</table>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">nCoresPerGroup</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Number of cores in each working group.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nGroups</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Total number of processor groups. This is the number of tasks that will be executed in parallel.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nNodesPerGroup</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body">Cores per task</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Number of nodes in each group. This option should only be used on homogeneous compute clusters, where all used compute nodes have the same number of processor cores.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RadialDisplacement</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">0.005</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">Angstrom</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Step size for translational degrees of freedom during Block Normal Modes finite difference calculations.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>The second derivatives of the energy with respect to Cartesian displacements of the free atoms and those with respect to block motions (3 translation plus 3 rotations) are calculated by numerical differentiation of the gradient. The accuracy of the second derivatives is determined by the accuracy of the gradient evaluation and the step size in the numerical differentiation. The <code class="docutils literal notranslate"><span class="pre">RadialDisplacement</span></code> and <code class="docutils literal notranslate"><span class="pre">AngularDisplacement</span></code> parameters can be specified to set the step size for Cartesian displacements (translations) and block rotations respectively. The step size for angles is automatically scaled with the block size.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Blocks should consist of at least 3 atoms (i.e. block of 1 or 2 atoms are not supported).</p>
</div>
<table class="docutils footnote" frame="void" id="ref1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>A. Ghysels, D. Van Neck, V. Van Speybroeck, T. Verstraelen and M. Waroquier, <em>Vibrational Modes in partially optimized molecular systems</em>, <a class="reference external" href="https://doi.org/10.1063/1.2737444">Journal of Chemical Physics 126, 224102 (2007)</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ref2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>A. Ghysels, D. Van Neck and M. Waroquier, <em>Cartesian formulation of the Mobile Block Hessian Approach to vibrational analysis in partially optimized systems</em>, <a class="reference external" href="https://doi.org/10.1063/1.2789429">Journal of Chemical Physics 127, 164108 (2007)</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="mode-scanning">
<span id="modescanning"></span><span id="index-10"></span><h3>Mode Scanning<a class="headerlink" href="#mode-scanning" title="Permalink to this headline">¶</a></h3>
<p>Mode Scanning can be used to obtain more accurate approximations for
properties obtained by numerical differentiation along the vibrational normal modes (frequencies, intensities, Raman, etc.), without changing the modes themselves. Mode Scanning is an extension of the frequency scanning options (<code class="docutils literal notranslate"><span class="pre">ScanFreq</span></code>) that were part of ADF and BAND in
earlier versions of the Amsterdam Modeling Suite. These latter options are still available as the <code class="docutils literal notranslate"><span class="pre">ReScanModes</span></code> keyword in the <code class="docutils literal notranslate"><span class="pre">NormalModes</span></code> block, if these are requested during a calculation.</p>
<ul class="simple">
<li>Primarily used to identify spurious imaginary modes.</li>
<li>Improve numerical accuracy of normal mode properties.</li>
<li>Rescanning modes using a different level of theory.</li>
</ul>
<div class="section" id="theory">
<h4>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h4>
<p>Vibrational normal modes are usually obtained as eigenvectors of the Hessian
matrix. A common problem with this scheme however, is that due to numerical
errors in constructing this Hessian, low-frequency vibrations may be reported
to have imaginary frequencies instead. The Mode Scanning task allows for
re-calculation of the frequency of these modes. The Mode Scanning task does
not change the normal modes itself, only its properties. This Mode Scanning task allows you to confirm
whether reported imaginary frequencies are attributed to transition states or
whether they are simply due to numerical errors.</p>
<p>Given a user-supplied mode <span class="math notranslate nohighlight">\(Q\)</span>, the frequency is calculated from the
force constant:</p>
<div class="math notranslate nohighlight">
\[k = \frac{\partial^2E}{\partial{}^2Q}\]</div>
<div class="math notranslate nohighlight">
\[\nu = \frac{1}{2\pi c}\sqrt{\frac{k}{\mu_r}}\]</div>
<p>This is again done by numerical differentiation of the energy gradients,
requiring AMS to set up 2 single point calculations per selected normal mode.
Integrated IR intensities are also calculated simultaneously (if dipole moments
are supported by the <a class="reference internal" href="Engines.html#engines"><span class="std std-ref">engine</span></a>):</p>
<div class="math notranslate nohighlight">
\[I_{IR} = \frac{N\pi}{3c^2}\sum_\alpha\Big(\frac{\partial{}\mu_\alpha}{\partial{}Q^m}\Big)^2\]</div>
<p>Where the derivative is with respect to the mass-weighted normal mode.</p>
<p>It is also possible to use this method to selectively re-calculate the normal
mode properties for different engine settings. This has two distinct uses:</p>
<ul class="simple">
<li>If the modes were originally generated using a finite difference method, a
different stepsize can be used. For strong vibrations (high frequencies),
large stepsizes may cause inaccuracies due to increasing anharmonic
contributions. For weak vibrations (low frequencies) on the other hand,
stepsizes can often be too small. The displacements associated with these
vibrations are small, which can give incorrect sampling of the PES profile.
This should be compensated for by choosing a larger stepsize. The stepsize
can be set using the <code class="docutils literal notranslate"><span class="pre">Displacement</span></code> key.</li>
<li>Users can also recalculate modes using higher levels of theory. Modes
generated from a full frequency analysis using e.g. DFTB can be recalculated
using e.g. LDA DFT to obtain more realistic integrated IR intensities. The
method used for the single point calculations can be set in the <a class="reference internal" href="Engines.html#engines"><span class="std std-ref">Engine
block</span></a>.</li>
</ul>
</div>
<div class="section" id="input">
<h4>Input<a class="headerlink" href="#input" title="Permalink to this headline">¶</a></h4>
<p>A numerical frequency calculation is performed by requesting the
<code class="docutils literal notranslate"><span class="pre">VibrationalAnalysis</span></code> task with <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">ModeScanning</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Task</span> <span class="n">VibrationalAnalysis</span>
<span class="n">VibrationalAnalysis</span>
   <span class="n">Type</span> <span class="n">ModeScanning</span>
   <span class="n">Displacement</span> <span class="mf">0.001</span>
   <span class="n">NormalModes</span>
     <span class="n">ModeFile</span> <span class="n">adf</span><span class="o">.</span><span class="n">rkf</span>
     <span class="c1"># select all modes with imaginary frequencies</span>
     <span class="n">ModeSelect</span>
        <span class="n">ImFreq</span> <span class="n">true</span>
     <span class="n">End</span>
   <span class="n">End</span>
<span class="n">End</span>
</pre></div>
</div>
<p>The Mode Scanning tasks uses only the <code class="docutils literal notranslate"><span class="pre">NormalModes</span></code> block for its input handling. Here, <code class="docutils literal notranslate"><span class="pre">ModeFile</span></code> specifies the AMS output file containing the normal modes for which you want to calculate the frequencies. The <code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code> block is used to specify which of the modes in this file should be recalculated, since we are often only interested in a select few of them. A more detailed overview of this block is given in the section <cite>Selecting Modes</cite> on the <a class="reference internal" href="#modeselect"><span class="std std-ref">main page</span></a>. Finally, <code class="docutils literal notranslate"><span class="pre">Displacement</span></code> can be used to specify the stepsize (in Bohr) for the finite differences. The stepsize is provided for displacements along the Cartesian normal modes.</p>
<p>The Mode Scanning module is the main driving force for the <a class="reference internal" href="#modetracking"><span class="std std-ref">Mode Tracking</span></a> and <a class="reference internal" href="#moderefinement"><span class="std std-ref">Vibrational Mode Refinement</span></a> tasks,
which provide more advanced options for refining not only the properties of the
modes, but also the modes themselves. Consult the relevant pages for more
information. Alternatively, a simplified version of Mode Scanning is available
which follows the old implementation in ADF and BAND (as the <code class="docutils literal notranslate"><span class="pre">ScanFreq</span></code> option).
This version can be enabled when doing a full frequency analysis by enabling the
<code class="docutils literal notranslate"><span class="pre">Properties%NormalModes</span></code> keyword. See the
<a class="reference internal" href="#amsfullvibrationalanalysis"><span class="std std-ref">Full Analysis</span></a> page for further details.</p>
</div>
</div>
<div class="section" id="mode-refinement">
<span id="moderefinement"></span><span id="index-11"></span><h3>Mode Refinement<a class="headerlink" href="#mode-refinement" title="Permalink to this headline">¶</a></h3>
<p>With this option you can improve the normal modes, by importing previously calculated modes and then applying a more accurate engine, or more accurate settings, typically for only part of the spectrum.
The vibrational Mode Refinement method not only refines frequencies from a previous calculation, but also
tries to correct the vibrational modes themselves.</p>
<ul class="simple">
<li>Refinement of spectral regions requires a sufficient number of
modes in the basis to be accurate.</li>
<li>1-step refinement. No iterative improvement possible. (Unless followed by a
separate Mode Tracking calculation.)</li>
<li>Quality of the results depends on accuracy of the selected guess modes.</li>
</ul>
<p>If we start from e.g. a
semi-empirical method such as in MOPAC, we can get approximations for the
vibrational modes. Mode Refinement then re-calculates part of the Hessian for a
subset of these modes using a more accurate method such as GGA DFT, and updates
the normal modes themselves to fit this more accurate method.  It is intended to
circumvent the expensive calculation of the Hessian if you are only interested
in a (small) part of the full spectrum. This is based on the method in reference
<a class="footnote-reference" href="#ref00" id="id3">[3]</a>.</p>
<p>Because the Mode Refinement method uses linear combinations of the guess modes,
its accuracy depends on the set of modes that is supplied.</p>
<ul class="simple">
<li>If we want to e.g. obtain a mode which includes a C=O stretch, then the
initial set must contain a mode which has this C=O stretch, otherwise this
cannot be included in the refined modes.</li>
<li>If we are refining a region containing many similar modes, e.g. vibrations of
aromatic ring backbones, and we only use part of this spectral region for the
initial set, the set of refined modes will “drift” towards the centre of the
spectral region as a results of mode-mixing. This is again an artefact of
missing character in the modes.</li>
<li>This mode-mixing may result in reduced accuracy for some of the modes, as
this procedure minimizes the total error for all of the modes. Instead of
having a couple of modes with large errors, mode-mixing tends to spread out
the error across multiple normal modes. Adding 1 “bad” mode to the basis can
then negatively affect your results.</li>
<li>The advantage of Mode Refinement over Mode Tracking is the ability to refine entire spectral
regions at once. If we have a good basis, Mode Refinement can be less
computationally expensive than Mode Tracking. If you want to refine larger
sections of the spectrum, Mode Refinement is therefore recommended. If you
only want to calculate a select few modes, use Mode Tracking to avoid basis
dependence and to assure accuracy of the obtained modes.</li>
<li>For characteristic peaks, Mode Tracking shows very good convergence, and will
thus be cheaper to use than Mode Refinement. For (semi-)degenerate modes
however, Mode Refinement works better due to the poor tracking performance
for these modes.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference external" href="../Tutorials/VibrationalSpectroscopy/ModeRefinement.html">GUI tutorial</a> on Mode Refinement.</p>
</div>
<div class="section" id="id4">
<h4>Theory<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>We are going to start from a set of normal modes <span class="math notranslate nohighlight">\(b\)</span>, obtained from e.g.
a semi-empirical or force-field method. First, this task runs the
<a class="reference internal" href="#modescanning"><span class="std std-ref">numerical frequency</span></a> calculation for all selected normal
modes, but this time using an ab initio method such as DFT. During the finite
difference steps, we also calculate the projection of the Hessian onto the
normal modes:</p>
<div class="math notranslate nohighlight">
\[\sigma_i = H^m \cdot b_i^m = \frac{\partial{}^{2}E}{\partial{}R_i^{m}\partial{}b^m}\]</div>
<p>This term is calculated through finite differences on the analytical gradients
of the electronic energy along the mass-weighted normal modes <span class="math notranslate nohighlight">\(b^m\)</span>. The
index <span class="math notranslate nohighlight">\(i\)</span> denotes the <span class="math notranslate nohighlight">\(3N\)</span> nuclear coordinates. These projections
are then used to construct a Rayleigh matrix:</p>
<div class="math notranslate nohighlight">
\[\tilde{H}^m = {B^m}^T \cdot H^m \cdot B^m = {B^m}^T \cdot \Sigma\]</div>
<p>Here, <span class="math notranslate nohighlight">\(B^m\)</span> and <span class="math notranslate nohighlight">\(\Sigma\)</span> are matrices containing the <span class="math notranslate nohighlight">\(b^m\)</span>
and <span class="math notranslate nohighlight">\(\sigma\)</span> vectors. The eigenvectors of <span class="math notranslate nohighlight">\(\tilde{H}^m\)</span> give us the
coefficient series for linear combinations of the normal modes <span class="math notranslate nohighlight">\(b^m\)</span> such
that we obtain a new set of modes <span class="math notranslate nohighlight">\(q\)</span>:</p>
<div class="math notranslate nohighlight">
\[q^m = \sum_k c_k \cdot b_k^m\]</div>
<p>These modes <span class="math notranslate nohighlight">\(q\)</span> are the closest approximation to the DFT-modes that we
could obtain from a linear combination of the approximate modes <span class="math notranslate nohighlight">\(b\)</span>. In
other words: the approximate modes <span class="math notranslate nohighlight">\(b\)</span> are used as a basis for finding
the modes from a more sophisticated theory.</p>
</div>
<div class="section" id="id5">
<h4>Input<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>This method inherently features a trade-off:</p>
<ul class="simple">
<li>The computational benefit comes from only performing the finite difference
calculations for the selected modes. By only selecting a small set of modes
that we are interested in, we minimize computational expense.</li>
<li>The more modes we select, the larger the basis for constructing the refined
modes. Running for a larger number of modes yields better results. (In the
extreme case, running for all 3N modes equates to constructing the full
Hessian.)</li>
</ul>
<p>In practice, Mode Refinement requires you to select a reasonable
portion of the spectrum to get accurate results. Specifically, you should
select all modes in a region of the spectrum which look similar. Ring
structures for instance often feature broad frequency regions with many ring
distortions. Even if you are only interested in a couple of these, you should
still select all modes in this region, to assure sufficient basis size.
Vibrational modes involving ring substituents can however be omitted, which is
where we save computation time.</p>
<p>If you are interested only in IR-active vibrations, you could further minimize
the basis by only selecting the approximate modes which are IR-active (since
adding the non-active modes to the linear expansion does not affect the
IR-intensity of the refined modes). Do note that if the semi-empirical method
used for calculating the approximate modes yields poor approximations for the
dipole gradients, it may be safer to include also modes with very low IR
intensity. This is because their low IR-activity may have only been due to the
low accuracy of the approximate method.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">A <a class="reference external" href="../Tutorials/VibrationalSpectroscopy/ModeRefinement.html">tutorial</a> showing this basis
representability.</p>
</div>
<p>A Mode Refinement calculation is set up by requesting the <code class="docutils literal notranslate"><span class="pre">VibrationalAnalysis</span></code>
task with the Type <code class="docutils literal notranslate"><span class="pre">ModeRefinement</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Task</span> <span class="n">VibrationalAnalysis</span>
<span class="n">VibrationalAnalysis</span>
   <span class="n">Type</span> <span class="n">ModeRefinement</span>
   <span class="n">Displacement</span> <span class="mf">0.001</span>
   <span class="n">NormalModes</span>
     <span class="n">ModeFile</span> <span class="n">adf</span><span class="o">.</span><span class="n">rkf</span>
     <span class="n">ModeSelect</span>
        <span class="o">...</span>
     <span class="n">End</span>
     <span class="n">ScanModes</span> <span class="n">true</span>
   <span class="n">End</span>
<span class="n">End</span>
</pre></div>
</div>
<p>The details of the calculation are specified in the <code class="docutils literal notranslate"><span class="pre">NormalModes</span></code> block.
Here, <code class="docutils literal notranslate"><span class="pre">ModeFile</span></code> specifies the AMS output file containing the normal modes
for which you want to calculate the frequencies. The <code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code> block is
used to specify which of the modes in this file will be selected for
refinement. A more detailed overview of this block is given in the section
<cite>Selecting modes</cite> on the <a class="reference internal" href="#modeselect"><span class="std std-ref">main page</span></a>. Finally,
<code class="docutils literal notranslate"><span class="pre">Displacement</span></code> can be used to specify the stepsize (in Bohr) for the finite
differences. The stepsize is provided for displacements along the Cartesian
normal modes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ScanModes</span></code> key in the <code class="docutils literal notranslate"><span class="pre">NormalModes</span></code> block can be used to
automatically run a <a class="reference internal" href="#modescanning"><span class="std std-ref">numerical frequencies</span></a> calculation on
the new modes <span class="math notranslate nohighlight">\(q\)</span>. Mode Refinement uses a linear combination of modes and
properties, all obtained through finite differences. These results may still
contain some minor errors due to the accumulation of numerical errors from the
linear expansion, or stepsize issues in the numerical frequency calculations.
While commonly not necessary, it is possible to run an additional numerical
refinement calculation on the new modes to minimize these errors.  Only in
exceptional cases will these errors be significant. Running this additional
refinement step is therefore only necessary if you need complete certainty that
the results are accurate.</p>
</div>
</div>
<div class="section" id="mode-tracking">
<span id="modetracking"></span><span id="index-12"></span><h3>Mode Tracking<a class="headerlink" href="#mode-tracking" title="Permalink to this headline">¶</a></h3>
<p>The Mode Tracking task is an interface for mode- and intensity-tracking
methods, adapted from the MoViPac suite <a class="footnote-reference" href="#ref01" id="id6">[4]</a>-
<a class="footnote-reference" href="#ref02" id="id7">[5]</a>. These methods can be used to obtain select normal
modes, without having to calculate the entire vibrational spectrum. It does
this through an iterative procedure.</p>
<ul class="simple">
<li>Calculations are conducted for each mode separately. Converges fastest for
characteristic (non-highly degenerate) modes.</li>
<li>Iterative approximation to the true modes. Guaranteed to give the correct
normal modes if the procedure converges.</li>
<li>Will not necessarily reproduce the entire spectrum as multiple guess modes
can converge to the same normal mode.</li>
</ul>
<p>Mode Tracking uses information about the known parts of the
Hessian to expand its basis iteratively:</p>
<ul class="simple">
<li>Missing C-O stretch character can thus be recovered in this procedure, and
there is no basis dependency.</li>
<li>For large regions with similar modes however, it is possible that multiple
guess modes converge to the same normal mode. Running mode tracking for all
modes in this region might not reproduce all unique normal modes.</li>
<li>The advantage of Mode Refinement over Mode Tracking is the ability to refine entire spectral
regions at once. If we have a good basis, Mode Refinement can be less
computationally expensive than Mode Tracking. If you want to refine larger
sections of the spectrum, Mode Refinement is therefore recommended. If you
only want to calculate a select few modes, use Mode Tracking to avoid basis
dependence and to assure accuracy of the obtained modes.</li>
<li>For characteristic peaks, Mode Tracking shows very good convergence, and will
thus be cheaper to use than Mode Refinement. For (semi-)degenerate modes
however, Mode Refinement works better due to the poor tracking performance
for these modes.</li>
</ul>
<p>Mode Tracking starts with a <a class="reference internal" href="#modescanning"><span class="std std-ref">numerical frequency</span></a>
calculation, which refines the initial guess <span class="math notranslate nohighlight">\(b^m\)</span> for the selected mode.
The error of this mode with respect to the true Hessian eigenvector is
calculated. This error is used in a (Jacobi-)Davidson algorithm to generate an
additional mode. In subsequent iterations, we use these modes as approximations
to the true normal modes. In this way, the error of the mode is minimized
iteratively, yielding a closer approximation to true normal modes. This is how
Mode Tracking differs from the Mode Refinement methods, in that it guarantees
that the obtained modes are correct (assuming the procedure has converged).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference external" href="../Tutorials/VibrationalSpectroscopy/ModeTracking.html">GUI tutorial</a> on Mode Tracking.</p>
</div>
<div class="section" id="id8">
<h4>Theory<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>During the numerical frequency calculation, we obtain also the projection of
the Hessian onto this mode:</p>
<div class="math notranslate nohighlight">
\[\sigma_i = H^m \cdot b_i^m = \frac{\partial{}^{2}E}{\partial{}R_i^{m}\partial{}b^m}\]</div>
<p>This term is calculated through finite differences on the analytical gradients
of the electronic energy along the mass-weighted normal modes <span class="math notranslate nohighlight">\(q^m\)</span>. The
index <span class="math notranslate nohighlight">\(i\)</span> denotes the <span class="math notranslate nohighlight">\(3N\)</span> nuclear coordinates. From this
projection a Rayleigh matrix is generated:</p>
<div class="math notranslate nohighlight">
\[\tilde{H}^m = {B^m}^T \cdot \Sigma\]</div>
<p>Here, <span class="math notranslate nohighlight">\(B^m\)</span> and <span class="math notranslate nohighlight">\(\Sigma\)</span> are matrices containing the <span class="math notranslate nohighlight">\(b^m\)</span>
and <span class="math notranslate nohighlight">\(\sigma\)</span> vectors for all foregoing iterations. During each iteration
<span class="math notranslate nohighlight">\(k\)</span>, if we have not converged, we generate an updated guess vector
<span class="math notranslate nohighlight">\(b_k^m\)</span>, and so the number of vectors in the matrices above is equal to
the number of iterations <span class="math notranslate nohighlight">\(k\)</span>. The eigenvectors of <span class="math notranslate nohighlight">\(\tilde{H}^m\)</span>
give us the coefficient series for linear combinations of the guess modes
<span class="math notranslate nohighlight">\(b^m\)</span> such that we obtain approximations for the true normal modes:</p>
<div class="math notranslate nohighlight">
\[Q^m = \sum_k c_k \cdot b_k^m\]</div>
<p>Each iteration, we expand the vector basis <span class="math notranslate nohighlight">\(B^m\)</span>, which allows this
series expansion to come closer to the true normal modes each time. We can also
calculate the error of this mode with respect to how close it is to being an
eigenvalue of the real Hessian:</p>
<div class="math notranslate nohighlight">
\[r = \sum_k c_k \cdot \Big[\sigma_k - \lambda \cdot b_k\Big]\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\lambda\)</span> is the corresponding eigenvalue of <span class="math notranslate nohighlight">\(\tilde{H}^m\)</span>.
<span class="math notranslate nohighlight">\(r\)</span> is the residual vector, giving the error for each vector element. It
should be zero if the mode is an exact eigenvector of the true Hessian.</p>
<p>Since <span class="math notranslate nohighlight">\(\tilde{H}^m\)</span> may give multiple eigenvectors, several approximate
modes will be generated during those iterations. Out of these, 1 mode is
identified as the mode of interest according to the specified <a class="reference internal" href="#trackingmethod"><span class="std std-ref">tracking
method</span></a>. If the residual of this mode has been minimized
sufficiently, the procedure has converged. If not, we generate a new guess
vector <span class="math notranslate nohighlight">\(b_k^m\)</span>. There are 2 algorithms for generating this new guess, set
by <code class="docutils literal notranslate"><span class="pre">UpdateMethod</span></code> in the <code class="docutils literal notranslate"><span class="pre">ModeTracking</span></code> block:</p>
<div class="section" id="davidson-method">
<h5>Davidson method<a class="headerlink" href="#davidson-method" title="Permalink to this headline">¶</a></h5>
<p>The Davidson method uses a pre-conditioner <span class="math notranslate nohighlight">\(D\)</span> to generate a new guess
mode from the residual vector of the mode selected by the tracking method:</p>
<div class="math notranslate nohighlight">
\[b_k^m = D^{-1} \cdot r\]</div>
<p>This preconditioner is constructed from an approximation of the Hessian:</p>
<div class="math notranslate nohighlight">
\[D = H_A - \lambda \cdot I\]</div>
<p>The Davidson method works reasonably well, but can have trouble converging if
the approximate modes or the Hessian are too accurate. This results as the new
vectors that are generated do not necessarily extend the span of the basis.
<a class="footnote-reference" href="#ref03" id="id9">[6]</a></p>
</div>
<div class="section" id="vdvorst-sleijpen-jacobi-davidson">
<h5>vdVorst-Sleijpen-Jacobi-Davidson<a class="headerlink" href="#vdvorst-sleijpen-jacobi-davidson" title="Permalink to this headline">¶</a></h5>
<p>This variant of the Jacobi-Davidson scheme from Sleijpen &amp; vdVorst
<a class="footnote-reference" href="#ref03" id="id10">[6]</a> automatically makes the new guess vector orthogonal
to the normal mode selected by the tracking method:</p>
<div class="math notranslate nohighlight">
\[b_k^m = \Big(\frac{Q^{m}D^{-1}r}{Q^{m}D^{-1}Q^m}\Big)D^{-1}Q^m - D^{-1}r\]</div>
<p>The new vector is therefore guaranteed to extend the span of the basis as much
as possible, and thus also eliminates the aforementioned issue with the
Davidson method. In general, it is therefore recommended to use this
Jacobi-Davidson method since it is found to converge faster, and be more
reliable, as a result of yielding better guess modes.</p>
</div>
</div>
<div class="section" id="id11">
<h4>Input<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Task</span> <span class="n">VibrationalAnalysis</span>
<span class="n">VibrationalAnalysis</span>
   <span class="n">Type</span> <span class="n">ModeTracking</span>
   <span class="o">...</span>
   <span class="n">ModeTracking</span>
      <span class="n">HessianGuess</span> <span class="p">[</span><span class="n">Unit</span> <span class="o">|</span> <span class="n">File</span> <span class="o">|</span> <span class="n">UFF</span> <span class="o">|</span> <span class="n">Inline</span><span class="p">]</span>
      <span class="n">HessianInline</span> <span class="c1"># Non-standard block. See details.</span>
         <span class="o">...</span>
      <span class="n">End</span>
      <span class="n">HessianPath</span> <span class="n">string</span>
      <span class="n">UpdateMethod</span> <span class="p">[</span><span class="n">JD</span> <span class="o">|</span> <span class="n">D</span> <span class="o">|</span> <span class="n">I</span><span class="p">]</span>
      <span class="n">MaxIterations</span> <span class="n">integer</span>
      <span class="o">...</span>
      <span class="n">GramSchmidt</span> <span class="p">[</span><span class="kc">True</span> <span class="o">|</span> <span class="kc">False</span><span class="p">]</span>
      <span class="n">GramSchmidtIterations</span> <span class="n">integer</span>
      <span class="n">GramSchmidtTolerance</span> <span class="nb">float</span>
   <span class="n">End</span>
<span class="n">End</span>
</pre></div>
</div>
<p>There are 4 methods to obtain the approximate Hessian <span class="math notranslate nohighlight">\(H_A\)</span>, used by both
update methods. They are set by <code class="docutils literal notranslate"><span class="pre">HessianGuess</span></code>:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">HessianGuess</span> <span class="pre">[Unit</span> <span class="pre">|</span> <span class="pre">File</span> <span class="pre">|</span> <span class="pre">UFF</span> <span class="pre">|</span> <span class="pre">Inline]</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">UFF</span></code></dt>
<dd>is the default, which generates the approximate Hessian using UFF.
While this Hessian may not yield the correct modes by itself, it produces
good results as a preconditioner since it correctly represents the molecular
structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">File</span></code></dt>
<dd>will read the Hessian from an AMS output file, which can be
specified in <code class="docutils literal notranslate"><span class="pre">HessianPath</span></code>. Using a Hessian from a more advanced method
will generally yield better results for the Jacobi-Davidson method. The
Davidson method will however experience difficulties with convergence as the
Hessian becomes too accurate. <a class="footnote-reference" href="#ref03" id="id12">[6]</a></dd>
<dt><code class="docutils literal notranslate"><span class="pre">Inline</span></code></dt>
<dd><p class="first">will read a Hessian specified in the input file, in the <code class="docutils literal notranslate"><span class="pre">HessianInline</span></code> block.
This allows you to use Hessians generated in external programs:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Task</span> <span class="n">VibrationalAnalysis</span>
<span class="n">VibrationalAnalysis</span>
   <span class="n">Type</span> <span class="n">ModeTracking</span>
   <span class="n">ModeTracking</span>
     <span class="n">HessianGuess</span> <span class="n">Inline</span>
     <span class="c1"># Approximate Hessian for H2O: 3 x nAtoms = 9 so 9x9 Hessian</span>
     <span class="n">HessianInline</span>
         <span class="mf">0.62088786</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>  <span class="o">-</span><span class="mf">0.31044393</span>   <span class="mf">0.00000000</span>  <span class="o">-</span><span class="mf">0.21902068</span>  <span class="o">-</span><span class="mf">0.31044393</span>   <span class="mf">0.00000000</span>   <span class="mf">0.21902068</span>
         <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>
         <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.32143213</span>  <span class="o">-</span><span class="mf">0.15284008</span>   <span class="mf">0.00000000</span>  <span class="o">-</span><span class="mf">0.16071607</span>   <span class="mf">0.15284008</span>   <span class="mf">0.00000000</span>  <span class="o">-</span><span class="mf">0.16071607</span>
        <span class="o">-</span><span class="mf">0.31044393</span>   <span class="mf">0.00000000</span>  <span class="o">-</span><span class="mf">0.15284008</span>   <span class="mf">0.33598889</span>   <span class="mf">0.00000000</span>   <span class="mf">0.18593038</span>  <span class="o">-</span><span class="mf">0.02554496</span>   <span class="mf">0.00000000</span>  <span class="o">-</span><span class="mf">0.03309030</span>
         <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>
        <span class="o">-</span><span class="mf">0.21902068</span>   <span class="mf">0.00000000</span>  <span class="o">-</span><span class="mf">0.16071607</span>   <span class="mf">0.18593038</span>   <span class="mf">0.00000000</span>   <span class="mf">0.15761846</span>   <span class="mf">0.03309030</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00309761</span>
        <span class="o">-</span><span class="mf">0.31044393</span>   <span class="mf">0.00000000</span>   <span class="mf">0.15284008</span>  <span class="o">-</span><span class="mf">0.02554496</span>   <span class="mf">0.00000000</span>   <span class="mf">0.03309030</span>   <span class="mf">0.33598889</span>   <span class="mf">0.00000000</span>  <span class="o">-</span><span class="mf">0.18593038</span>
         <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>
         <span class="mf">0.21902068</span>   <span class="mf">0.00000000</span>  <span class="o">-</span><span class="mf">0.16071607</span>  <span class="o">-</span><span class="mf">0.03309030</span>   <span class="mf">0.00000000</span>   <span class="mf">0.00309761</span>  <span class="o">-</span><span class="mf">0.18593038</span>   <span class="mf">0.00000000</span>   <span class="mf">0.15761846</span>
     <span class="n">End</span>
   <span class="n">End</span>
<span class="n">End</span>
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Unit</span></code></dt>
<dd>uses the unit matrix. This is evidently not a good approximation for
the Hessian, and is not intended to be used for proper Mode Tracking runs.
However: using a poor approximation for the Hessian can result in basis
vectors being generated that we would not obtain otherwise. Running Mode
Tracking with this option can allow you to “probe” the vector space to obtain
guesses for normal modes, which can be used as starting points for proper
Mode Tracking calculations. It is however generally recommended to instead do
e.g. a DFTB or UFF run if your goal is to obtain guess modes.</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UpdateMethod</span> <span class="pre">[JD</span> <span class="pre">|</span> <span class="pre">D</span> <span class="pre">|</span> <span class="pre">I]</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">JD</span></code></dt>
<dd>vdVorst-Sleijpen variant of Jacobi-Davidson (Mode tracking default).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">D</span></code></dt>
<dd>Davidson</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I</span></code></dt>
<dd>No preconditioner (VST default). This is not recommended for typical mode tracking applications,
but is useful for a variation of mode tracking, <a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#vibronicstructuretracking"><span class="std std-ref">Vibronic-Structure Tracking</span></a>.</dd>
</dl>
</dd>
</dl>
<p>In later iterations, the basis <span class="math notranslate nohighlight">\(B^m\)</span> will become larger. In order to
improve the guess modes even further, an iterative Gram-Schmidt procedure is
used to orthogonalize the new guess mode to the existing basis. An iterative
procedure is necessary to account for numerical noise.</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">GramSchmidt</span> <span class="pre">[True</span> <span class="pre">|</span> <span class="pre">False]</span></code></dt>
<dd>Expert key. Sets whether to perform this Gram-Schmidt orthogonalization
step. It is <code class="docutils literal notranslate"><span class="pre">True</span></code> by default.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GramSchmidtTolerance</span> <span class="pre">float</span></code></dt>
<dd>Expert key. Sets the absolute tolerance for orthogonality of the
basis. It is evaluated with respect to the norm of the overlap vector between
the new guess mode and the basis of the previous iteration <span class="math notranslate nohighlight">\(||{b_k^m}^T B^m||\)</span>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GramSchmidtIterations</span></code></dt>
<dd>Expert key. Sets the maximum number of allowed iterations during the Gram-Schmidt procedure.</dd>
</dl>
<p>The default settings for the Gram-Schmidt procedure should work for almost all systems.</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">MaxIterations</span> <span class="pre">integer</span></code></dt>
<dd>Finally, the Mode Tracking input block contains the <code class="docutils literal notranslate"><span class="pre">MaxIterations</span></code> key.
It sets the maximum allowed number of iterations that the Mode
Tracking calculation may go through. If this number is reached, the
calculation will stop even if convergence was not achieved. If no value is
supplied, a default of <span class="math notranslate nohighlight">\(3N/2\)</span> will be used. This is approximately the
maximum number of iterations where the procedure remains computationally
competitive with the construction of the full Hessian.</dd>
</dl>
<div class="section" id="additional-input-parameters">
<h5>Additional input parameters<a class="headerlink" href="#additional-input-parameters" title="Permalink to this headline">¶</a></h5>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Task</span> <span class="n">VibrationalAnalysis</span>
<span class="n">VibrationalAnalysis</span>
   <span class="n">Type</span> <span class="n">ModeTracking</span>
   <span class="n">Displacement</span> <span class="nb">float</span>
   <span class="o">...</span>
   <span class="n">NormalModes</span>
      <span class="n">ScanModes</span> <span class="p">[</span><span class="kc">True</span> <span class="o">|</span> <span class="kc">False</span><span class="p">]</span>
      <span class="o">...</span>
   <span class="n">End</span>
<span class="n">End</span>
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Displacement</span> <span class="pre">float</span></code></dt>
<dd>is the displacement stepsize (in Bohr) that is used for
calculating frequencies, IR intensities and the Hessian projections through
finite differences. The stepsize is provided for displacements along the
Cartesian normal modes.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ScanModes</span> <span class="pre">[True</span> <span class="pre">|</span> <span class="pre">False]</span></code></dt>
<dd>key (False by default) in the <code class="docutils literal notranslate"><span class="pre">NormalModes</span></code> vibrational analysis sub-block
can be used to automatically run a <a class="reference internal" href="#modescanning"><span class="std std-ref">numerical frequencies</span></a>
calculation on the new modes <span class="math notranslate nohighlight">\(Q\)</span> after the Mode Tracking calculation
has finished. Ritz vectors are obtained here as linear combinations of the
guess modes, which in turn follow from finite difference calculations. This
makes it possible for numerical errors to accumulate in the normal modes.
Only in exceptional cases will these errors be significant, and running this
additional refinement step is therefore only necessary if you need complete
certainty that the results are accurate.</dd>
</dl>
</div>
</div>
<div class="section" id="input-tracking-methods">
<span id="trackingmethod"></span><h4>Input: Tracking methods<a class="headerlink" href="#input-tracking-methods" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">TrackingMethod</span></code> parameter allows you to select what property of the
normal modes you want to track. At the end of each iteration, we obtain a set
of approximate normal modes. The tracking method identifies which of these
modes fits best for some criterion, and either returns this mode as the
calculation result, or, if convergence was not achieved, uses it to generating
a new basis mode for the next iteration. In general these methods are
distinguished in 3 categories:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Task</span> <span class="n">VibrationalAnalysis</span>
<span class="n">VibrationalAnalysis</span>
   <span class="n">Type</span> <span class="n">ModeTracking</span>
   <span class="n">ModeTracking</span>
      <span class="n">TrackingMethod</span> <span class="p">[</span><span class="n">OverlapInitial</span><span class="p">,</span> <span class="n">DifferenceInitial</span><span class="p">,</span> <span class="n">FreqInitial</span><span class="p">,</span> <span class="n">IRInitial</span><span class="p">,</span>
                      <span class="n">OverlapPrevious</span><span class="p">,</span> <span class="n">DifferencePrevious</span><span class="p">,</span> <span class="n">FreqPrevious</span><span class="p">,</span> <span class="n">IRPrevious</span><span class="p">,</span>
                      <span class="n">HighestFreq</span><span class="p">,</span> <span class="n">HighestIR</span><span class="p">,</span> <span class="n">LowestFreq</span><span class="p">,</span> <span class="n">LowestResidual</span><span class="p">]</span>
      <span class="o">...</span>
   <span class="n">End</span>
<span class="n">End</span>
</pre></div>
</div>
<div class="section" id="id13">
<h5>Mode Tracking<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h5>
<p>The original tracking methods focus on obtaining as accurate as possible a
normal mode for the system. This class of tracking methods focuses either on
accuracy of the mode, or obtaining modes with particular vibrational character:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TrackingMethod</span> <span class="pre">[OverlapInitial,</span> <span class="pre">DifferenceInitial,</span> <span class="pre">FreqInitial,</span> <span class="pre">OverlapPrevious,</span> <span class="pre">DifferencePrevious,</span> <span class="pre">FreqPrevious,</span> <span class="pre">HighestFreq,</span> <span class="pre">LowestFreq,</span> <span class="pre">LowestResidual]</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">OverlapInitial</span></code></dt>
<dd>is the default tracking method. Here, we choose the mode
which resembles most closely the guess mode that was initially supplied
<span class="math notranslate nohighlight">\(b_1^m\)</span>. This is done by choosing the mode which has the greatest
overlap with the initial guess vector. This method allows us to direct the
optimization towards modes that e.g. involve particular atoms or include
particular bending/stretching vibrations.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">OverlapPrevious</span></code></dt>
<dd>instead chooses the mode which resembles closest the
approximate mode of the previous iteration <span class="math notranslate nohighlight">\(Q_k^m\)</span>. This procedure
allows a bit more flexibility in the optimization. Since we essentially
“forget” about earlier iterations, this procedure allows the optimization to
correct errors in the initial guess. (It is possible for instance that the
initial guess included 2 different bond stretches which do not mutually occur
in the true modes. This method will then converge quicker to a mode involving
only 1 of these stretches, whereas <code class="docutils literal notranslate"><span class="pre">OverlapInitial</span></code> will take a much larger
number of iterations to achieve this, if it does so at all.) Do note that
this means that the final mode that you obtain does not necessarily represent
the mode you initially supplied.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DifferenceInitial</span></code></dt>
<dd>works the same as <code class="docutils literal notranslate"><span class="pre">OverlapInitial</span></code>, except that it
chooses the mode which has the smallest norm for the difference vector
between the initial mode and the approximate normal modes of this iteration.
The use of the difference vector prioritizes deviations in the dominant parts
of the vibrational character. E.g. if a mode consists primarily of a CO
stretch, plus some minor vibrations in a carbon backbone, it may be desired
to prioritize getting the correct force constant for the dominant CO stretch.
This is achieved using these difference vector methods. In general, overlap
methods still work well in these situations, and the use of difference
methods should only be necessary in extreme cases.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DifferencePrevious</span></code></dt>
<dd>is also the same as <code class="docutils literal notranslate"><span class="pre">DifferenceInitial</span></code> except for
the use of the difference vector norm as the selection criterion.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FreqInitial</span></code></dt>
<dd>chooses the mode with the frequency closest to that of the
initial guess. This allows us to direct the tracking towards modes in a
particular frequency region of the spectrum. Note that convergence for these
frequency-based methods is slightly slower since the character of the mode
itself is not included in the selection criteria, allowing for larger
differences in the modes between iterations.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FreqPrevious</span></code></dt>
<dd>is similar to <code class="docutils literal notranslate"><span class="pre">FreqInitial</span></code> except that we choose the mode
with the frequency closest to that of the previous iteration. This allows the
optimization more freedom to move away from the frequency region of the
initial guess, and thus allows to correct somewhat for poor initial guesses.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HighestFreq</span></code></dt>
<dd>chooses the mode with the highest frequency. This method can
be used if it is desired to track particular characteristic high-frequency
vibrations.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LowestResidual</span></code></dt>
<dd>chooses the mode which has the smallest norm for the
residual vector (see the ‘Convergence’ section below.) This method only
focuses on obtain the most accurate mode, regardless of vibrational
character or where it lies in the spectrum. This method should generally only
be used as a pre-conditioner if you have very little information on what the
normal modes should look like. (Since it is basically a non-directed
optimization.) This method will then try and find the normal mode closest to
your guess. The approximate normal mode obtained this way will most likely
not have converged yet, but should give you an indication of what the normal
modes may look like. You can use these modes to refine your initial guess,
and then do a new Mode Tracking run using any of the other tracking
parameters to obtain the desired mode. Although this strategy is possible, it
is generally recommended to use an approximate method to get an initial guess
for the normal modes instead (as shown in the <a class="reference internal" href="Examples.html#examples"><span class="std std-ref">examples</span></a>).</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="intensity-tracking">
<span id="index-13"></span><h5>Intensity Tracking<a class="headerlink" href="#intensity-tracking" title="Permalink to this headline">¶</a></h5>
<p>This class of methods focuses on tracking modes based on their intensity in
e.g. the infrared spectrum, rather than focusing on getting a mode with a
particular type of vibration.</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">TrackingMethod</span> <span class="pre">[IRInitial,</span> <span class="pre">IRPrevious,</span> <span class="pre">HighestIR]</span></code></dt>
<dd><p class="first"><code class="docutils literal notranslate"><span class="pre">IRInitial</span></code>
chooses the mode with the IR intensity closest to that of the
initial guess. This constrains the optimization to modes which are IR active,
a property that may be lost when using mode tracking update methods.</p>
<p><code class="docutils literal notranslate"><span class="pre">IRPrevious</span></code>
similarly chooses the mode with the IR intensity closest to
that of the previous iteration. This allows the method some more flexibility
in varying the intensity of the vibration, and thus works better if the
initial guess is not that good.</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">HighestIR</span></code>
chooses the mode with the highest IR intensity. This option can
be used to find the modes associated with sharp peaks in the IR spectrum.</p>
</dd>
</dl>
<p>With Intensity Tracking, we essentially add an additional requirement to the
modes: they must have a particular IR intensity. This constrained search has
different convergence characteristics than conventional mode tracking, which
you should take into account when setting up the mode tracking calculations.</p>
<ul class="simple">
<li>The majority of modes will have near-zero IR intensity. If we use a near-zero
IR intensity mode as our initial guess, and request <code class="docutils literal notranslate"><span class="pre">IRIntitial</span></code> or
<code class="docutils literal notranslate"><span class="pre">IRPrevious</span></code>, then we could be tracking any of one of these. Conversely,
convergence behavior will be poor since the generated basis modes are
essentially random. If you are trying to obtain a high IR-intensity mode, use
an IR-susceptible mode.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In our conventional work-flow, we recommend starting mode tracking or
refinement calculations from a set of approximate normal modes obtained from
a semi-empirical or force-field method. Note however, that these method often
do not produce accurate IR intensities. When selecting the initial guess
mode, do <strong>not</strong> use the <code class="docutils literal notranslate"><span class="pre">IRRange</span></code> or related options in the <code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code>
block. This will cause you to miss vibrations which were incorrectly labeled
with low IR intensity, or vice versa. Instead, rely on chemical intuition to
identify the modes which contain commonly IR active vibrational components
(such as C-O or N-H stretches). You can use AMSspectra in the GUI to
visualize the vibrational modes, to help you in this process.</p>
</div>
<ul class="simple">
<li>To allow the intensity tracking procedure to converge faster, it is
recommended to use the <code class="docutils literal notranslate"><span class="pre">IRPrevious</span></code> tag instead of the <code class="docutils literal notranslate"><span class="pre">IRInitial</span></code> tag.
As discussed earlier, the former allows more flexibility in the optimization
procedure, which counters the rigidity imposed by the intensity constraint.
Intensity tracking methods often need this additional flexibility in
generating guess modes to converge to the desired modes.</li>
<li><strong>Poor Initial Guesses:</strong> During each iteration, we still use the mode
tracking methods to generate new basis modes. These basis modes try to expand
the span of the basis with respect to the vibrational character of the modes.
Note that this expansion does not guarantee that we will expand the basis
specifically in the sub-span of IR-susceptible vibrations. If the initial
guess for intensity tracking is correct, we already start our search in the
sub-span vicinity of the normal modes. Basis expansion is then more efficient
and there is a high chance that new guess modes sample the IR characteristic
vibrations. For intensity tracking it is therefore discouraged to use poor
initial guess modes.</li>
<li><code class="docutils literal notranslate"><span class="pre">HighestIR</span></code> is considered a “pure” intensity tracking method, in that it is
used specifically to target characteristics of the IR spectrum irrespective
of the underlying vibrational character. Consequently, the normal mode
character can vary a lot between iterations. In order to assure that the
procedure converges to the desired modes, it is recommended to use
sufficiently strict tolerances (see the <cite>Convergence</cite> section). If the
tolerances are too lax, the program may consider the modes to be “good
enough” based on residual minimization, even though there may be another mode
with a higher IR intensity. For this reason it is generally recommended to
use <code class="docutils literal notranslate"><span class="pre">ToleranceForNorm</span></code> values 1 order of magnitude lower than the default,
or around <code class="docutils literal notranslate"><span class="pre">0.00005</span></code>.</li>
</ul>
</div>
</div>
<div class="section" id="input-selecting-modes">
<h4>Input: Selecting modes<a class="headerlink" href="#input-selecting-modes" title="Permalink to this headline">¶</a></h4>
<p>It is possible to track multiple modes in a single Mode Tracking calculation.
The Mode Tracking task will then run the Mode Tracking algorithm for each mode
in order.</p>
<p>The initial guess for the mode which will be tracked can be supplied in several
ways. This is governed by <code class="docutils literal notranslate"><span class="pre">ModeInputFormat</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Task</span> <span class="n">VibrationalAnalysis</span>
<span class="n">VibrationalAnalysis</span>
   <span class="n">Type</span> <span class="n">ModeTracking</span>
   <span class="n">NormalModes</span>
      <span class="n">ModeInputFormat</span> <span class="p">[</span><span class="n">File</span> <span class="o">|</span> <span class="n">Inline</span> <span class="o">|</span> <span class="n">Hessian</span><span class="p">]</span>
      <span class="n">ModeFile</span> <span class="n">string</span>
      <span class="n">ModeInline</span> <span class="c1"># Non-standard block. See details.</span>
         <span class="o">...</span>
      <span class="n">End</span>
      <span class="n">ModeSelect</span>
         <span class="o">...</span>
      <span class="n">End</span>
      <span class="n">MassWeighInlineMode</span> <span class="p">[</span><span class="kc">True</span> <span class="o">|</span> <span class="kc">False</span><span class="p">]</span>
  <span class="n">End</span>
<span class="n">End</span>
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ModeInputFormat</span> <span class="pre">[File</span> <span class="pre">|</span> <span class="pre">Inline</span> <span class="pre">|</span> <span class="pre">Hessian]</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Inline</span></code></dt>
<dd><p class="first">will make the module read the mode from the input file. If this
option is selected, you can supply the mode in the <code class="docutils literal notranslate"><span class="pre">ModeInline</span></code> block. It is
possible to supply multiple modes by adding additional <code class="docutils literal notranslate"><span class="pre">ModeInline</span></code> blocks.
The modes are given with one line for the x,y,z-displacement per atom, and in
the same order, as the <code class="docutils literal notranslate"><span class="pre">Atoms</span></code> block in <code class="docutils literal notranslate"><span class="pre">System</span></code>:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ModeTracking</span>
   <span class="n">TrackedMode</span> <span class="n">Inline</span>
   <span class="n">ModeInline</span>
       <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="o">-</span><span class="mf">0.03815965</span>
      <span class="o">-</span><span class="mf">0.18888544</span>   <span class="mf">0.00000000</span>    <span class="mf">0.30281066</span>
       <span class="mf">0.18888544</span>   <span class="mf">0.00000000</span>    <span class="mf">0.30281066</span>
   <span class="n">End</span>
   <span class="n">ModeInline</span>
       <span class="mf">0.00000000</span>   <span class="mf">0.00000000</span>   <span class="o">-</span><span class="mf">0.02243153</span>
       <span class="mf">0.32132452</span>   <span class="mf">0.00000000</span>    <span class="mf">0.17800237</span>
      <span class="o">-</span><span class="mf">0.32132452</span>   <span class="mf">0.00000000</span>    <span class="mf">0.17800237</span>
   <span class="n">End</span>
   <span class="o">...</span>
<span class="n">End</span>
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">File</span></code></dt>
<dd>will make the module read modes from an AMS or engine output file,
specified by <code class="docutils literal notranslate"><span class="pre">ModePath</span></code>. Modes generated using DFTB can be read from the
<code class="docutils literal notranslate"><span class="pre">dftb.rkf</span></code> file and optimised using Mode Tracking for example. When this
option is selected, all the vibrational modes present in the file are read
first. The <code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code> block then specifies for which of these modes you
want to perform the Mode Tracking calculation.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Hessian</span></code></dt>
<dd>will generate modes as the eigenvectors of the approximate Hessian
selected for the preconditioner in <code class="docutils literal notranslate"><span class="pre">HessianGuess</span></code>. This also allows modes to
be generated for Hessians obtained from external programs.  <code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code>
specifies which of the generated vibrational modes are selected for Mode
Tracking.</dd>
</dl>
</dd>
</dl>
<ul class="simple">
<li>Settings for the <code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code> block are discussed on the <a class="reference internal" href="#modeselect"><span class="std std-ref">main page</span></a>.</li>
</ul>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">MassWeighInlineMode</span> <span class="pre">[True</span> <span class="pre">|</span> <span class="pre">False]</span></code></dt>
<dd>decides whether the initial guess modes need to be
mass-weighted (default True). As discussed above, Mode Tracking uses mass-weighted normal
modes. In most cases, the normal modes are given in regular Cartesian
coordinates however. By setting <code class="docutils literal notranslate"><span class="pre">MassWeighInlineMode</span> <span class="pre">true</span></code>, these Cartesian
modes are converted into mass-weighted modes by the program. If you supply a
mass-weighted mode through the <code class="docutils literal notranslate"><span class="pre">ModeInline</span></code> block however, you do not need
the program to do the mass-weighing, and you should set <code class="docutils literal notranslate"><span class="pre">MassWeighInlineMode</span>
<span class="pre">false</span></code>.</dd>
</dl>
</div>
<div class="section" id="input-convergence">
<h4>Input: Convergence<a class="headerlink" href="#input-convergence" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Task</span> <span class="n">VibrationalAnalysis</span>
<span class="n">VibrationalAnalysis</span>
   <span class="n">Type</span> <span class="n">ModeTracking</span>
   <span class="n">ModeTracking</span>
      <span class="n">ToleranceForNorm</span> <span class="nb">float</span>
      <span class="n">ToleranceForResidual</span> <span class="nb">float</span>
      <span class="n">ToleranceForBasis</span> <span class="nb">float</span>
   <span class="n">End</span>
<span class="n">End</span>
</pre></div>
</div>
<p>In order to guide the Mode Tracking procedure, several convergence criteria
are used:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ToleranceForNorm</span> <span class="pre">float</span></code></dt>
<dd>is the absolute tolerance for convergence of the norm of
the residual vector. The residual vector is a vector containing the error for
each element of the normal mode, and we use the norm as a measure for the
total error. If the total error is smaller than this threshold, we consider
the mode to be a true normal mode and we stop iterating. Since the value of
this norm depends on the length of the residual vector hence the number of
atoms in the system, this tolerance is scaled internally to the number of
atoms. <code class="docutils literal notranslate"><span class="pre">0.0005</span></code> is used as a default value for which most systems will
converge to reasonably accurate modes in not too many iterations. If you want
a more accurate approximation, you can decrease this value by e.g. 1 order of
magnitude. (Consider running using the default settings, and reading the norm
at convergence from the logfile. The new norm can be chosen to be lower than
this value to ‘force’ the method into another iteration.)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ToleranceForResidual</span> <span class="pre">float</span></code></dt>
<dd>is the absolute tolerance for the maximum component
of the residual vector. Particularly in larger systems, where the vibration
may be dominated by a small number of atoms, the error associated with the
vibration of the majority of atoms may be small (the scaled residual norm
will be small). The error for the atoms involved in the vibration may be
comparatively large then, which is why we also check convergence for the
maximum component of the error. Note that both the norm and this max. error
are checked simultaneously. By varying strictness of the criteria for the
norm and the max. error separately, you can prioritize either the total
vibration or more localized character.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ToleranceForBasis</span> <span class="pre">float</span></code></dt>
<dd>checks that the basis mode generated in the previous
iteration, through the (Jacobi-)Davidson method, contributes to the
approximate normal mode. Since the approximate mode is taken as a linear
combination of the basis modes, its linear expansion coefficient must be
larger than this tolerance.</dd>
</dl>
<p>The iterative procedure is stopped in one of two cases. Either both the residual
criteria are achieved, in which case the mode is deemed to be converged and
the program exits normally. Alternatively, the basis criterion is met in which
case a warning is broadcast indicating that the desired level of accuracy of the
mode may not have been reachd yet, but the basis has stopped expanding.
The default values for these parameters should be applicable for most
cases, but can be adjusted if needed. If stricter criteria are required, it is
recommended to adjust both <code class="docutils literal notranslate"><span class="pre">ToleranceForNorm</span></code> and <code class="docutils literal notranslate"><span class="pre">ToleranceForResidual</span></code>.</p>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="ref00" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>T.Q. Teodoro, M.A.J. Koenis, S.E. Galembeck, V.P. Nicu, W.J. Buma, L. Visscher, <em>A frequency range selection method for vibrational spectra</em>, <a class="reference external" href="https://doi.org/10.1021/acs.jpclett.8b02963">J. Phys. Chem. Lett., 9 (23), 6878 (2018)</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ref01" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td>T. Weymuth, M.P. Haag, K. Kiewisch, S. Luber, S. Schenk, C.R. Jacob, C. Herrmann, J. Neugebauer, M. Reiher, <em>MoViPac: Vibrational Spectroscopy with a Robust Meta-Program for Massively Parallel Standard Inverse Calculations</em>, <a class="reference external" href="https://doi.org/10.1002/jcc.23036">Journal of Computational Chemistry 33, 2186 (2012)</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ref02" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[5]</a></td><td>S. Luber, J.Neugebauer, M. Reiher, <em>Intensity tracking for theoretical infrared spectroscopy of large molecules</em>, <a class="reference external" href="https://doi.org/10.1063/1.3069834">Journal of Chemical Physics 130, 064105 (2009)</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ref03" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><em>(<a class="fn-backref" href="#id9">1</a>, <a class="fn-backref" href="#id10">2</a>, <a class="fn-backref" href="#id12">3</a>)</em> G.L.G. Sleijpen, H.A. van der Vorst, <em>A Jacobi-Davidson Iteration Method for Linear Eigenvalue Problems</em>, <a class="reference external" href="https://doi.org/10.1137/S0895479894270427">SIAM Journal on Matrix Analysis and Applications 17, 401 (1996)</a></td></tr>
</tbody>
</table>
<span class="target" id="modeselect"></span></div>
</div>
<div class="section" id="selecting-modes">
<span id="index-14"></span><h3>Selecting modes<a class="headerlink" href="#selecting-modes" title="Permalink to this headline">¶</a></h3>
<p>Mode Scanning, Mode Refinement and Mode Tracking as well as VG-FC Vibronic-Structure,
VG-FC Vibronic-Structure Refinement and VG-FC resonance Raman all require a set of normal
modes to operate on. For Mode Scanning these are the modes that you want to
calculate the properties of, for Mode Refinement these modes form the basis
modes, and for Mode Tracking these are the initial guess modes. For the VG-FC based
methods these modes are the modes responsible for the vibronic coupling to the
electronic excitation (in VG-FC Vibronic-Structure Refinement they are refined first).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">VG-FC Vibronic-Structure Tracking does not require any normal modes and as such does not
support the <code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code> (nor does it support the <code class="docutils literal notranslate"><span class="pre">NormalModes</span></code> block for that matter).</p>
</div>
<p>These methods provide options to load a large set of modes, after which the
program will filter out the modes of interest. This is done according to the
keys set in the <code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code> block.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code> block is part of the <code class="docutils literal notranslate"><span class="pre">NormalModes</span></code> block of the Vibrational
Analysis input. All Vibrational Analysis methods share this block, with the
exception of VG-FC Vibronic-Structure Tracking. The methods for obtaining the
set of modes that we will filter can differ per method. Particularly Mode Tracking
features a lot of additional options, and the vibronic variants feature
more specialized options.</p>
</div>
<p>Below is an overview of all the available options for the <code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code> block
as they appear in the basic vibrational analysis tools. The vibronic variants
are discussed in more detail on their respective documentation pages.</p>
<p>The options below are not mutually exclusive.</p>
<div class="highlight-none notranslate" id="ams-key-vibrationalanalysis-normalmodes-modeselect"><div class="highlight"><pre><span></span>ModeSelect
   DisplacementBound float
   FreqAndIRRange float_list
   FreqRange float_list
   Full Yes/No
   HighFreq integer
   HighIR integer
   IRRange float_list
   ImFreq Yes/No
   LargestDisplacement integer
   LowFreq integer
   LowFreqNoIm integer
   LowIR integer
   ModeNumber integer_list
End
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DisplacementBound</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Vibronic Structure (Refinement), Resonance Raman: Select all modes with a dimensionless oscillator displacement greater than the specified value.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FreqAndIRRange</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float List</td>
</tr>
<tr class="field-even field"><th class="field-name">Unit:</th><td class="field-body">cm-1 and km/mol</td>
</tr>
<tr class="field-odd field"><th class="field-name">Recurring:</th><td class="field-body">True</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Specifies a combined frequency and IR intensity range within which all modes will be selected. First 2 numbers are the frequency range, last 2 numbers are the IR intensity range.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FreqRange</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float List</td>
</tr>
<tr class="field-even field"><th class="field-name">Unit:</th><td class="field-body">cm-1</td>
</tr>
<tr class="field-odd field"><th class="field-name">Recurring:</th><td class="field-body">True</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Specifies a frequency range within which all modes will be selected. 2 numbers: an upper and a lower bound. Calculating all modes higher than some frequency can be achieved by making the upper bound very large.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Full</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Bool</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">No</td>
</tr>
<tr class="field-odd field"><th class="field-name">GUI name:</th><td class="field-body">All modes</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Select all modes. This only make sense for Mode Scanning calculations.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HighFreq</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body"># High frequencies</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Select the N modes with the highest frequencies.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HighIR</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body"># High IR</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Select the N modes with the largest IR intensities.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IRRange</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float List</td>
</tr>
<tr class="field-even field"><th class="field-name">Unit:</th><td class="field-body">km/mol</td>
</tr>
<tr class="field-odd field"><th class="field-name">Recurring:</th><td class="field-body">True</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Specifies an IR intensity range within which all modes will be selected. 2 numbers: an upper and a lower bound.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ImFreq</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Bool</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">No</td>
</tr>
<tr class="field-odd field"><th class="field-name">GUI name:</th><td class="field-body">All imaginary frequencies</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Select all modes with imaginary frequencies.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LargestDisplacement</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Vibronic Structure (Refinement), Resonance Raman: Select the N modes with the largest VG-FC displacement.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LowFreq</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body"># Low frequencies</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Select the N modes with the lowest frequencies. Includes imaginary modes which are recorded with negative frequencies.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LowFreqNoIm</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body"># Low positive frequencies</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Select the N modes with the lowest non-negative frequencies. Imaginary modes have negative frequencies and are thus omitted here.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LowIR</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body"># Low IR</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Select the N modes with the smallest IR intensities.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ModeNumber</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer List</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body">Mode numbers</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Indices of the modes to select.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<span class="target" id="thermodynamics"></span><span class="target" id="index-15"></span><span class="target" id="index-16"></span><span class="target" id="index-17"></span><span class="target" id="index-18"></span><span class="target" id="index-19"></span><span class="target" id="index-20"></span></div>
<div class="section" id="thermodynamics-ideal-gas">
<span id="index-21"></span><h3>Thermodynamics (ideal gas)<a class="headerlink" href="#thermodynamics-ideal-gas" title="Permalink to this headline">¶</a></h3>
<p>The following thermodynamic properties are calculated by default whenever normal modes are computed: entropy, internal energy, constant volume heat capacity, enthalpy and Gibbs free energy. Translational, rotational and vibrational contributions are calculated for entropy, internal energy and constant volume heat capacity.</p>
<p>The results are written to the output file (section: “Statistical Thermal Analysis”) and to the engine binary results file (section: “Thermodynamics”).</p>
<p>The thermodynamic properties are computed assuming an ideal gas, and electronic contributions are ignored. The latter is a serious omission if the electronic configuration is (almost) degenerate, but the effect is small whenever the energy difference with the next state is large compared to the vibrational frequencies.
The thermal analysis is based on the temperature dependent partition function. The energy of a (non-linear) molecule is (if the energy is measured from the zero-point energy)</p>
<div class="math notranslate nohighlight">
\[\frac{E}{NkT} = \frac{3}{2} + \frac{3}{2} + \sum_j^{3N-6} \left( \frac{h \nu_j}{2kT} + \frac{h \nu_j}{kT (e^{h \nu_j /(kT)}-1)}    \right) - \frac{D}{kT}\]</div>
<p>The summation is over all harmonic <span class="math notranslate nohighlight">\(\nu_j\)</span>, <span class="math notranslate nohighlight">\(h\)</span> is Planck’s constant and <span class="math notranslate nohighlight">\(D\)</span> is the dissociation energy</p>
<div class="math notranslate nohighlight">
\[D = D_0 + \sum_j \frac{h \nu_j}{2}\]</div>
<p>Contributions from low (less than 20 1/cm) frequencies to entropy, heat capacity and internal energy are excluded from the total values, but they are listed separately (so the user can add them if they wish).</p>
<p>As an alternative to outright excluding low-frequency contributions, a correction scheme is available that is based on interpolating between harmonic oscillator and free rotor values <a class="footnote-reference" href="#ref-free-rotor-correction1" id="id14">[7]</a> <a class="footnote-reference" href="#ref-free-rotor-correction2" id="id15">[8]</a> (Li/Head-Gordon and Grimme). It can greatly reduce the impact of the inaccuracies of the harmonic oscillator model on thermodynamic properties at these low frequencies. The scheme corrects vibrational contributions to entropies, internal energies and constant volume heat capacities. This correction is applied automatically and its results are printed separately (in the text output, the corrected terms are marked with the symbol <code class="docutils literal notranslate"><span class="pre">(c)</span></code>). When applied, the correction considers all real frequencies, including those less than 20 1/cm.</p>
<p>The interpolation for a corrected thermodynamic property <span class="math notranslate nohighlight">\(f\)</span> at pressure <span class="math notranslate nohighlight">\(p\)</span> and temperature <span class="math notranslate nohighlight">\(T\)</span> in terms of harmonic oscillator terms <span class="math notranslate nohighlight">\(f_{HO}\)</span>, free rotor terms <span class="math notranslate nohighlight">\(f_{FR}\)</span>, and interpolator terms <span class="math notranslate nohighlight">\(x\)</span> for each harmonic oscillator frequency <span class="math notranslate nohighlight">\(\nu_j\)</span> is:</p>
<div class="math notranslate nohighlight">
\[f \left( p, T \right) = \sum_j x \left( \nu_j \right) \cdot f_{HO} \left( p, T, \nu_j \right) + \left( 1 - x \left( \nu_j \right) \right) \cdot f_{FR} \left( p, T, \nu_j \right)\]</div>
<div class="math notranslate nohighlight">
\[x \left( \nu_j \right) = \frac{1}{1+\left(\frac{\nu_0}{\nu_j}\right)^\alpha}\]</div>
<p>Where <span class="math notranslate nohighlight">\(\alpha\)</span> is an arbitrary exponent and <span class="math notranslate nohighlight">\(\nu_0\)</span> is the harmonic oscillator frequency around which <span class="math notranslate nohighlight">\(x\)</span> interpolates, with <span class="math notranslate nohighlight">\(x=0.5\)</span> when <span class="math notranslate nohighlight">\(\nu_j=\nu_0\)</span> and <span class="math notranslate nohighlight">\(x\approx1.0\)</span> when <span class="math notranslate nohighlight">\(\nu_j\gg\nu_0\)</span>.</p>
<p>While the free rotor terms used for internal energies and heat capacities are the standard ones, the terms used for entropies have to use the rotors’ moments of inertia <span class="math notranslate nohighlight">\(\mu_{FR}\)</span> and symmetry <span class="math notranslate nohighlight">\(\sigma\)</span>, which formally cannot be calculated from harmonic frequencies alone. The correction scheme instead estimates each moment of inertia as being of a <span class="math notranslate nohighlight">\(\sigma=1\)</span> free rotor whose first excited state has an energy equal to the given <span class="math notranslate nohighlight">\(h\nu_{j}\)</span>. After this, each obtained moment of inertia <span class="math notranslate nohighlight">\(\mu_{FR}\)</span> is modified by an averaging moment of inertia <span class="math notranslate nohighlight">\(\mu_{av}\)</span> to avoid grossly overestimating entropies at very small frequencies (less than around 1 1/cm):</p>
<div class="math notranslate nohighlight">
\[\mu = \frac{\mu_{FR}\cdot\mu_{av}}{\mu_{FR}+\mu_{av}}\]</div>
<p><strong>Input options</strong></p>
<div class="highlight-none notranslate" id="ams-key-thermo"><div class="highlight"><pre><span></span>Thermo
   Temperatures float_list
   Pressure float
   LowFrequencyCorrector
      Alpha float
      Frequency float
      MomentOfInertia float
   End
End
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Thermo</span></code></dt>
<dd><table class="first docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Block</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Options for thermodynamic properties (assuming an ideal gas). The properties are computed for all specified temperatures.</td>
</tr>
</tbody>
</table>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Temperatures</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float List</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">[298.15]</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">Kelvin</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">List of temperatures at which the thermodynamic properties will be calculated.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Pressure</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">1.0</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">atm</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">The pressure at which the thermodynamic properties are computed.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LowFrequencyCorrector</span></code></dt>
<dd><table class="first docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Block</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Options for the dampener-powered free rotor interpolator that corrects thermodynamic quantities for low frequencies. See DOI:10.1021/jp509921r and DOI:10.1002/chem.201200497.</td>
</tr>
</tbody>
</table>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Alpha</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">4.0</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">The exponent term used in the dampener.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Frequency</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">100.0</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">cm-1</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">The frequency around which the dampener interpolates between harmonic oscillator and free rotor quantities.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MomentOfInertia</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">1e-44</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">kg m^2</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body">Averaging Moment of Inertia</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">The moment of inertia used to restrict entropy results for very small frequencies (generally around less than 1 cm-1).</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<table class="docutils footnote" frame="void" id="ref-free-rotor-correction1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[7]</a></td><td>Yi-Pei Li, Joseph Gomes, Shaama Mallikarjun Sharada, Alexis T. Bell, Martin Head-Gordon, <em>Improved Force-Field Parameters for QM/MM Simulations of the Energies of Adsorption for Molecules in Zeolites and a Free Rotor Correction to the Rigid Rotor Harmonic Oscillator Model for Adsorption Enthalpies</em>, <a class="reference external" href="https://doi.org/10.1021/jp509921r">J. Phys. Chem. C 2015, 119, 4, 1840-1850</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ref-free-rotor-correction2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[8]</a></td><td>Stefan Grimme, <em>Supramolecular Binding Thermodynamics by Dispersion‐Corrected Density Functional Theory</em>, <a class="reference external" href="https://doi.org/10.1002/chem.201200497">Chem. Eur. J., 18: 9955-9964</a></td></tr>
</tbody>
</table>
<div class="section" id="gibbs-free-energy-change-for-a-gas-phase-reaction">
<span id="gasphasegibbsfree"></span><h4>Gibbs free energy change for a gas phase reaction<a class="headerlink" href="#gibbs-free-energy-change-for-a-gas-phase-reaction" title="Permalink to this headline">¶</a></h4>
<p>Here an example is given how to calculate the free energy change for a reaction. In the AMS output of a normal modes calculation you can find the electronic bonding energy and nuclear kinetic energies, at room temperature. Example part of the AMS output of a nonlinear molecule:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Zero</span><span class="o">-</span><span class="n">point</span> <span class="n">energy</span> <span class="p">(</span><span class="n">Hartree</span><span class="p">):</span>     <span class="mf">0.0333</span>

<span class="o">...</span>
<span class="o">...</span>

<span class="n">Temp</span>                                                        <span class="n">Transl</span>      <span class="n">Rotat</span>     <span class="n">Vibrat</span>     <span class="n">Total</span>
<span class="o">----</span>                                                        <span class="o">------</span>      <span class="o">-----</span>     <span class="o">------</span>     <span class="o">-----</span>

<span class="mf">298.15</span>   <span class="n">Entropy</span> <span class="p">(</span><span class="n">cal</span><span class="o">/</span><span class="n">mol</span><span class="o">-</span><span class="n">K</span><span class="p">):</span>                              <span class="mf">34.441</span>     <span class="mf">11.474</span>      <span class="mf">0.137</span>     <span class="mf">46.052</span>
         <span class="n">Nuclear</span> <span class="n">Internal</span> <span class="n">Energy</span> <span class="p">(</span><span class="n">kcal</span><span class="o">/</span><span class="n">mol</span><span class="p">):</span>                <span class="mf">0.889</span>      <span class="mf">0.889</span>     <span class="mf">20.941</span>     <span class="mf">22.718</span>
         <span class="n">Constant</span> <span class="n">Volume</span> <span class="n">Heat</span> <span class="n">Capacity</span> <span class="p">(</span><span class="n">cal</span><span class="o">/</span><span class="n">mol</span><span class="o">-</span><span class="n">K</span><span class="p">):</span>         <span class="mf">2.981</span>      <span class="mf">2.981</span>      <span class="mf">0.565</span>      <span class="mf">6.526</span>

 <span class="n">Summary</span> <span class="n">of</span> <span class="n">energy</span> <span class="n">terms</span>
                                              <span class="n">hartree</span>              <span class="n">eV</span>         <span class="n">kcal</span><span class="o">/</span><span class="n">mol</span>           <span class="n">kJ</span><span class="o">/</span><span class="n">mol</span>
                                 <span class="o">--------------------</span>     <span class="o">-----------</span>       <span class="o">----------</span>      <span class="o">-----------</span>
 <span class="n">Energy</span> <span class="kn">from</span> <span class="nn">Engine</span><span class="p">:</span>               <span class="o">-</span><span class="mf">0.743995039793930</span>        <span class="o">-</span><span class="mf">20.2451</span>          <span class="o">-</span><span class="mf">466.86</span>         <span class="o">-</span><span class="mf">1953.36</span>
 <span class="n">Nuclear</span> <span class="n">Internal</span> <span class="n">Energy</span><span class="p">:</span>           <span class="mf">0.036203917534227</span>          <span class="mf">0.9852</span>            <span class="mf">22.72</span>            <span class="mf">95.05</span>
 <span class="n">Internal</span> <span class="n">Energy</span> <span class="n">U</span><span class="p">:</span>                <span class="o">-</span><span class="mf">0.707791122259703</span>        <span class="o">-</span><span class="mf">19.2599</span>          <span class="o">-</span><span class="mf">444.14</span>         <span class="o">-</span><span class="mf">1858.31</span>
 <span class="n">pV</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="n">RT</span><span class="p">:</span>                         <span class="mf">0.000944186013486</span>          <span class="mf">0.0257</span>             <span class="mf">0.59</span>             <span class="mf">2.48</span>
 <span class="n">Enthalpy</span> <span class="n">H</span><span class="p">:</span>                       <span class="o">-</span><span class="mf">0.706846936246217</span>        <span class="o">-</span><span class="mf">19.2343</span>          <span class="o">-</span><span class="mf">443.55</span>         <span class="o">-</span><span class="mf">1855.83</span>
 <span class="o">-</span><span class="n">T</span><span class="o">*</span><span class="n">S</span><span class="p">:</span>                             <span class="o">-</span><span class="mf">0.021880868282982</span>         <span class="o">-</span><span class="mf">0.5954</span>           <span class="o">-</span><span class="mf">13.73</span>           <span class="o">-</span><span class="mf">57.45</span>
 <span class="n">Gibbs</span> <span class="n">free</span> <span class="n">energy</span><span class="p">:</span>                <span class="o">-</span><span class="mf">0.728727804529199</span>        <span class="o">-</span><span class="mf">19.8297</span>          <span class="o">-</span><span class="mf">457.28</span>         <span class="o">-</span><span class="mf">1913.27</span>
</pre></div>
</div>
<p>The Energy from Engine = -466.86 kcal/mol. It depends on the engine how this energy is calculated.
In the ADF and BAND engines the energy is normally calculated with respect to (artificial) spherical averaged neutral atoms.</p>
<p>The Nuclear Internal Energy = zero point energy + 3 kT + small correction term = 22.72 kcal/mol.
3 kT = 3/2 kT for rotation, and 3/2 kT for translation (i.e. 1/2 kT for each degree of freedom).
The small correction term is a term due to the vibration partition function, depending on the temperature not only the ground state vibrational levels are occupied, see also the previous discussion.</p>
<p>The Internal Energy U = Energy from Engine + Nuclear Internal Energy = -466.86 + 22.72 = -444.14 kcal/mol.
Gas phase pV/n = RT = 8.314472 * 298.15 / 4184 = 0.59 kcal/mol. The enthalpy H = U + pV = -444.14 + 0.59 = -443.55 kcal/mol.
The Gibbs free energy G = H - TS = -443.55 - 298.15*46.052/1000 = -457.28 kcal/mol.</p>
<p>For a calculation of the free energy change for reaction (<span class="math notranslate nohighlight">\(\Delta\)</span> G), you will have to do this for the reactant and product molecules, and add and subtract these energies, for each molecule proportional to the number of molecules that take place in the reaction. Application of ADF for obtaining enthalpy, entropy and Gibbs free energy can for instance be obtained in Refs. <a class="footnote-reference" href="#ref9" id="id16">[9]</a> <a class="footnote-reference" href="#ref10" id="id17">[10]</a>.</p>
<table class="docutils footnote" frame="void" id="ref9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[9]</a></td><td>M. Swart, E. Rösler, and F. M. Bickelhaupt, <em>Proton affinities of maingroup-element hydrides and noble gases: Trends across the periodic table, structural effects, and DFT validation</em>, <a class="reference external" href="https://doi.org/10.1002/jcc.20431">Journal of Computational Chemistry 27, 1486 (2006)</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ref10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[10]</a></td><td>M. Swart, and F. M. Bickelhaupt, <em>Proton Affinities of Anionic Bases: Trends Across the Periodic Table, Structural Effects, and DFT Validation</em>, <a class="reference external" href="https://doi.org/10.1021/ct0502460">Journal of Chemical Theory and Computation 2, 281 (2006)</a>.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="moments-of-inertia">
<span id="index-22"></span><h3>Moments of inertia<a class="headerlink" href="#moments-of-inertia" title="Permalink to this headline">¶</a></h3>
<p>In case normal modes are computed in AMS, AMS also reports the moments of inertia of the molecule in units of amu bohr<sup>2</sup>  (amu = atomic mass unit) and its corresponding principal axes.</p>
<span class="target" id="index-23"></span><span class="target" id="index-24"></span></div>
<div class="section" id="partial-vibrational-spectra-pvdos">
<span id="pvdos"></span><span id="index-25"></span><h3>Partial Vibrational Spectra (PVDOS)<a class="headerlink" href="#partial-vibrational-spectra-pvdos" title="Permalink to this headline">¶</a></h3>
<p>The Partial Vibrational Spectra (also known as PVDOS) is computed by default whenever normal modes are requested.
The PVDOS <span class="math notranslate nohighlight">\(P_{I,n}\)</span> for atom <span class="math notranslate nohighlight">\(I\)</span> and normal mode <span class="math notranslate nohighlight">\(n\)</span> is defined as:</p>
<div class="math notranslate nohighlight">
\[P_{I,n} = \frac{m_I |\vec{\eta}_{I,n}|^2} {\sum_{J} m_J |\vec{\eta}_{J,n}|^2}\]</div>
<p>where <span class="math notranslate nohighlight">\(m_I\)</span> is the nuclear weight of atom <span class="math notranslate nohighlight">\(I\)</span>, and <span class="math notranslate nohighlight">\(\vec{\eta}_{I,n}\)</span> is the displacement vector for atom <span class="math notranslate nohighlight">\(I\)</span> in normal normal mode <span class="math notranslate nohighlight">\(n\)</span>.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">The Partial Vibrational Spectra (PVDOS) can be visualized using the <strong>AMSspectra</strong> GUI module (<strong>Vibrations → Partial Vibrational Spectra (PVDOS)</strong>). When plotting a partial vibrational spectrum, the IR intensity of normal modes is scaled by the corresponding PVDOS of the selected atoms.</p>
</div>
<div class="figure" id="id30">
<a class="reference internal image-reference" href="_images/pvdos.png"><img alt="_images/pvdos.png" src="_images/pvdos.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Example of partial vibrational spectrum (PVDOS). The dotted line is the full IR spectrum of 1-propanol. The solid line is the PVDOS-scaled IR spectrum of the OH group (IR spectrum computed using GFN1-xTB).</span></p>
</div>
<p>The PVDOS matrix is not printed to the text output, but only saved to the engine
binary output (.rkf) in the variable <code class="docutils literal notranslate"><span class="pre">Vibrations%PVDOS</span></code>.</p>
<span class="target" id="index-26"></span></div>
</div>
<div class="section" id="phonons">
<span id="index-27"></span><span id="id18"></span><h2>Phonons<a class="headerlink" href="#phonons" title="Permalink to this headline">¶</a></h2>
<p>Collective oscillations of atoms around theirs equilibrium positions, giving
rise to lattice vibrations, are called phonons. AMS can calculate phonon
dispersion curves within standard harmonic theory, implemented with a finite
difference method. Within the harmonic approximation we can calculate the
partition function and therefore thermodynamic properties, such as the specific
heat and the free energy.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="Examples/Phonons_Graphene.html#example-phonons-graphene"><span class="std std-ref">Example: Phonons for graphene</span></a>, <a class="reference internal" href="Examples/Phonons_Isotopes.html#example-phonons-isotopes"><span class="std std-ref">Example: Phonons with isotopes</span></a>, <a class="reference internal" href="Examples/Phonons_UserBZPath.html#example-phonons-userbzpath"><span class="std std-ref">Example: User-defined Brillouin zone for phonon dispersion</span></a> and <a class="reference external" href="../Tutorials/StructureAndReactivity/DiamondOptimizationAndPhonons.html">diamond lattice optimization and phonons tutorial</a></p>
</div>
<p>The calculation of phonons is enabled in the <code class="docutils literal notranslate"><span class="pre">Properties</span></code> block.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Properties
   Phonons Yes/No
End
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Phonon calculations should be performed on optimized geometries, <strong>including the lattice vectors</strong>. This can be done by either using an already optimized system as input, or by combining the phonon calculation with the <a class="reference internal" href="Tasks/Geometry_Optimization.html#geometryoptimization"><span class="std std-ref">geometry optimization task</span></a> (you should set the <code class="docutils literal notranslate"><span class="pre">GeometryOptimization%OptimizeLattice</span></code> input option to <code class="docutils literal notranslate"><span class="pre">True</span></code>).</p>
</div>
<p>The details of the phonon calculations are configured in the
<code class="docutils literal notranslate"><span class="pre">NumericalPhonons</span></code> block:</p>
<div class="highlight-none notranslate" id="ams-key-numericalphonons"><div class="highlight"><pre><span></span>NumericalPhonons
   SuperCell # Non-standard block. See details.
      ...
   End
   StepSize float
   DoubleSided Yes/No
   Interpolation integer
   NDosEnergies integer
   AutomaticBZPath Yes/No
   BZPath
      Path # Non-standard block. See details.
         ...
      End
   End
   Parallel
      nCoresPerGroup integer
      nGroups integer
      nNodesPerGroup integer
   End
End
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">NumericalPhonons</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SuperCell</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Non-standard block</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Used for the phonon run. The super lattice is expressed in the lattice vectors. Most people will find a diagonal matrix easiest to understand.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<p>The most important setting here is the super cell transformation. In principle
this should be as large as possible, as the phonon bandstructure converges with
the size of the super cell. In practice one may want to start with a 2x2x2 cell
and increase the size of the super cell until the phonon band structure
converges:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NumericalPhonons</span>
   <span class="n">SuperCell</span>
      <span class="mi">2</span> <span class="mi">0</span> <span class="mi">0</span>
      <span class="mi">0</span> <span class="mi">2</span> <span class="mi">0</span>
      <span class="mi">0</span> <span class="mi">0</span> <span class="mi">2</span>
   <span class="n">End</span>
<span class="n">End</span>
</pre></div>
</div>
<p>By default the phonon dispersion curves are computed for the standard path though the Brillouin zone (see <a class="reference external" href="https://doi.org/10.1016/j.commatsci.2010.05.010">https://doi.org/10.1016/j.commatsci.2010.05.010</a>). One can request the a different path using the following keywords (for an example of how to specify a user-defined path see <a class="reference internal" href="Examples/Phonons_UserBZPath.html#example-phonons-userbzpath"><span class="std std-ref">Example: User-defined Brillouin zone for phonon dispersion</span></a>):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NumericalPhonons
   AutomaticBZPath Yes/No
   BZPath
      Path # Non-standard block. See details.
         ...
      End
   End
End
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">NumericalPhonons</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">AutomaticBZPath</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Bool</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">Yes</td>
</tr>
<tr class="field-odd field"><th class="field-name">GUI name:</th><td class="field-body">Automatic BZ path</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">If True, compute the phonon dispersion curve for the standard path through the Brillouin zone. If False, you must specify your custom path in the [BZPath] block.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BZPath</span></code></dt>
<dd><table class="first docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Block</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">If [NumericalPhonons%AutomaticBZPath] is false, the phonon dispersion curve will be computed for the user-defined path in the [BZPath] block. You should define the vertices of your path in fractional coordinates (with respect to the reciprocal lattice vectors) in the [Path] sub-block. If you want to make a jump in your path (i.e. have a discontinuous path), you need to specify a new [Path] sub-block.</td>
</tr>
</tbody>
</table>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Path</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Non-standard block</td>
</tr>
<tr class="field-even field"><th class="field-name">Recurring:</th><td class="field-body">True</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">A section of a k space path. This block should contain multiple lines, and in each line you should specify one vertex of the path in fractional coordinates. Optionally, you can add text labels for your vertices at the end of each line.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>Other keywords in the <code class="docutils literal notranslate"><span class="pre">NumericalPhonons</span></code> block modify the details of the numerical differentiation
procedure and the accuracy of the results:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">NumericalPhonons</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">StepSize</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">0.04</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">Angstrom</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Step size to be taken to obtain the force constants (second derivative) from the analytical gradients numerically.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DoubleSided</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Bool</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">Yes</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">By default a two-sided (or quadratic) numerical differentiation of the nuclear gradients is used. Using a single-sided (or linear) numerical differentiation is computationally faster but much less accurate. Note: In older versions of the program only the single-sided option was available.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Interpolation</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">100</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Use interpolation to generate smooth phonon plots.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NDosEnergies</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">1000</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Nr. of energies used to calculate the phonon DOS used to integrate thermodynamic properties. For fast compute engines this may become time limiting and smaller values can be tried.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<p>The numerical phonon calculation supports AMS’ <a class="reference internal" href="Input_Output.html#driverlevelparallelism"><span class="std std-ref">double parallelization</span></a>, which can perform the calculations for the individual displacements in parallel. This is configured automatically, but can be further tweaked using the keys in the <code class="docutils literal notranslate"><span class="pre">NumericalPhonons%Parallel</span></code> block:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NumericalPhonons
   Parallel
      nCoresPerGroup integer
      nGroups integer
      nNodesPerGroup integer
   End
End
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">NumericalPhonons</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Parallel</span></code></dt>
<dd><table class="first docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Block</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Options for double parallelization, which allows to split the available processor cores into groups working through all the available tasks in parallel, resulting in a better parallel performance. The keys in this block determine how to split the available processor cores into groups working in parallel.</td>
</tr>
</tbody>
</table>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">nCoresPerGroup</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body">Cores per group</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Number of cores in each working group.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nGroups</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body">Number of groups</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Total number of processor groups. This is the number of tasks that will be executed in parallel.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nNodesPerGroup</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body">Nodes per group</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Number of nodes in each group. This option should only be used on homogeneous compute clusters, where all used compute nodes have the same number of processor cores.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<span class="target" id="raman"></span></div>
<div class="section" id="resonance-raman">
<span id="index-28"></span><h2>(Resonance) Raman<a class="headerlink" href="#resonance-raman" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id19">
<h3>Raman<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>In this method the Raman scattering spectrum is calculated from the geometrical derivatives of the frequency-dependent polarizability. Engine ADF is required.
Raman scattering intensities and depolarization ratios for all or a selected number of molecular vibrations at a certain laser frequency can be calculated.
The Raman scattering calculation is very similar to an IR intensity calculation.
In fact, all IR output is automatically generated as well.
At all distorted geometries the dipole polarizability tensor is calculated.
This is time-consuming and is only feasible for small molecules.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Properties
   Raman Yes/No
End
</pre></div>
</div>
<div class="highlight-none notranslate" id="ams-key-raman"><div class="highlight"><pre><span></span>Raman
   IncidentFrequency float
   FreqRange float_list
End
</pre></div>
</div>
<p>If a <code class="docutils literal notranslate"><span class="pre">FreqRange</span></code> is included the Raman intensities are calculated for a range of vibrational frequencies only.
Using this option is a fast alternative for calculating all Raman intensities.</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Properties</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Raman</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Bool</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">No</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Requests calculation of Raman intensities for vibrational normal modes.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Raman</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">IncidentFrequency</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">0.0</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">eV</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Frequency of incident light.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FreqRange</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float List</td>
</tr>
<tr class="field-even field"><th class="field-name">Unit:</th><td class="field-body">cm-1</td>
</tr>
<tr class="field-odd field"><th class="field-name">Recurring:</th><td class="field-body">True</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body">Frequency range</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Specifies a frequency range within which all modes will be scanned. 2 numbers: an upper and a lower bound.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="resonance-raman-excited-state-finite-lifetime">
<span id="index-29"></span><h3>Resonance Raman: excited-state finite lifetime<a class="headerlink" href="#resonance-raman-excited-state-finite-lifetime" title="Permalink to this headline">¶</a></h3>
<p>Resonance Raman spectroscopy uses incident light with a wavelength close to that of an electronic transition.
In this method (Ref. <a class="footnote-reference" href="#ref5" id="id20">[11]</a>) the resonance Raman-scattering (RRS) spectra is calculated from the geometrical derivatives of the frequency-dependent polarizability. Engine ADF is required.
The polarizability derivatives are calculated from resonance polarizabilities by including a finite lifetime (phenomenological parameter) of the electronic excited states.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Raman
   FreqRange float_list
   IncidentFrequency float
   LifeTime float
End
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Raman</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">FreqRange</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float List</td>
</tr>
<tr class="field-even field"><th class="field-name">Unit:</th><td class="field-body">cm-1</td>
</tr>
<tr class="field-odd field"><th class="field-name">Recurring:</th><td class="field-body">True</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body">Frequency range</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Specifies a frequency range within which all modes will be scanned. 2 numbers: an upper and a lower bound.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IncidentFrequency</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">0.0</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">eV</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Frequency of incident light.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LifeTime</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">0.0</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">hartree</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Specify the resonance peak width (damping) in Hartree units. Typically the lifetime of the excited states is approximated with a common phenomenological damping parameter. Values are best obtained by fitting absorption data for the molecule, however, the values do not vary a lot between similar molecules, so it is not hard to estimate values. A typical value is 0.004 Hartree.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<p>It is similar to the simple excited-state gradient approximation method (see next section) if only one electronic excited state is important, however, it is not restricted to only one electronic excited state. In the limit that there is only one possible state in resonance the two methods should give more or less the same results. However, for many states and high-energy states  and to get resonance Raman profiles (i.e., Raman intensities as a function of the energy of the incident light beam) this approach might be more suitable. The resonance Raman profiles in this approach are averaged profiles since vibronic coupling effects are not accounted for.</p>
<table class="docutils footnote" frame="void" id="ref5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[11]</a></td><td>L. Jensen, L. Zhao, J. Autschbach and G.C. Schatz, <em>Theory and method for calculating resonance Raman scattering from resonance polarizability derivatives</em>, <a class="reference external" href="https://doi.org/10.1063/1.2046670">Journal of Chemical Physics 123, 174110 (2005)</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="resonance-raman-vg-fc">
<span id="imdhoresonanceraman"></span><h3>Resonance Raman: VG-FC<a class="headerlink" href="#resonance-raman-vg-fc" title="Permalink to this headline">¶</a></h3>
<p>According to a the time-dependent picture of resonance-Raman (RR) scattering the relative intensities of RR scattering cross sections are, under certain assumptions, proportional to the square of the excited-state energy gradients projected onto the ground-state normal modes of the molecule (see Ref. <a class="footnote-reference" href="#ref7" id="id21">[12]</a>). For an alternative implementation of RR scattering using a finite lifetime of the excited states, and a discussion of some of the differences, see the previous section. Engine ADF or DFTB is required.</p>
<p>The vertical gradient Franck-Condon (VG-FC) method, also called the Independent Mode Displaced Harmonic Oscillator (IMDHO) model,
we use to calculate vibrationally resolved absorption spectra can also be applied to the calculation of resonance Raman spectra.
In resonance Raman spectroscopy a molecule is excited from its ground state to some electronically excited state. After a short period of time, the molecule then relaxes back to its electronic ground state. However, when doing so, it might end up in a different vibrational state than it started off in. The result is an energy difference between the incident and emmitted photon. One can then plot the intensity for different energy differences to produce what is known as a Raman spectra. Resonance Raman spectroscopy uses incident light with a wavelength close to that of an electronic transition.</p>
<p>AMS supports the calculation of such spectra by modeling the vibronic coupling of electronic transitions using the VG-FC model. This model is discussed also on the <a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#imdhovibronicstructure"><span class="std std-ref">Vibronic-Structure</span></a> documentation page. Here we will discuss the modifications necessary to use the VG-FC model for resonance Raman spectroscopy. It is worth noting that this VG-FC resonance Raman application does not support the mode selective options. As a result the VG-FC Resonance Raman application will always first perform a full frequency analysis to obtain its normal modes.</p>
<div class="section" id="id22">
<h4>Theory<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<p>While the basic theory behind the VG-FC model is explained in detail on the <a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#imdhovibronicstructure"><span class="std std-ref">Vibronic-Structure</span></a> documentation page, we will briefly summarize the most important points here, as well as the modifications necessary for its application to resonance Raman spectroscopy. It applies the harmonic approximation to both the ground state and excited state PES and then goes on to assume that neither frequency changes nor normal mode rotations occur. Thus the excited state PES is a shifted version of the ground state PES. We do not include temperature effects (so all initial states will be ground states) and work at the Franck-Condon point. Under these assumptions, the Raman polarizability of a particular excited state n, for a transition between initial and final vibrational states I and F can be written as:</p>
<div class="math notranslate nohighlight">
\[(\alpha_{n,ij})_{F\leftarrow I}  = \mu_{n,i}\mu_{n,j} \int_{0}^{\infty} \langle F|I_n(t)\rangle e^{i[\omega -(E_{n,0}-E_{m,0})]t}\cdot e^{-\Gamma t}dt\]</div>
<p>Here, <span class="math notranslate nohighlight">\(i,j\)</span> label the components of the polarizability tensor and <span class="math notranslate nohighlight">\(\langle F|I_n(t)\rangle\)</span> denotes the overlap of the initial state I, propagated along the excited state PES with the final state F. Under the <a class="reference internal" href="Vibrationally_resolved_electronic_spectra.html#vibrationallyresolvedelectronicspectra"><span class="std std-ref">assumptions of the VG-FC model</span></a>, this overlap is equal to:</p>
<div class="math notranslate nohighlight">
\[\langle F|I_n(t)\rangle = \prod_{j=1}^{N_{modes}}\left\{\frac{(-1)^{m_j}\Delta^{m_j}}{2^{m_j/2}m_j!}(1 - e^{-i\omega_jt})^{m_j}\right\}\exp\bigg[-\frac{\Delta_{n,j}^2}{2}(1-e^{-i\omega_jt})\bigg]\]</div>
<p>Where the <span class="math notranslate nohighlight">\(m_j\)</span> denote the excitation number of mode j in final state F. For a more detailed discussion, we refer to <a class="footnote-reference" href="#ref6" id="id23">[13]</a>. The only parameters that appear in our expression are the dimensionless oscillator displacements <span class="math notranslate nohighlight">\(\Delta_{n,j}\)</span> that represent displacement of the excited state PES along normal mode j. Under the simplifying assumptions of the VG-FC, these can be obtained from the ground state normal modes and a single excited state gradient. The Raman intensity is then proportional to the square of the polarizabilities:</p>
<div class="math notranslate nohighlight">
\[\sigma(\omega)_{F\leftarrow I} \propto \sum_{i,j}|\sum_n (\alpha_{n,ij})_{F\leftarrow I}|^2\]</div>
<p>A spectrum is then generated by including various different final states F, which are defined by different combinations of normal mode excitation numbers, and assigning a relative intensity to each transition equal to the above expression. AMS only supports spectra which display relative intensities so the results are plotted in arbitrary units and are normalized such that the largest peak reaches an intensity of 1.</p>
</div>
<div class="section" id="id24">
<h4>Input<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h4>
<p>The calculation setup for resonance Raman spectra largely proceeds as it does for <a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#imdhovibronicstructure"><span class="std std-ref">Absorption Spectra</span></a>. We need a set of ground state normal modes as well as an excited state gradient. The former are calculated at the start using the selected AMS engine, or, in case the user has a pre-calculated set of normal modes, these can be read from a .rkf file using the <code class="docutils literal notranslate"><span class="pre">ModeFile</span></code> key in the <code class="docutils literal notranslate"><span class="pre">NormalModes</span></code> sub-block. In this latter case, the engine is not used. The <code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code> block can be used to select specific modes from the full set of normal modes for which the spectrum should be calculated. For details see the <a class="reference internal" href="#modeselect"><span class="std std-ref">Mode Select</span></a> documentation on the main page. If one simply wants the spectrum for the full set of normal modes, the <code class="docutils literal notranslate"><span class="pre">Full</span></code> key in the <code class="docutils literal notranslate"><span class="pre">ModeSelect</span></code> block can be set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. The excited state information is passed to the application via the <code class="docutils literal notranslate"><span class="pre">ExcitationSettings</span></code> block.</p>
<p>Another point to note is that since our states are labeled by discrete indices we will be calculating stick spectra (which can be homogeneously broadened in amsspectra). By contrast, the absorption spectra produced by <code class="docutils literal notranslate"><span class="pre">VibronicStructure</span></code> are raw x,y data. Due to this difference in nature of the Raman spectrum compared to the absorption spectrum, this method uses the <code class="docutils literal notranslate"><span class="pre">ResonanceRaman</span></code> block for input options related to its spectrum (as opposed to the <code class="docutils literal notranslate"><span class="pre">AbsorptionSpectrum</span></code> block).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ExcitationSettings</span></code> block is discussed on the <a class="reference internal" href="Tasks/VibrationalAnalysis/Vibrationally_resolved_electronic_spectra.html#excitationsettings"><span class="std std-ref">Vibronic-Structure</span></a> page. One important difference with the latter is that Resonance Raman calculations are supported for more than one excitation at once. This is more important for the case of Raman spectra as the intensity associated with a set of transitions is not equal to the sum of their individual intensities (we sum over electronic states n before we square the polarizabilities). Here we will address settings specific to the Raman spectrum, all of which can be found in the <code class="docutils literal notranslate"><span class="pre">ResonanceRaman</span></code> block. A short example of how a typical input file might look is included at the end of this section.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Task</span> <span class="n">VibrationalAnalysis</span>
<span class="n">VibrationalAnalysis</span>
   <span class="n">Task</span> <span class="n">ResonanceRaman</span>
   <span class="n">ResonanceRaman</span>
      <span class="n">IncidentFrequency</span> <span class="nb">float</span>
      <span class="n">LifeTime</span> <span class="nb">float</span>
      <span class="n">RamanOrder</span> <span class="n">integer</span>
      <span class="n">RamanRange</span> <span class="n">float_list</span>
      <span class="n">MaximumStates</span> <span class="n">integer</span>
   <span class="n">End</span>
   <span class="o">...</span>
<span class="n">End</span>
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">IncidentFrequency</span> <span class="pre">float</span></code></dt>
<dd>Frequency of incident light.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LifeTime</span> <span class="pre">float</span></code></dt>
<dd>sets the value of <span class="math notranslate nohighlight">\(\Gamma\)</span> (in Hartree) that controls the
exponential damping in our integral. This phenomenological parameter can be interpreted as the (inverse) life time of the Raman excited state and can be used to help the results agree with experiment. The default value of 4.5e-4 is on the low end of reasonable values but should provide a good starting point for most cases.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RamanOrder</span> <span class="pre">integer</span></code></dt>
<dd>determines the set of final states and overtones to be
included in the spectrum. It is an integer and the application considers only final states such that the sum of excitation numbers of all normal modes is less than or equal to this number. Setting this to 1 means we only include the fundamental band.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RamanRange</span> <span class="pre">float_list</span></code></dt>
<dd>this keyword specifies the frequency range (in
<span class="math notranslate nohighlight">\(cm^{-1}\)</span>) the Raman shift is restricted to lie in. This prevents us from including excessively many states and overtones for high frequency modes. The default is [0, 2000] <span class="math notranslate nohighlight">\(cm^{-1}\)</span> but this can be changed to whatever is desired.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MaximumStates</span> <span class="pre">integer</span></code></dt>
<dd>Expert key. Due to the combinatorial explosion of included final states that occurs for
combinations of large values of the raman order, large molecules and wide spectrum ranges, there is a maximum number of final states that can be included in the spectrum. This is to prevent the program from using excessive amounts of memory/computation times.
The user can set this number using the <code class="docutils literal notranslate"><span class="pre">MaximumStates</span></code> key but this should be done with caution.</dd>
</dl>
<p>Finally we give an example of a typical <code class="docutils literal notranslate"><span class="pre">VibrationalAnalysis</span></code> block for a resonance Raman calculation. This also gives an idea of how the settings that were not explicitly mentioned above work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VibrationalAnalysis</span>
   <span class="n">Type</span> <span class="n">ResonanceRaman</span>
   <span class="n">NormalModes</span>
     <span class="n">ModeSelect</span>
       <span class="n">Full</span> <span class="kc">True</span>
     <span class="n">End</span>
   <span class="n">End</span>
   <span class="n">ExcitationSettings</span>
     <span class="n">ExcitationInfo</span> <span class="n">File</span>
     <span class="n">ExcitationFile</span> <span class="o">./</span><span class="n">your_excitation</span><span class="o">/</span><span class="n">dftb</span><span class="o">.</span><span class="n">rkf</span>
     <span class="n">Singlet</span>
       <span class="n">A</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span>
     <span class="n">End</span>
   <span class="n">End</span>
   <span class="n">ResonanceRaman</span>
     <span class="n">RamanOrder</span> <span class="mi">3</span>
     <span class="n">RamanRange</span> <span class="mf">0.0</span> <span class="mf">3000.0</span>
   <span class="n">End</span>
<span class="n">End</span>
</pre></div>
</div>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="ref7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[12]</a></td><td>J. Neugebauer, E.J. Baerends, E. Efremov, F. Ariese and C. Gooijer, <em>Combined Theoretical and Experimental Deep-UV Resonance Raman Studies of Substituted Pyrenes</em>, <a class="reference external" href="https://doi.org/10.1021/jp045360d">Journal of Physical Chemistry A 109, 2100 (2005)</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ref6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[13]</a></td><td>T. Petrenko and F. Neese, <em>Analysis and prediction of absorption band shapes, fluorescence band shapes, resonance Raman intensities, and excitation profiles using the time-dependent theory of electronic spectroscopy</em> <a class="reference external" href="https://doi.org/10.1063/1.2770706">The Journal of Chemical Physics 127, 164319 (2007)</a></td></tr>
</tbody>
</table>
<span class="target" id="vroa"></span><span class="target" id="index-30"></span><span class="target" id="index-31"></span></div>
</div>
</div>
<div class="section" id="vroa-resonance-vibrational-raman-optical-activity">
<span id="index-32"></span><h2>VROA: (Resonance) vibrational Raman optical activity<a class="headerlink" href="#vroa-resonance-vibrational-raman-optical-activity" title="Permalink to this headline">¶</a></h2>
<p>The normal and resonance VROA spectra are calculated from geometric derivatives of the different generalized polarizabilities obtained using linear response theory which may include a damping term to account for the finite lifetime. Engine ADF is required.
These polarizabilities are the electric dipole - electric dipole polarizability, the electric dipole - magnetic dipole polarizability, and the the electric dipole - electric quadrupole polarizability.
For resonance VROA one should include a finite lifetime.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Properties
   VROA Yes/No
End
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Raman
   FreqRange float_list
   IncidentFrequency float
   LifeTime float
End
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Properties</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">VROA</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Bool</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">No</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Requests calculation of VROA for vibrational normal modes.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Raman</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">FreqRange</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float List</td>
</tr>
<tr class="field-even field"><th class="field-name">Unit:</th><td class="field-body">cm-1</td>
</tr>
<tr class="field-odd field"><th class="field-name">Recurring:</th><td class="field-body">True</td>
</tr>
<tr class="field-even field"><th class="field-name">GUI name:</th><td class="field-body">Frequency range</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Specifies a frequency range within which all modes will be scanned. 2 numbers: an upper and a lower bound.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IncidentFrequency</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">0.0</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">eV</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Frequency of incident light.</td>
</tr>
</tbody>
</table>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LifeTime</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Float</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">0.0</td>
</tr>
<tr class="field-odd field"><th class="field-name">Unit:</th><td class="field-body">hartree</td>
</tr>
<tr class="field-even field"><th class="field-name">Description:</th><td class="field-body">Specify the resonance peak width (damping) in Hartree units. Typically the lifetime of the excited states is approximated with a common phenomenological damping parameter. Values are best obtained by fitting absorption data for the molecule, however, the values do not vary a lot between similar molecules, so it is not hard to estimate values. A typical value is 0.004 Hartree.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<div class="section" id="engine-adf">
<h3>Engine ADF<a class="headerlink" href="#engine-adf" title="Permalink to this headline">¶</a></h3>
<p>In the ADF engine a method is implemented to calculate both on- and off-resonance vibrational Raman optical activities (VROAs) of molecules using time-dependent density functional theory, see Ref. <a class="footnote-reference" href="#ref15" id="id25">[14]</a>.
This is an extension of a method to calculate the normal VROA by including a finite lifetime of the electronic excited states in all calculated properties.
The method is based on a short-time approximation to Raman scattering and is, in the off-resonance case, identical to the standard theory of Placzek.
The normal and resonance VROA spectra are calculated from geometric derivatives of the different generalized polarizabilities obtained using linear response theory which includes a damping term to account for the finite lifetime.
Gauge-origin independent results for normal VROA have been ensured using either the modified-velocity gauge or gauge-included atomic orbitals.
In ADF2016 the velocity gauge tensors required for the calculation of VROA are now correctly calculated with the life time damping parameter.
With these complex tensors fixed, resonance VROA intensities are now origin invariant in the velocity gauge, see also Ref. <a class="footnote-reference" href="#ref16" id="id26">[15]</a>.</p>
<table class="docutils footnote" frame="void" id="ref15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[14]</a></td><td>L. Jensen, J. Autschbach, M. Krykunov, and G.C. Schatz, <em>Resonance vibrational Raman optical activity: A time-dependent density functional theory approach</em>, <a class="reference external" href="https://doi.org/10.1063/1.2768533">Journal of Chemical Physics 127, 134101 (2007)</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ref16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26">[15]</a></td><td>D.V. Chulhai and L. Jensen, <em>Simulating Surface-Enhanced Raman Optical Activity Using Atomistic Electrodynamics-Quantum Mechanical Models</em>, <a class="reference external" href="https://doi.org/10.1021/jp502107f">Journal of Physical Chemistry A 118, 9069 (2014)</a></td></tr>
</tbody>
</table>
<span class="target" id="vcd"></span><span class="target" id="index-33"></span></div>
</div>
<div class="section" id="vcd-vibrational-circular-dichroism">
<span id="index-34"></span><h2>VCD: Vibrational Circular Dichroism<a class="headerlink" href="#vcd-vibrational-circular-dichroism" title="Permalink to this headline">¶</a></h2>
<p>Vibrational circular dichroism (VCD) is the differential absorption of left and right circularly polarized infrared light by vibrating molecules. Most engines can be used to calculate VCD with the approximate Atomic polar tensor (APT) model. Engine ADF is required for the more accurate analytical VCD.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Properties
   VCD Yes/No
End
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">Properties</span></code></dt>
<dd><dl class="first last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">VCD</span></code></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Bool</td>
</tr>
<tr class="field-even field"><th class="field-name">Default value:</th><td class="field-body">No</td>
</tr>
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Requests calculation of VCD for vibrational normal modes.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<p><a class="reference internal" href="Utilities/VCDtools.html#vcdtools"><span class="std std-ref">VCDtools</span></a> is a program that can be used to do an analysis of the VCD spectrum. <a class="reference internal" href="Utilities/VCDtools.html#vcdtools"><span class="std std-ref">VCDtools</span></a> can be used with the AMS-GUI module AMSspectra.</p>
<span class="target" id="index-35"></span><div class="section" id="atomic-polar-tensor-apt-model">
<span id="index-36"></span><h3>Atomic polar tensor (APT) model<a class="headerlink" href="#atomic-polar-tensor-apt-model" title="Permalink to this headline">¶</a></h3>
<p>In the so-called atomic polar tensor (APT) model the atomic axial tensors (AATs) can be calculated from electric dipole gradients.
Note that the APT model may not be very reliable for predicting VCD bands and its implementation should not be blindly applied beyond a quick assessment.
Results using the engine DFTB can be found in <a class="footnote-reference" href="#ref18" id="id27">[16]</a>.</p>
<p>For the engines BAND and DFTB only the APT model can be used.
In case of the engine ADF the default is to calculate the VCD analytically, see next section.
One can calculate VCD using the APT model with the ADF engine if one includes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NormalModes</span>
  <span class="n">Hessian</span> <span class="n">Numerical</span>
<span class="n">End</span>
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="ref18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27">[16]</a></td><td>T.Q. Teodoro, M.A.J. Koenis, R. Rüger, S.E. Galembeck, W.J. Buma, V.P. Nicu, L. Vissche, <em>Use of Density Functional Based Tight Binding Methods in Vibrational Circular Dichroism</em>, <a class="reference external" href="https://doi.org/10.1021/acs.jpca.8b08218">Journal of Physical Chemistry A 122, 9435 (2018)</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="analytical-vcd-in-adf">
<h3>Analytical VCD in ADF<a class="headerlink" href="#analytical-vcd-in-adf" title="Permalink to this headline">¶</a></h3>
<p>In the ADF engine the VCD intensities are calculated using Stephens’ equations for VCD.
For the calculation of the atomic axial tensors (AATs), analytical derivatives techniques and London atomic orbitals (the so called GIAO) are employed.
As a result the calculated rotational strengths are origin independent, and therefore the common origin gauge is used <a class="footnote-reference" href="#ref8" id="id28">[17]</a>.</p>
<p>New in AMS2020 is that one can calculate analytical VCD also for open-shell systems in a spin-unrestricted calculation.</p>
<p>Calculation of the AATs requires an analytical frequencies calculation.
This limits the choice of functionals that can be used for VCD calculations.</p>
<p>The accuracy of the vibrational rotational strengths are determined by the accuracy of the harmonic force field, atomic polar tensors (APTs) and AATs.
The most critical parameter being the harmonic force field. Thus, for a fair comparison with experimental data, accurate geometries and functionals that yield accurate force fields (e.g. BP86, OLYP, etc) should be used.
Our tests showed that the BP86 functional in combination with TZP basis sets is always a safe choice.
For a comparison of VCD spectra calculated with various functionals (e.g BP86, OLYP, BLYP,  B3PW91 and B3LYP) see <a class="footnote-reference" href="#ref8" id="id29">[17]</a>.
Regarding the geometries, we recommend the following strict settings, 10<sup>-4</sup> for the geometry convergence of the gradients,
and BeckeGrid quality good. The default settings should be used for the calculation of the frequencies.</p>
<p>By default, only the vibrational rotational strengths are printed in the AMS output file.
For a deeper insight regarding the origin of the VCD intensity of a given normal mode one can use the auxiliary program <a class="reference internal" href="Utilities/VCDtools.html#vcdtools"><span class="std std-ref">VCDtools</span></a>.
<a class="reference internal" href="Utilities/VCDtools.html#vcdtools"><span class="std std-ref">VCDtools</span></a> can be used with the ADF-GUI module ADFspectra.</p>
<table class="docutils footnote" frame="void" id="ref8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[17]</td><td><em>(<a class="fn-backref" href="#id28">1</a>, <a class="fn-backref" href="#id29">2</a>)</em> V.P. Nicu J. Neugebauer S.K. Wolff and E.J. Baerends, <em>A vibrational circular dichroism implementation within a Slater-type-orbital based density functional framework and its application to hexa- and hepta-helicenes</em>, <a class="reference external" href="https://doi.org/10.1007/s00214-006-0234-x">Theoretical Chemical Accounts 119, 245 (2008)</a></td></tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
          </div>
          <!--STARTNOSOLR-->
<footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Vibrationally_resolved_electronic_spectra.html" class="btn btn-neutral float-right" title="Vibrationally resolved electronic spectra" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Gradients_Stress_Elasticity.html" class="btn btn-neutral" title="Gradients, Hessian, Stress tensor, Elasticity" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/> 

<!-- start :: footer -->
		<footer class="site-footer block">
			<div class="container">
				<div class="row">
					<div class="footer-column" >
	<ul>
		<li id="nav_menu-2" class="widget widget_nav_menu "><h3>Application Areas</h3><div class="menu-application-areas-container"><ul id="menu-application-areas" class="menu">
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/batteries/">Batteries &#038; PVs</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/chemical-bonding-analysis/">Bonding Analysis</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/catalysis/">Catalysis</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/heavy-elements/">Heavy Elements</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/inorganic-chemistry/">Inorganic Chemistry</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/pharma/">Life Sciences</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/materials-science/">Materials Science</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/nanotechnology/">Nanotechnology</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/oil-and-gas/">Oil and Gas</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/organic-electronics/">Organic Electronics</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/polymers/">Polymers</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/spectroscopy/">Spectroscopy</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/applications/teaching/">Teaching</a></li>
</ul></div></li>	</ul>
</div><div class="footer-column" >
	<ul>
		<li id="nav_menu-7" class="widget widget_nav_menu "><h3>Products</h3><div class="menu-product-navigation-container"><ul id="menu-product-navigation" class="menu">
<li id="menu-item-40263" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-40263"><a href="https://www.scm.com/product/ams/">AMS Driver</a></li>
<li id="menu-item-7235" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7235"><a href="https://www.scm.com/product/adf/">ADF</a></li>
<li id="menu-item-7236" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7236"><a href="https://www.scm.com/product/band_periodicdft/">BAND</a></li>
<li id="menu-item-7237" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7237"><a href="https://www.scm.com/product/cosmo-rs/">COSMO-RS</a></li>
<li id="menu-item-7238" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7238"><a href="https://www.scm.com/product/dftb/">DFTB</a></li>
<li id="menu-item-7239" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7239"><a href="https://www.scm.com/product/gui/">GUI</a></li>
<li id="menu-item-44383" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-44383"><a href="https://www.scm.com/product/machine-learning-potentials/">MLPotential</a></li>
<li id="menu-item-7240" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7240"><a href="https://www.scm.com/product/mopac/">MOPAC</a></li>
<li id="menu-item-40262" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-40262"><a href="https://www.scm.com/product/plams/">PLAMS</a></li>
<li id="menu-item-43701" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-43701"><a href="https://www.scm.com/product/quantum-espresso/">Quantum ESPRESSO</a></li>
<li id="menu-item-7241" class="menu-item menu-item-type-post_type menu-item-object-product menu-item-7241"><a href="https://www.scm.com/product/reaxff/">ReaxFF</a></li></ul></div></li><li id="nav_menu-26" class="widget widget_nav_menu "><div class="menu-licensing-container"><ul id="menu-licensing" class="menu"><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/pricing-licensing/">Pricing &#038; Licensing</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/pricing-licensing/price-quote/">Price Quote</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/pricing-licensing/price-quote/calculate-your-price/">Price Calculator</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/consulting/">Scientific Consulting</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/pricing-licensing/adf-resellers/">Resellers</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/pricing-licensing/scm-license-terms/">License Terms</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/pricing-licensing/ordering-procedure/">Ordering</a></li>
</ul></div></li>	</ul>
</div><div class="footer-column" >
	<ul>
		<li id="nav_menu-6" class="widget widget_nav_menu "><h3>Support</h3><div class="menu-support-navigation-container"><ul id="menu-support-navigation" class="menu"><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/support/">Support Overview</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/support/ams-installation-videos/">Installation</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/support/ams-tutorials-and-manuals/">Documentation</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/doc/Tutorials/GUI_overview/GUI_overview_tutorials.html">GUI Tutorials</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/support/downloads/">Downloads</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/faq/">FAQs</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/adf-discussion-list/">Discussion List</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/support/documentation-previous-versions/release-notes/">Release Notes</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/support/adf-teaching-materials/">Teaching Materials</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/news-agenda/adf-hands-on-workshops/">Workshops</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/news-agenda/web-presentations-by-adf-experts/">Webinars</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/videos-tutorials-and-web-presentations/">Videos</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/amsterdam-modeling-suite/brochures/">Brochure</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/amsterdam-modeling-suite/research-papers-citing-adf/">Papers Citing ADF</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/category/highlights/">Literature Highlights</a></li>
</ul></div></li>	</ul>
</div><div class="footer-column" >
	<ul>
		<li id="nav_menu-28" class="widget widget_nav_menu "><h3>About Us</h3><div class="menu-about-us-container"><ul id="menu-about-us" class="menu"><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/contact-us/">Contact Us</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/eu-projects/">EU Projects</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/our-authors/">Contributors</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/our-people/">The SCM Team</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/collaborations/">Collaborations</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/careers/">Careers</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/mission-vision/">Mission &#038; Vision</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/newsletters/">Newsletters</a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom"><a href="https://www.scm.com/category/news/">News</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://www.scm.com/about-us/news-agenda/">Events</a></li>
</ul></div></li>	</ul>
</div><div class="footer-column" >
	<ul>
			</ul>
</div>				</div>
			</div>
		</footer>
		<footer class="disclaimer-footer">
			<img src="https://www.scm.com/wp-content/themes/scm/images/logos/scm-logo-compact.svg" alt="">
			<nav class="menu-service-navigation-container"><ul id="menu-service-navigation" class="menu-service navbar-nav"><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-73"><a href="https://www.scm.com/copyright/">Copyright</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-72"><a href="https://www.scm.com/terms-of-use/">Terms of Use</a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-privacy-policy menu-item-71"><a href="https://www.scm.com/privacy-policy/">Privacy Policy</a></li>
</ul></nav></footer>	
		<!-- end :: footer -->

<!--ENDNOSOLR-->
        </div>
      </div>

    </section>
  </div>
  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2021.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>

    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NCRWHZZ"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/language_data.js"></script>
      <script type="text/javascript" src="_static/../../MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>